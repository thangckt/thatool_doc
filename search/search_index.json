{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>thmd</code> Documentation","text":""},{"location":"#thmd","title":"<code>thmd</code>","text":"<p>Python package for building models, pre-processing and post-processing Molecular Dynamics simulations.</p> <p>Developed and maintained by C.Thang Nguyen</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#thmd","title":"<code>thmd</code>","text":"<p>Python package for building models, pre-processing and post-processing Molecular Dynamics simulations.</p> <p>Developed and maintained by C.Thang Nguyen</p> <p>Modules:</p> <ul> <li> <code>calc</code>           \u2013            </li> <li> <code>io</code>           \u2013            <p>This module contains classes and functions to read/write data in various formats.</p> </li> <li> <code>latex</code>           \u2013            </li> <li> <code>model</code>           \u2013            </li> <li> <code>plot</code>           \u2013            <p>This module provides functions and class to produce publication-quality figures. The main idea is to create a handy class which setup all necessary parameters for plotting, and then just call its methods to produce the publication-quality figures.</p> </li> <li> <code>post</code>           \u2013            </li> <li> <code>qflow</code>           \u2013            </li> <li> <code>recipe</code>           \u2013            </li> <li> <code>util</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>__description__</code>           \u2013            </li> <li> <code>__long_description__</code>           \u2013            </li> <li> <code>__author__</code>           \u2013            </li> <li> <code>mySTR</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.__description__","title":"<code>__description__ = 'Python package'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__long_description__","title":"<code>__long_description__ = 'Python package for pre- and post-processing data from MD simulations.'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__author__","title":"<code>__author__ = 'thangckt'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.mySTR","title":"<code>mySTR = '\\n```shell\\n    thmd_package\\n    \u2502__ README.md\\n    \u2502__ LICENSE.md\\n    \u2502__ setup.py\\n    \u2502\\n    \u2502__ thmd\\n        \u2502__ __init__.py\\n        \u2502__ data.py\\n        \u2502\\n        \u2502__ io\\n        \u2502   \u2502__ __init__.py\\n        \u2502   \u2502__ define_script.py\\n        \u2502   \u2502__ LmpFrame.py\\n        \u2502   \u2502__ ...\\n        \u2502\\n        \u2502__ model\\n        \u2502   \u2502__ __init__.py\\n        \u2502   \u2502__ box_orientation.py\\n        \u2502   \u2502__ crystal3D.py\\n        \u2502   \u2502__  ...\\n        \u2502\\n        \u2502__ colvar\\n        \u2502   \u2502__ __init__.py\\n        \u2502   \u2502__ cv_fccCUBIC.py\\n        \u2502   \u2502__ cv_localCRYSTALLINITY.py\\n        \u2502   \u2502__ ...\\n        \u2502\\n        \u2502__ free_energy\\n        \u2502   \u2502__ __init__.py\\n        \u2502   \u2502__ Helmholtz_excess_UF.py\\n        \u2502   \u2502__ replica_logPD_intergration.py\\n        \u2502   \u2502__ ...\\n        \u2502\\n        \u2502__ utils\\n        \u2502   \u2502__ __init__.py\\n        \u2502   \u2502__ coord_rotation.py\\n        \u2502   \u2502__ unit_convert.py\\n        \u2502   \u2502__ compute_distance.py\\n        \u2502   \u2502__ fitting.py\\n        \u2502   \u2502__ ...\\n        \u2502\\n```\\n'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__version","title":"<code>__version</code>","text":"<p>Attributes:</p> <ul> <li> <code>TYPE_CHECKING</code>           \u2013            </li> <li> <code>VERSION_TUPLE</code>           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> <li> <code>__version__</code>               (<code>str</code>)           \u2013            </li> <li> <code>__version_tuple__</code>               (<code>VERSION_TUPLE</code>)           \u2013            </li> <li> <code>version_tuple</code>               (<code>VERSION_TUPLE</code>)           \u2013            </li> </ul>"},{"location":"api/#thmd.__version.TYPE_CHECKING","title":"<code>TYPE_CHECKING = False</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__version.VERSION_TUPLE","title":"<code>VERSION_TUPLE = Tuple[Union[int, str], ...]</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__version.version","title":"<code>version: str = '0.1.dev577+g4cca31c.d20250211'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__version.__version__","title":"<code>__version__: str = '0.1.dev577+g4cca31c.d20250211'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__version.__version_tuple__","title":"<code>__version_tuple__: VERSION_TUPLE = (0, 1, 'dev577', 'g4cca31c.d20250211')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.__version.version_tuple","title":"<code>version_tuple: VERSION_TUPLE = (0, 1, 'dev577', 'g4cca31c.d20250211')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.calc","title":"<code>calc</code>","text":"<p>Modules:</p> <ul> <li> <code>colvar</code>           \u2013            <p>This module contains classes and functions to compute Order parameters, Collective variables,...</p> </li> <li> <code>free_energy</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.colvar","title":"<code>colvar</code>","text":"<p>This module contains classes and functions to compute Order parameters, Collective variables,...</p> <p>Modules:</p> <ul> <li> <code>cv_CoordNum</code>           \u2013            </li> <li> <code>cv_PairANGLE</code>           \u2013            </li> <li> <code>cv_Steinhardt</code>           \u2013            </li> <li> <code>cv_fccCUBIC</code>           \u2013            </li> <li> <code>cv_localCRYSTALLINITY</code>           \u2013            </li> <li> <code>cv_slip_atom</code>           \u2013            </li> <li> <code>find_neighbor</code>           \u2013            </li> <li> <code>sph_harmonics</code>           \u2013            </li> <li> <code>switch_function</code>           \u2013            </li> <li> <code>voronoi</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>RATIONAL</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>HEAVISIDE</code>           \u2013            </li> <li> <code>CUBIC</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>SMAP</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.colvar.RATIONAL","title":"<code>RATIONAL(r0, d0=0.0, n=6, m=12, dmax_tol=0.001)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>r0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>d0</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The d_0 parameter of the switching function</p> </li> <li> <code>n</code>               (<code> (float</code>, default:                   <code>6</code> )           \u2013            <p>The n parameter of the switching function</p> </li> <li> <code>m</code>               (<code> (float</code>, default:                   <code>12</code> )           \u2013            <p>The m parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> Notes <p>Dmin != D0 D0, R0    : are the parameter of switching function Dmin, Dmax : are the bounds at which the switching take affect</p> <p>Examples:</p> <pre><code>sw = thmd.SwitchFunc.RATIONAL(r0=6.3, d0=0.0, n=10)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>dmax</code>             \u2013              </li> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>r0</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>n</code>           \u2013            </li> <li> <code>m</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.colvar.RATIONAL.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.RATIONAL.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.RATIONAL.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.RATIONAL.m","title":"<code>m = m</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.RATIONAL.dmax","title":"<code>dmax(dmax_tol)</code>","text":""},{"location":"api/#thmd.calc.colvar.RATIONAL.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function Input x can be a scalar or a 1d numpy ndarray</p>"},{"location":"api/#thmd.calc.colvar.HEAVISIDE","title":"<code>HEAVISIDE(r0)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute value of sw function</p> </li> <li> <code>der</code>             \u2013              <p>compute derivative of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dmax</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.colvar.HEAVISIDE.dmax","title":"<code>dmax = r0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.HEAVISIDE.eval","title":"<code>eval(x: Union[float, list, np.ndarray]) -&gt; np.ndarray</code>","text":"<p>compute value of sw function</p>"},{"location":"api/#thmd.calc.colvar.HEAVISIDE.der","title":"<code>der(x: float | list | np.ndarray) -&gt; np.ndarray</code>","text":"<p>compute derivative of sw function</p>"},{"location":"api/#thmd.calc.colvar.CUBIC","title":"<code>CUBIC(d0, dmax)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>d0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>dmax</code>               (<code>float</code>)           \u2013            <p>The d_0 parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> <p>Examples:</p> <pre><code>        sw = thmd.SwitchFunc.CUBIC(d0=0.0, dmax=2)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>d0</code>           \u2013            </li> <li> <code>dmax</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.colvar.CUBIC.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.CUBIC.dmax","title":"<code>dmax = dmax</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.CUBIC.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float or ndarray</code>)           \u2013            <p>input values</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>f</code> (              <code>float or ndarray</code> )          \u2013            <p>value of the switching function</p> </li> <li> <code>df</code> (              <code>(float or ndarray, optional)</code> )          \u2013            <p>value of the derivative of the switching function. Just return if <code>compute_der=True</code></p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.SMAP","title":"<code>SMAP(r0, a=10, b=20, d0=0, tol=0.0001)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              </li> <li> <code>findDmax</code>             \u2013              </li> <li> <code>findDmin</code>             \u2013              </li> <li> <code>find_Dmin_Dmax</code>             \u2013              <p>find Dmin and Dmax of function based on given tolerance</p> </li> <li> <code>estimate_ab</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> <li> <code>estimate_ab_old_manual</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>a</code>           \u2013            </li> <li> <code>b</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>r0</code>           \u2013            </li> <li> <code>tol</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.colvar.SMAP.a","title":"<code>a = a</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.b","title":"<code>b = b</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.tol","title":"<code>tol = tol</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.eval","title":"<code>eval(x, compute_der=False)</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.findDmax","title":"<code>findDmax(tol=None, upper_bound=100, gridSize=0.0001)</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.findDmin","title":"<code>findDmin(tol=None, lower_bound=None, gridSize=0.0001)</code>","text":""},{"location":"api/#thmd.calc.colvar.SMAP.find_Dmin_Dmax","title":"<code>find_Dmin_Dmax(tol=None, gridSize=0.0001, upper_bound=50)</code>","text":"<p>find Dmin and Dmax of function based on given tolerance</p>"},{"location":"api/#thmd.calc.colvar.SMAP.estimate_ab","title":"<code>estimate_ab(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version employs <code>scipy.optimize.minimize</code></p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>)           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.SMAP.estimate_ab_old_manual","title":"<code>estimate_ab_old_manual(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001, search_step=0.1)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version use manual search.</p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_CoordNum","title":"<code>cv_CoordNum</code>","text":"<p>Functions:</p> <ul> <li> <code>coord_number</code>             \u2013              <p>The Coordination is the size of input \"Points\", this function just weight it with a switching function</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_CoordNum.coord_number","title":"<code>coord_number(Points, **kwargs)</code>","text":"<p>The Coordination is the size of input \"Points\", this function just weight it with a switching function * Compulsory Inputs: ** optional Inputs:         switchFunc=[1,1...,1] : Nx1 array, contain values of switching function s(Rj) (Rj is positions of atom j) Returns:         coord  : scalar, Order Parameter     Examples: S = thmd.OrderPara.Coordination([1,0,0; 0,1,0], SW=sw) By Cao Thang, Aug 2020</p>"},{"location":"api/#thmd.calc.colvar.cv_PairANGLE","title":"<code>cv_PairANGLE</code>","text":"<p>Functions:</p> <ul> <li> <code>PairANGLE</code>             \u2013              <p>Order Parameter based on pair functions of Angles in the first shell:</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_PairANGLE.PairANGLE","title":"<code>PairANGLE(Points, CENTER, SIGMA, **kwargs)</code>","text":"<p>Order Parameter based on pair functions of Angles in the first shell:</p> Agrs <p>Points   : Nx3 Matrix, contain bonding vectors between neighboring  atoms j and ref atom i CENTER=[pi/3, pi/2, 2*pi/3, pi] : list, centers of Gaussians SIGMA =[0.03,0.04,0.04,0.03]   : list, sigmas of Gaussians switchFunc=[1,1...,1] : Nx1 array, contain values of switching function s(Rj) (Rj is positions of atom j)</p> <p>Returns:</p> <ul> <li> <code>gamma</code> (              <code>float</code> )          \u2013            <p>Order Parameter</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.OrderPara.FCCcubic([1,0,0; 0,1,0], SW=sw)\n</code></pre> Notes <p>Require to best chose Rcut for Switching function</p> Refs <ol> <li>Gobbob et al., \"Nucleation of Molecular Crystals Driven by Relative Information Entropy\"</li> </ol>"},{"location":"api/#thmd.calc.colvar.cv_Steinhardt","title":"<code>cv_Steinhardt</code>","text":"<p>Functions:</p> <ul> <li> <code>Ql_Steinhardt</code>             \u2013              <p>compute origincal Stainhardt of l-th order</p> </li> <li> <code>Local_Ql_Steinhardt</code>             \u2013              <p>compute Local Stainhardt of l-th order (modified Steinhardt as: 10.1021/acs.jctc.6b01073)</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_Steinhardt.Ql_Steinhardt","title":"<code>Ql_Steinhardt(ql_i)</code>","text":"<p>compute origincal Stainhardt of l-th order Args:         ql_i   : a vector of (2l+1) complex components, qlm(i) vector of atom i Returns:         Ql      : scalar value of l-th order Stainhardt parameter</p>"},{"location":"api/#thmd.calc.colvar.cv_Steinhardt.Local_Ql_Steinhardt","title":"<code>Local_Ql_Steinhardt(ql_i, qlm_j, SW)</code>","text":"<p>compute Local Stainhardt of l-th order (modified Steinhardt as: 10.1021/acs.jctc.6b01073) Args:         ql_i   : 1x(2l+1) array, vector of (2l+1) complex components, qlm(i) vector of atom i         qlm_j   : Nx(2l+1) array, rows are vectors of (2l+1) complex components, qlm(j) of all neighbors j of atom i Returns:         Local_Ql_i      : scalar value of l-th order Stainhardt parameter of atom i * PreRequire: compute ql_i complex vector for all atoms before this function can be used</p>"},{"location":"api/#thmd.calc.colvar.cv_fccCUBIC","title":"<code>cv_fccCUBIC</code>","text":"<p>Functions:</p> <ul> <li> <code>fccCUBIC</code>             \u2013              <p>Function to Calculate FCC CUBIC parameters.</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_fccCUBIC.fccCUBIC","title":"<code>fccCUBIC(points, alpha=27, zDirect='001', switch_function=None)</code>","text":"<p>Function to Calculate FCC CUBIC parameters.</p> <p>By thangckt, Mar 2020</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Nx3 np.array</code>)           \u2013            <p>array contains bonding vectors between neighboring  atoms j and ref atom i</p> </li> <li> <code>alpha</code>               (<code>int</code>, default:                   <code>27</code> )           \u2013            <p>coefficient of harmonic function. Default to 27.</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>direction of Z-direction, available '001'  '110'  '111'. Default to '001'.</p> </li> <li> <code>switch_function</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list contain values of switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>param</code> (              <code>float</code> )          \u2013            <p>Order Parameter.</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.colvar.fccCUBIC([1,0,0; 0,1,0], alpha=3, zDirect='001', switch_function=sw)\n</code></pre> Notes <p>Must choose suitable Rcut for Switching function.</p>"},{"location":"api/#thmd.calc.colvar.cv_localCRYSTALLINITY","title":"<code>cv_localCRYSTALLINITY</code>","text":"<p>Functions:</p> <ul> <li> <code>localCRYSTALLINITY</code>             \u2013              <p>Function to Calculate Order Parameter with multi_vectors K.</p> </li> <li> <code>compute_Gvectors_FCC</code>             \u2013              <p>Function to convert reciprocal vectors G to be used in <code>localCRYSTALLINITY</code>.</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_localCRYSTALLINITY.localCRYSTALLINITY","title":"<code>localCRYSTALLINITY(points: np.array, g_vectors: list[list], switch_function=None)</code>","text":"<p>Function to Calculate Order Parameter with multi_vectors K.</p> <p>By thangckt, Apr 2019</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Nx3 np.array</code>)           \u2013            <p>array contains bonding vectors between neighboring  atoms j and ref atom i     g_vectors (tuple): 2d-tuple contains \"directions_vectors\" for g_vectors  (ex: ((4*pi/a)(1,0,0), (4*pi/a)(0,1,0)). The actual g_vectors will be computed in function. Default to ((1,0,0)).</p> </li> <li> <code>switch_function</code>               (<code>object</code>, default:                   <code>None</code> )           \u2013            <p>switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>aveLC</code> (              <code>float</code> )          \u2013            <p>is average Order Parameter , tage over on input g_factors, 0 &lt;= LC &lt;=1</p> </li> <li> <code>LC</code> (              <code>list</code> )          \u2013            <p>list of real numbers, are Order Parameters corresponding to each g-vector 0 &lt;= LC &lt;=1</p> </li> <li> <code>S</code> (              <code>list</code> )          \u2013            <p>(not computed) Kx1 vetor of complex numbers, are Static Structure Factors corresponding to each g-vector</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.colvar.localCRYSTALLINITY([1,0,0; 0,1,0], switch_function=sw, zDirect='001')\n</code></pre> Notes <p>If multi g-vectors is input, then OrderPara is take by averaging over all g-vectors.</p>"},{"location":"api/#thmd.calc.colvar.cv_localCRYSTALLINITY.compute_Gvectors_FCC","title":"<code>compute_Gvectors_FCC(g_directions: list[list] = [[1, 0, 0]], lattice_constant: float = 1.0, zDirect: str = '001') -&gt; list[list]</code>","text":"<p>Function to convert reciprocal vectors G to be used in <code>localCRYSTALLINITY</code>.</p> <p>Parameters:</p> <ul> <li> <code>g_directions</code>               (<code>list</code>, default:                   <code>[[1, 0, 0]]</code> )           \u2013            <p>2d-list contains \"directions_vectors\" for g_vectors  (ex: ((1,0,0), (0,1,0)). The actual g_vectors will be computed. Default to ((1,0,0)).</p> </li> <li> <code>lattice_constant</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>lattice constant of crystal. Default to 1.</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>direction of Z-direction, available '001'  '110'  '111'. Default to '001'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>g_vectors</code> (              <code>list</code> )          \u2013            <p>2d-list contains g_vectors</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_slip_atom","title":"<code>cv_slip_atom</code>","text":"<p>Functions:</p> <ul> <li> <code>slip_atom</code>             \u2013              <p>Function to Calculate FCC CUBIC parameters.</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.cv_slip_atom.slip_atom","title":"<code>slip_atom(points, d_ref, d_diff)</code>","text":"<p>Function to Calculate FCC CUBIC parameters.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Nx3 np.array</code>)           \u2013            <p>array contains bonding vectors between neighboring  atoms j and ref atom i</p> </li> <li> <code>d_ref</code>               (<code>float</code>)           \u2013            <p>reference distance.</p> </li> <li> <code>d_diff</code>               (<code>float</code>)           \u2013            <p>difference distance to referred as dislocation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>param</code> (              <code>float</code> )          \u2013            <p>Order Parameter.</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.colvar.fccCUBIC([1,0,0; 0,1,0], alpha=3, zDirect='001', switch_function=sw)\n</code></pre> Notes <p>Must choose suitable Rcut for Switching function.</p>"},{"location":"api/#thmd.calc.colvar.find_neighbor","title":"<code>find_neighbor</code>","text":"<p>Functions:</p> <ul> <li> <code>find_neighbor_gen</code>             \u2013              <p>find Nearest_Neighbors, return generator of Nearest_IDs, \"Nearest relative-Position vetors from atom i\"</p> </li> <li> <code>find_neighbor_list</code>             \u2013              <p>find Nearest_Neighbors, return list of Nearest_IDs, \"Nearest relative-Position vetors from atom i\"</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.find_neighbor.find_neighbor_gen","title":"<code>find_neighbor_gen(points: Union[np.array, list[list]], box: Union[np.array, list[list]], bound_cond: list = [1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False) -&gt; Generator[list, list[list], None]</code>","text":"<p>find Nearest_Neighbors, return generator of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>thangckt, Sep 2019. Update: Aug 2022 to use generator</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>array</code>)           \u2013            <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>               (<code>array</code>)           \u2013            <p>simulation box</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code> (              <code>generator</code> )          \u2013            <p>this output a GEN contains (Idx_neigh, Rij_vectors)</p> </li> </ul> <p>Examples:</p> <pre><code>GEN = colvar.find_neighbors_gen(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> old version <pre><code>access items in generator with:\n        for Near_ID, Rij_vector in GEN:\n                print (Near_ID, Rij_vector)\n\n- Idx_neigh    : Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms\n- Rij_vectors : Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)\n</code></pre>"},{"location":"api/#thmd.calc.colvar.find_neighbor.find_neighbor_list","title":"<code>find_neighbor_list(points, box, bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False)</code>","text":"<p>find Nearest_Neighbors, return list of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>array</code>)           \u2013            <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>               (<code>array</code>)           \u2013            <p>simulation box</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Idx_neigh</code> (              <code>array</code> )          \u2013            <p>Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms</p> </li> <li> <code>Rij_vectors</code> (              <code>array</code> )          \u2013            <p>Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)</p> </li> </ul> <p>Examples:</p> <pre><code>Idx_neigh, Rij_vectors = colvar.find_neighbors_list(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> Notes <p>don't compute Rij_Bond to save memory Rij_Bonds (np.array): Nx1 list of scalars, contain Rij_bonds from Ref.atom to Nearest_atoms (Nearest-bonds)</p>"},{"location":"api/#thmd.calc.colvar.sph_harmonics","title":"<code>sph_harmonics</code>","text":"<p>Functions:</p> <ul> <li> <code>yl_i</code>             \u2013              <p>Compute vector of Spherical Harmonics for a set of point (ylm vector have (2l+1) components)</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.sph_harmonics.yl_i","title":"<code>yl_i(l, Rij, SW=None, kind='real', normalization='4pi', deg=False)</code>","text":"<p>Compute vector of Spherical Harmonics for a set of point (ylm vector have (2l+1) components)</p> <p>Parameters:</p> <ul> <li> <code>l</code>               (<code>int)         </code>)           \u2013            <p>degree of Spherical Harmonic</p> </li> <li> <code>Rij</code>               (<code>array - like</code>)           \u2013            <p>Nx3 array contain Rij of nearest neighbors compute from atom i</p> </li> <li> <code>SW</code>               (<code> (array-like</code>, default:                   <code>None</code> )           \u2013            <p>Nx1 values of switching function. Default to 'None'</p> </li> <li> <code>kind</code>               (<code> (str</code>, default:                   <code>'real'</code> )           \u2013            <p>kind of return result. Possible <code>complex</code>/<code>real</code>. Default to <code>complex</code></p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'4pi'</code> )           \u2013            <p>'4pi', 'ortho', 'schmidt', or 'unnorm' for geodesy 4pi normalized, orthonormalized, Schmidt semi-normalized, or unnormalized spherical harmonic functions, respectively. Default to '4pi'</p> </li> <li> <code>deg</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, theta and phi are expressed in degrees. Default to <code>False</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>yl</code> (              <code>array - like</code> )          \u2013            <p>vector of (2l+1) components</p> </li> </ul> Notes <p>This functions used the function <code>spharm_lm()</code> from pyshtools</p> Refs <ol> <li>Visualizing the real forms of the spherical harmonics</li> <li>In <code>scipy.special.sph_harm</code> function the azimuthal coordinate, theta, comes before the polar coordinate, phi; anh may return complex number only</li> </ol>"},{"location":"api/#thmd.calc.colvar.switch_function","title":"<code>switch_function</code>","text":"<p>Classes:</p> <ul> <li> <code>RATIONAL</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>HEAVISIDE</code>           \u2013            </li> <li> <code>CUBIC</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>SMAP</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.colvar.switch_function.RATIONAL","title":"<code>RATIONAL(r0, d0=0.0, n=6, m=12, dmax_tol=0.001)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>r0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>d0</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The d_0 parameter of the switching function</p> </li> <li> <code>n</code>               (<code> (float</code>, default:                   <code>6</code> )           \u2013            <p>The n parameter of the switching function</p> </li> <li> <code>m</code>               (<code> (float</code>, default:                   <code>12</code> )           \u2013            <p>The m parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> Notes <p>Dmin != D0 D0, R0    : are the parameter of switching function Dmin, Dmax : are the bounds at which the switching take affect</p> <p>Examples:</p> <pre><code>sw = thmd.SwitchFunc.RATIONAL(r0=6.3, d0=0.0, n=10)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> <li> <code>dmax</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>r0</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>n</code>           \u2013            </li> <li> <code>m</code>           \u2013            </li> </ul> <code></code> <code>r0 = r0</code> <code>instance-attribute</code> \u00b6 <code></code> <code>d0 = d0</code> <code>instance-attribute</code> \u00b6 <code></code> <code>n = n</code> <code>instance-attribute</code> \u00b6 <code></code> <code>m = m</code> <code>instance-attribute</code> \u00b6 <code></code> <code>eval(x, compute_der=False)</code> \u00b6 <p>compute &amp; return value and derivation of sw function Input x can be a scalar or a 1d numpy ndarray</p> <code></code> <code>dmax(dmax_tol)</code> \u00b6"},{"location":"api/#thmd.calc.colvar.switch_function.HEAVISIDE","title":"<code>HEAVISIDE(r0)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute value of sw function</p> </li> <li> <code>der</code>             \u2013              <p>compute derivative of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dmax</code>           \u2013            </li> </ul> <code></code> <code>dmax = r0</code> <code>instance-attribute</code> \u00b6 <code></code> <code>eval(x: Union[float, list, np.ndarray]) -&gt; np.ndarray</code> \u00b6 <p>compute value of sw function</p> <code></code> <code>der(x: float | list | np.ndarray) -&gt; np.ndarray</code> \u00b6 <p>compute derivative of sw function</p>"},{"location":"api/#thmd.calc.colvar.switch_function.CUBIC","title":"<code>CUBIC(d0, dmax)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>d0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>dmax</code>               (<code>float</code>)           \u2013            <p>The d_0 parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> <p>Examples:</p> <pre><code>        sw = thmd.SwitchFunc.CUBIC(d0=0.0, dmax=2)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>d0</code>           \u2013            </li> <li> <code>dmax</code>           \u2013            </li> </ul> <code></code> <code>d0 = d0</code> <code>instance-attribute</code> \u00b6 <code></code> <code>dmax = dmax</code> <code>instance-attribute</code> \u00b6 <code></code> <code>eval(x, compute_der=False)</code> \u00b6 <p>compute &amp; return value and derivation of sw function</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float or ndarray</code>)           \u2013            <p>input values</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>f</code> (              <code>float or ndarray</code> )          \u2013            <p>value of the switching function</p> </li> <li> <code>df</code> (              <code>(float or ndarray, optional)</code> )          \u2013            <p>value of the derivative of the switching function. Just return if <code>compute_der=True</code></p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.switch_function.SMAP","title":"<code>SMAP(r0, a=10, b=20, d0=0, tol=0.0001)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              </li> <li> <code>findDmax</code>             \u2013              </li> <li> <code>findDmin</code>             \u2013              </li> <li> <code>find_Dmin_Dmax</code>             \u2013              <p>find Dmin and Dmax of function based on given tolerance</p> </li> <li> <code>estimate_ab</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> <li> <code>estimate_ab_old_manual</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>a</code>           \u2013            </li> <li> <code>b</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>r0</code>           \u2013            </li> <li> <code>tol</code>           \u2013            </li> </ul> <code></code> <code>a = a</code> <code>instance-attribute</code> \u00b6 <code></code> <code>b = b</code> <code>instance-attribute</code> \u00b6 <code></code> <code>d0 = d0</code> <code>instance-attribute</code> \u00b6 <code></code> <code>r0 = r0</code> <code>instance-attribute</code> \u00b6 <code></code> <code>tol = tol</code> <code>instance-attribute</code> \u00b6 <code></code> <code>eval(x, compute_der=False)</code> \u00b6 <code></code> <code>findDmax(tol=None, upper_bound=100, gridSize=0.0001)</code> \u00b6 <code></code> <code>findDmin(tol=None, lower_bound=None, gridSize=0.0001)</code> \u00b6 <code></code> <code>find_Dmin_Dmax(tol=None, gridSize=0.0001, upper_bound=50)</code> \u00b6 <p>find Dmin and Dmax of function based on given tolerance</p> <code></code> <code>estimate_ab(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001)</code> \u00b6 <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version employs <code>scipy.optimize.minimize</code></p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>)           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul> <code></code> <code>estimate_ab_old_manual(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001, search_step=0.1)</code> \u00b6 <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version use manual search.</p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.voronoi","title":"<code>voronoi</code>","text":"<p>Classes:</p> <ul> <li> <code>Voro3D</code>           \u2013            <p>Voro ++ library</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>layer_extractor</code>             \u2013              <p>Extract atoms of outermost layers, based on Voronoi analysis</p> </li> <li> <code>surface_detect</code>             \u2013              <p>Extract atoms on free surface, are atoms have Voronoi with max(faceArea) &gt;= max_edge**2</p> </li> </ul>"},{"location":"api/#thmd.calc.colvar.voronoi.Voro3D","title":"<code>Voro3D()</code>","text":"<p>Voro ++ library</p> <p>Methods:</p> <ul> <li> <code>fAtomicVol_Bulk_gen</code>             \u2013              <p>compute atomic-volume of each atom in Bulk models</p> </li> <li> <code>fAtomicVol_Plate_gen</code>             \u2013              <p>compute atomic-volume of each atom in Plate models</p> </li> <li> <code>fAtomicVol_Bulk</code>             \u2013              <p>compute atomic-volume of each atom in Bulk models</p> </li> <li> <code>fAtomicVol_Plate</code>             \u2013              <p>compute atomic-volume of each atom in Plate models</p> </li> </ul> <code></code> <code>fAtomicVol_Bulk_gen(P, box, coord_number=False)</code> \u00b6 <p>compute atomic-volume of each atom in Bulk models Args:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p> <p>Examples:</p> <pre><code>gen2 = thmd.fAtomicVol_Bulk_gen(P, box, coord_number=False)   # gen2 = (tomicVol_i, cell_neighbor_i)\ngen3 = thmd.fAtomicVol_Bulk_gen(P, box, coord_number=True)    # gen3 = (tomicVol_i, cell_neighbor_i, coord_i)\n</code></pre> <code></code> <code>fAtomicVol_Plate_gen(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code> \u00b6 <p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value Args:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p> <code></code> <code>fAtomicVol_Bulk(P, box, coord_number=False)</code> \u00b6 <p>compute atomic-volume of each atom in Bulk models Args:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box **Optional:         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p> <code></code> <code>fAtomicVol_Plate(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code> \u00b6 <p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value Args:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"api/#thmd.calc.colvar.voronoi.layer_extractor","title":"<code>layer_extractor(P, bound_cond=(1, 1, 0), layer_num=1, max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms of outermost layers, based on Voronoi analysis Args:           P   : Nx3 Matrix contain positions of atoms           bound_cond=(1, 1, 0)  : tuple of boundary condtions           layer_num   : number of Layers need to extract (layer_num=0 will extract all layers)           max_edge  : value to to compute face-area = max_edge**2           surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory           method   : 'max_face_perimeter'  or   'max_face_area' Returns:         hiLayerIndex, loLayerIndex: list of lists (1xM index of atoms in each layer) By Cao Thang, Jan 2020</p>"},{"location":"api/#thmd.calc.colvar.voronoi.surface_detect","title":"<code>surface_detect(P, bound_cond=(1, 1, 0), max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms on free surface, are atoms have Voronoi with max(faceArea) &gt;= max_edge**2 Agrs:     P   : Nx3 Matrix contain positions of atoms     bound_cond=(1, 1, 0)  : tuple of boundary condtions     max_edge  : value to to compute face-area = max_edge**2     surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory     method   : 'max_face_perimeter'  or   'max_face_area'</p> <p>Returns:</p> <ul> <li>           \u2013            <p>hiSurIndex, loSurIndex: 1xM array, index of surface atoms in the original input points</p> </li> </ul> Notes <p>experimental choose: max_edge=0.73*latticeConst only 1 pair of surface is detect each time</p>"},{"location":"api/#thmd.calc.free_energy","title":"<code>free_energy</code>","text":"<p>Modules:</p> <ul> <li> <code>TImethod</code>           \u2013            </li> <li> <code>logmfd</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.free_energy.TImethod","title":"<code>TImethod</code>","text":"<p>Functions:</p> <ul> <li> <code>AS_integration</code>             \u2013              <p>Compute Free energy difference in TI method - Lambda integration along Adiabatic Switching path</p> </li> <li> <code>RS_integration</code>             \u2013              <p>Compute Free energy difference in TI method - Lambda integration along Reversible Scaling path</p> </li> <li> <code>Helmholtz_excess_UF</code>             \u2013              <p>this func. is to compute the excess Helmholtz freeEnergy as Eq.(25) by R.Paula Leite 2016.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>kB</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.calc.free_energy.TImethod.kB","title":"<code>kB = sc.value('Boltzmann constant in eV/K')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.calc.free_energy.TImethod.AS_integration","title":"<code>AS_integration(forwFile, backFile)</code>","text":"<p>Compute Free energy difference in TI method - Lambda integration along Adiabatic Switching path</p> <p>Parameters:</p> <ul> <li> <code>forwFile</code>               (<code>str</code>)           \u2013            <p>file name of forward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>backFile</code>               (<code>str</code>)           \u2013            <p>file name of backward integration (must contain 2 first columns are: dE, lambda)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>W</code> (              <code>float</code> )          \u2013            <p>irreversible TI work</p> </li> <li> <code>Q</code> (              <code>float</code> )          \u2013            <p>dissipation</p> </li> </ul>"},{"location":"api/#thmd.calc.free_energy.TImethod.RS_integration","title":"<code>RS_integration(forwFile, backFile, T0=0, F0=0, kB=kB)</code>","text":"<p>Compute Free energy difference in TI method - Lambda integration along Reversible Scaling path</p> <p>Parameters:</p> <ul> <li> <code>forwFile</code>               (<code>str</code>)           \u2013            <p>file name of forward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>backFile</code>               (<code>str</code>)           \u2013            <p>file name of backward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>T0</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>reference temperature. Default is 0.</p> </li> <li> <code>F0</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>free energy at reference temperature. Default is 0.</p> </li> <li> <code>kB</code>               (<code>float</code>, default:                   <code>kB</code> )           \u2013            <p>Boltzmann constant (chose unit to consist with F0). Default is kB in unit eV/K.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>array</code> )          \u2013            <p>temperature</p> </li> <li> <code>Ft</code> (              <code>array</code> )          \u2013            <p>free energy as a function of temperature.</p> </li> <li> <code>W</code> (              <code>array</code> )          \u2013            <p>cumulative work</p> </li> </ul>"},{"location":"api/#thmd.calc.free_energy.TImethod.Helmholtz_excess_UF","title":"<code>Helmholtz_excess_UF(p, x)</code>","text":"<p>this func. is to compute the excess Helmholtz freeEnergy as Eq.(25) by R.Paula Leite 2016. J.Chem.Phys.145,no.19:194101. https://doi.org/10.1063/1.4967775.                         p  :           # UFM p-parameter                         x = b*rho  :   # adimensional variable, involved UFM-sigma parameter, rho in unit [1/A^3]</p> <ol> <li>the excess_Helmholtz free enegy in eV : (beta*Fexc)/N</li> </ol> <ol> <li>the pressure : beta*b*P</li> </ol>"},{"location":"api/#thmd.calc.free_energy.logmfd","title":"<code>logmfd</code>","text":"<p>Classes:</p> <ul> <li> <code>LogMFD_FCCUBIC</code>           \u2013            <p>Create an Object (class) of Potential, contain some pre-setup information for Energy barrier for LogMFD calculation.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>replica_logPD_integration</code>             \u2013              <p>The function to compute LogPD-based MeanForce</p> </li> <li> <code>replica_MD_average</code>             \u2013              <p>compute Replica_MD_Average from output of MD.</p> </li> <li> <code>exp_normalize</code>             \u2013              </li> <li> <code>read_df</code>             \u2013              <p>define lamda(x)</p> </li> <li> <code>replica_SteerMD</code>             \u2013              <p>compute Average Work from output of SteerMD.</p> </li> <li> <code>find_basin_logmfd_profile</code>             \u2013              <p>Args:</p> </li> </ul>"},{"location":"api/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC","title":"<code>LogMFD_FCCUBIC(Element, Potential_Name, modelType='Bulk', zDirect='001')</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information for Energy barrier for LogMFD calculation. Energy barrier of System does not depend on CV (same value for energy CV: meanCV, nAtomLiquid,...) * Attributes:         Element         :         Cutoff          : force cutoff of potential         Potential_Name  :         * Energy barrier Coeff: an estimation of per-atom energy barrier for melting,                                 for a system of N atoms  \ud835\udc39=\ud835\udc53\u2217\ud835\udc41^(\u2154) , then perAtom barrier  \ud835\udc53=\ud835\udc39/\ud835\udc41^(\u2154)                                 This method return f(T)         * histo_point_coeff: the CV-value at which histogram of solid and liquid meets, coeff of function f(T) = a0 + a1T</p> <ul> <li>Methods:         Latt_Const      : compute lattice constant at a specific temperature</li> </ul> <p>Element         : 'Al', 'Cu',... Potential_Name  :         'Cu' : 'Mishin-2001'; 'Foiles-1986';...         'Al' : 'Mishin-1999'; 'Sheng-2011';... modelType       : 'Bulk' or 'Plate' zDirect         : '001' or '110' or '111' or thickness       : thickness of plate</p> <p>Methods:</p> <ul> <li> <code>meltingBarrier</code>             \u2013              <p>for a system of N atoms  \ud835\udc39=\ud835\udc53\u2217\ud835\udc41^(\u2154) , then perAtom barrier  \ud835\udc53=\ud835\udc39/\ud835\udc41^(\u2154). This method return f(T)</p> </li> <li> <code>histo_point</code>             \u2013              <p>Value of CV at intersection point of histogram as function y = a + bx</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Element</code>           \u2013            </li> <li> <code>Potential_Name</code>           \u2013            </li> <li> <code>melt_barrier_coeff</code>           \u2013            </li> <li> <code>histo_point_coeff</code>           \u2013            </li> </ul> <code></code> <code>Element = Element</code> <code>instance-attribute</code> \u00b6 <code></code> <code>Potential_Name = Potential_Name</code> <code>instance-attribute</code> \u00b6 <code></code> <code>melt_barrier_coeff = melt_barrier_coeff[melt_barrier_key]</code> <code>instance-attribute</code> \u00b6 <code></code> <code>histo_point_coeff = histo_point_coeff</code> <code>instance-attribute</code> \u00b6 <code></code> <code>meltingBarrier(Temp)</code> \u00b6 <p>for a system of N atoms  \ud835\udc39=\ud835\udc53\u2217\ud835\udc41^(\u2154) , then perAtom barrier  \ud835\udc53=\ud835\udc39/\ud835\udc41^(\u2154). This method return f(T)</p> <code></code> <code>histo_point(Temp)</code> \u00b6 <p>Value of CV at intersection point of histogram as function y = a + bx</p>"},{"location":"api/#thmd.calc.free_energy.logmfd.replica_logPD_integration","title":"<code>replica_logPD_integration(logmfd_files: list[str], replica_files: list[str], beta: float = 1.0)</code>","text":"<p>The function to compute LogPD-based MeanForce</p> <p>Parameters:</p> <ul> <li> <code>logmfd_files</code>               (<code>list[str]</code>)           \u2013            <p>list of <code>logmfd.out</code> files</p> </li> <li> <code>replica_files</code>               (<code>list[str]</code>)           \u2013            <p>list of <code>replica.out</code> files</p> </li> <li> <code>beta</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>kB is Boltzmann constant (can be set to 1.0, regardless of kB unit). Defaults to beta = 1.0/(TEMP*kB)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (              <code>obj</code> )          \u2013            <p>contains logPD-based MeanForce</p> </li> </ul> <p>Examples:</p> <pre><code>free_energy.replica_logPD_intergration(logmfd_files, replica_files)\n</code></pre> <p>Requisites:</p> <pre><code>1. Run logMFD simulations to produce `replica_*/logmfd.out` and `replica_*/replica.out`\n\n```\n&lt;logmfd.out&gt;\n1:iter_md, 2:Flog(t), \u2026, 6: X(t), 7: V(t), 8: Force(t)\n1   F(1), \u2026, X(1), V(1), Force(0)\n2   F(3), \u2026, X(2), V(2), Force(1)\n```\n\n```\n&lt;replica.out&gt;\niter_md, work, weight, cv\n1  work(1)   weight(1)  cv(0)\n2  work(2)   weight(2)  cv(1)\n```\n</code></pre> Notes <ol> <li>About the printed values in <code>&lt;replica.out&gt;</code> and <code>&lt;logmfd.out&gt;</code> as emails replied by Tetsuya Morishita. (check thangckt email)</li> <li>Specify type of function <code>cumulative_trapezoid:np.float64</code> to be used in <code>numba</code> <pre><code>cumulative_trapezoid:np.float64 = cumulative_trapezoid,   # this to specify `type` for function `cumulative_trapezoid`\nlogMFD:pd.DataFrame = read_data.logMFD,\nmatrix_auto:pd.DataFrame = read_data.matrix_auto):\n</code></pre></li> </ol> Refs <p>[1].https://pubs.acs.org/doi/10.1021/acs.jctc.7b00252 Free Energy Reconstruction from Logarithmic Mean-Force Dynamics Using Multiple Nonequilibrium TrajectoriesFree [2] Exp-normalize trick: https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/</p> 2023 Apr <p>CV-value in <code>replica.out</code> and <code>logmfd.out</code> are the same, so don't need to shift value in <code>replica.out</code> as below: <pre><code>Force = [elem['CV1_force'].shift(-1) for elem in logmfd ]\n</code></pre></p>"},{"location":"api/#thmd.calc.free_energy.logmfd.replica_MD_average","title":"<code>replica_MD_average(MD_out_files: list[str])</code>","text":"<p>compute Replica_MD_Average from output of MD.</p> <p>Parameters:</p> <ul> <li> <code>MD_out_files</code>               (<code>list[str]</code>)           \u2013            <p>list of \"MDout_replica.txt\" files</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>logPD file: contains logPD-based MeanForce</p> </li> </ul> Requisites <ol> <li><code>Replica_*</code> files from separate MD simulations</li> </ol> <p>Thang, Jul2020 (update: Sep 2021)</p>"},{"location":"api/#thmd.calc.free_energy.logmfd.exp_normalize","title":"<code>exp_normalize(x)</code>","text":""},{"location":"api/#thmd.calc.free_energy.logmfd.read_df","title":"<code>read_df(file, engine='LAMMPS')</code>","text":"<p>define lamda(x)</p>"},{"location":"api/#thmd.calc.free_energy.logmfd.replica_SteerMD","title":"<code>replica_SteerMD(SteerMD_files, beta=1.0, engine='Lammps')</code>","text":"<p>compute Average Work from output of SteerMD.</p> <p>Parameters:</p> <ul> <li> <code>SteerMD_files</code>           \u2013            <p>|<code>list</code>| of \"SteerMD.txt\" files</p> </li> <li> <code>beta</code>               (<code>= 1.0/(TEMP*kB</code>, default:                   <code>1.0</code> )           \u2013            <p>kB is Boltzmann constant (can be set to 1.0, regardless of kB unit)</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>aveSteerMD file: contains logPD-based MeanForce</p> </li> </ul> <p>Requisites: 1. Replica_* files from separate MD simulations</p> Refs <p>[1]. https://github.com/sandeshkalantre/jarzynski/blob/master/code/Simulations%20on%20Harmonic%20Oscillator%20Model.ipynb [2]. https://www.plumed.org/doc-v2.6/user-doc/html/belfast-5.html#belfast-5-work [3]. Exp-normalize trick: https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/</p>"},{"location":"api/#thmd.calc.free_energy.logmfd.find_basin_logmfd_profile","title":"<code>find_basin_logmfd_profile(ldf: list[pd.DataFrame], mfd_interval: list[float], hill_region: list = [0.2, 0.6]) -&gt; list[pd.DataFrame]</code>","text":"<p>Parameters:</p> <ul> <li> <code>ldf</code>               (<code>list[DataFrame]</code>)           \u2013            <p>list of <code>pd.DataFrames</code> of <code>LogMFD.out</code> files</p> </li> <li> <code>mfd_interval</code>               (<code>list</code>)           \u2013            <p>interval of MFDstep in PLUMED input files</p> </li> <li> <code>hill_region</code>               (<code>1x2 list</code>, default:                   <code>[0.2, 0.6]</code> )           \u2013            <p>the region of CV that contains saddle point. The Left/Right basin is located at left/right of this region. This region should exclude the bassins.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df_min_right</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of right basin minima</p> </li> <li> <code>df_min_left</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of left basin minima</p> </li> <li> <code>df_max</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of maxima energy</p> </li> <li> <code>df_diff</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of energy difference between minima and maxima</p> </li> </ul>"},{"location":"api/#thmd.io","title":"<code>io</code>","text":"<p>This module contains classes and functions to read/write data in various formats.</p> <p>Modules:</p> <ul> <li> <code>read_block</code>           \u2013            </li> <li> <code>read_data</code>           \u2013            <p>This module contains functions to read numeric data from various formats of TEXT files.</p> </li> <li> <code>script</code>           \u2013            <p>This module contains functions to read/write some specific scripts.</p> </li> <li> <code>traj</code>           \u2013            <p>This module contains classes and functions to process molecular dynamics trajectories.</p> </li> </ul>"},{"location":"api/#thmd.io.read_block","title":"<code>read_block</code>","text":"<p>Classes:</p> <ul> <li> <code>LmpLogFile</code>           \u2013            <p>Create an Object of LOG file.</p> </li> <li> <code>LmpRDF</code>           \u2013            <p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> </li> <li> <code>LmpAveChunk</code>           \u2013            <p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> </li> <li> <code>PlumHistogram</code>           \u2013            <p>Create an Object of DUMP file</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>average_df_list</code>             \u2013              <p>compute average of list of DataFrame</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpLogFile","title":"<code>LmpLogFile(logfile=None)</code>","text":"<p>Create an Object of LOG file.</p> Notes <ul> <li>run 0 without data</li> </ul> Udpate <ul> <li>2024-10-10: use Polars DataFrame instead of Pandas Series</li> </ul> <p>Parameters:</p> <ul> <li> <code>logfile</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>file_name of LOG file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpLogFile</code> )          \u2013            <p>LmpLogFile object</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>read_log</code>             \u2013              <p>Read LAMMPS logfile</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpLogFile.read_log","title":"<code>read_log(logfile)</code>","text":"<p>Read LAMMPS logfile Args:         logfile (str): input LOG file</p> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpLogFile</code> )          \u2013            <p>LmpLogFile object</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpRDF","title":"<code>LmpRDF(file_name: str)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file name</p> </li> <li> <code>frame</code>               (<code>DataFrame</code>)           \u2013            <p>3d pandas Frame (multi-row-index DataFrame)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>             \u2013              <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>             \u2013              <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpAveChunk</code> )          \u2013            <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('rdf.txt')\n</code></pre> <p>Methods:</p> <ul> <li> <code>read_RDF</code>             \u2013              <p>Args:</p> </li> <li> <code>compute_AveRDF</code>             \u2013              <p>compute average of RDF over all frames</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpRDF.read_RDF","title":"<code>read_RDF(file_name: str)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpRDF</code> )          \u2013            <p>LmpRDF object</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpRDF.compute_AveRDF","title":"<code>compute_AveRDF()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Average of RDF</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpAveChunk","title":"<code>LmpAveChunk(file_name)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file name.</p> </li> <li> <code>frame</code>               (<code>DataFrame</code>)           \u2013            <p>3d pandas Frame (multi-row-index DataFrame).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>             \u2013              <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>             \u2013              <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpAveChunk</code> )          \u2013            <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('LmpAveChunk.txt')\n</code></pre> <p>Methods:</p> <ul> <li> <code>read_AveChunk</code>             \u2013              <p>Args:</p> </li> <li> <code>compute_AveChunk</code>             \u2013              <p>compute average of RDF over all frames</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpAveChunk.read_AveChunk","title":"<code>read_AveChunk(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpAveChunk</code> )          \u2013            <p>LmpAveChunk object</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.LmpAveChunk.compute_AveChunk","title":"<code>compute_AveChunk()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Average of RDF</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.PlumHistogram","title":"<code>PlumHistogram(file_name)</code>","text":"<p>Create an Object of DUMP file</p> <p>Methods:</p> <ul> <li> <code>read_histogram       </code>             \u2013              <p>read Histogram file</p> </li> <li> <code>average_histogram    </code>             \u2013              <p>the Average Histogram</p> </li> <li> <code>AreaHisto       </code>             \u2013              <p>Area under pdf curve</p> </li> <li> <code>find_tail</code>             \u2013              <p>find limit of histogram</p> </li> <li> <code>find_center</code>             \u2013              <p>find center of histogram</p> </li> </ul> <p>Examples:</p> <pre><code>from thmd.io.read_block import PlumHistogram\nRDF = PlumHistogram(file_name='myRDF.txt')\n</code></pre> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>PlumHistogram</code> )          \u2013            <p>PlumHistogram object</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>read_histogram</code>             \u2013              <p>Args:</p> </li> <li> <code>compute_average_histogram</code>             \u2013              <p>compute average of histogram over all frames</p> </li> <li> <code>areaHisto</code>             \u2013              </li> <li> <code>fit_std_gaussian</code>             \u2013              <p>Fit the average-histogarm to Standard Gaussian function</p> </li> <li> <code>find_tail</code>             \u2013              <p>Find tail of distribution function</p> </li> <li> <code>find_center</code>             \u2013              <p>Find tail of distribution function</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.PlumHistogram.read_histogram","title":"<code>read_histogram(file_name: str)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>input HISTOGRAM file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>PlumHistogram</code> )          \u2013            <p>update PlumHistogram object</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.PlumHistogram.compute_average_histogram","title":"<code>compute_average_histogram()</code>","text":"<p>compute average of histogram over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of avergave histogram</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.PlumHistogram.areaHisto","title":"<code>areaHisto()</code>","text":""},{"location":"api/#thmd.io.read_block.PlumHistogram.fit_std_gaussian","title":"<code>fit_std_gaussian()</code>","text":"<p>Fit the average-histogarm to Standard Gaussian function</p> <p>Returns:</p> <ul> <li> <code>amp, miu, sigma) (tuple</code>           \u2013            <p>parameters of Gaussian function</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.PlumHistogram.find_tail","title":"<code>find_tail(tol=0.0001, gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>tolerance</p> </li> <li> <code>gridSize</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>left_tail</code> (              <code>float</code> )          \u2013            <p>limit on the left side</p> </li> <li> <code>right_tail</code> (              <code>float</code> )          \u2013            <p>limit on the right side</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.PlumHistogram.find_center","title":"<code>find_center(gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>gridSize</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Xcenter</code> (              <code>float</code> )          \u2013            <p>center of the distribution function</p> </li> </ul>"},{"location":"api/#thmd.io.read_block.average_df_list","title":"<code>average_df_list(list_df: list[pl.DataFrame]) -&gt; pl.DataFrame</code>","text":"<p>compute average of list of DataFrame</p> <p>Parameters:</p> <ul> <li> <code>list_df</code>               (<code>list</code>)           \u2013            <p>list of DataFrame</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Average of list of DataFrame</p> </li> </ul>"},{"location":"api/#thmd.io.read_data","title":"<code>read_data</code>","text":"<p>This module contains functions to read numeric data from various formats of TEXT files.</p> <p>Functions:</p> <ul> <li> <code>matrix_lost</code>             \u2013              <p>Function to read data in matrix form, in which number of values in each line are NOT equal (missing values)</p> </li> <li> <code>matrix</code>             \u2013              <p>Function to read Data that is as a regular matrix.</p> </li> <li> <code>logMFD</code>             \u2013              <p>Function to read data from LogMFD calculation.</p> </li> <li> <code>lammps_var</code>             \u2013              <p>Function to extract variable values from LAMMPS input file.</p> </li> <li> <code>plumed_var</code>             \u2013              <p>Function to extract variable values from PLUMED input file.</p> </li> <li> <code>list_matrix_in_dir</code>             \u2013              <p>read data from all *.txt files in current and sub-folders.</p> </li> </ul>"},{"location":"api/#thmd.io.read_data.matrix_lost","title":"<code>matrix_lost(file_name: str, header_line: int = None, column_names: list[str] = None, comment: str = '#', sep: str = ' ', read_note: bool = False) -&gt; pl.DataFrame</code>","text":"<p>Function to read data in matrix form, in which number of values in each line are NOT equal (missing values) This cannot be read by Numpy, <code>polars</code>,...</p> <p>The names of columns are extracted from <code>header_line</code> or set by <code>column_names</code>. If both <code>column_names</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file.</p> </li> <li> <code>header_line</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>the lines to extract column-names. Defaults to None.</p> </li> <li> <code>column_names</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>'#'</code> )           \u2013            <p>comment-line mark. Defaults to \"#\".</p> </li> <li> <code>sep</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>separator. Defaults to \" \".</p> </li> <li> <code>read_note</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>read 'note' column (any text beyond comment mark). Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>polars DataFrame</p> </li> </ul> Notes <ul> <li>To return 2 lists from list comprehension, it is better (may faster) running 2 separated list comprehensions.</li> <li><code>.strip()</code> function removes trailing and leading space in string.</li> </ul>"},{"location":"api/#thmd.io.read_data.matrix","title":"<code>matrix(file_name: str, header_line: int = None, column_names: list[str] = None, usecols: tuple[int] = None) -&gt; pl.DataFrame</code>","text":"<p>Function to read Data that is as a regular matrix. The names of columns are exatract based on <code>column_names</code> or <code>header_line</code>. If both <code>column_names</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file.</p> </li> <li> <code>header_line</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>the line to extract column-names. Defaults to None.</p> </li> <li> <code>column_names</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>usecols</code>               (<code>tuple[int]</code>, default:                   <code>None</code> )           \u2013            <p>only extract some columns. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p><code>polars</code> DataFrame</p> </li> </ul>"},{"location":"api/#thmd.io.read_data.logMFD","title":"<code>logMFD(file_name, dim=1) -&gt; pl.DataFrame</code>","text":"<p>Function to read data from LogMFD calculation.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the logmfd.out file.</p> </li> <li> <code>dim</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>dimension of LogMFD calulation. Defaults to 1.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p><code>polars</code> DataFrame</p> </li> </ul>"},{"location":"api/#thmd.io.read_data.lammps_var","title":"<code>lammps_var(file_name, var_names=None)</code>","text":"<p>Function to extract variable values from LAMMPS input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_names</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list of varibalbes to be extracted. Default to None. mean extract all variables.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p><code>polars</code> DataFrame contains variable in Lammps file</p> </li> </ul>"},{"location":"api/#thmd.io.read_data.plumed_var","title":"<code>plumed_var(file_name, var_name, block_name=None)</code>","text":"<p>Function to extract variable values from PLUMED input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_name</code>               (<code>str</code>)           \u2013            <p>list of keyworks in PLUMED, ex: INTERVAL,...</p> </li> <li> <code>block_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>block command in Plumed, ex: METAD, LOGMFD. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>value</code> (              <code>float</code> )          \u2013            <p>value of plumed_var.</p> </li> </ul> Refs <p>Include negative decimal numbers in regular expression</p>"},{"location":"api/#thmd.io.read_data.list_matrix_in_dir","title":"<code>list_matrix_in_dir(search_key='deform_', file_ext='.txt', read_note=False, recursive=True)</code>","text":"<p>read data from all *.txt files in current and sub-folders.</p> <p>Parameters:</p> <ul> <li> <code>search_key</code>               (<code>str</code>, default:                   <code>'deform_'</code> )           \u2013            <p>a string to search file_name.</p> </li> <li> <code>file_ext</code>               (<code>str</code>, default:                   <code>'.txt'</code> )           \u2013            <p>file extension. Default to '.txt'</p> </li> <li> <code>read_note</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>read 'note' column in pl.DataFrame. Default to False.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>search in sub-folders. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ldf</code> (              <code>list</code> )          \u2013            <p>list of DataFrames.</p> </li> <li> <code>files</code> (              <code>list</code> )          \u2013            <p>list of filenames.</p> </li> </ul>"},{"location":"api/#thmd.io.script","title":"<code>script</code>","text":"<p>This module contains functions to read/write some specific scripts.</p> <p>Functions:</p> <ul> <li> <code>read_lines</code>             \u2013              <p>Function to read lines in a script that match some KEY_WORDs.</p> </li> <li> <code>read_plumed_block</code>             \u2013              <p>Function to read block_command in PLUMED script.</p> </li> <li> <code>write_lines</code>             \u2013              <p>Funtion to write a list of strings into file.</p> </li> <li> <code>write_list</code>             \u2013              <p>Funtion to write a list of strings into file.</p> </li> </ul>"},{"location":"api/#thmd.io.script.read_lines","title":"<code>read_lines(file_name: str, keywords: list = [])</code>","text":"<p>Function to read lines in a script that match some KEY_WORDs.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>a text file of any format.</p> </li> <li> <code>keywords</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>list-of-Keywords to extract a line, ex: METAD, LOGMFD. Default to [], mean read all lines.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (              <code>list</code> )          \u2013            <p>a list of lines.</p> </li> <li> <code>rest_lines</code> (              <code>list</code> )          \u2013            <p>a list of rest lines.</p> </li> </ul>"},{"location":"api/#thmd.io.script.read_plumed_block","title":"<code>read_plumed_block(file_name: str, block_name: str = ' ') -&gt; list</code>","text":"<p>Function to read block_command in PLUMED script.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>a text file of PLUMED format.</p> </li> <li> <code>block_name</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>block command in PLUMED, ex: METAD, LOGMFD</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (              <code>list</code> )          \u2013            <p>block_of_commandlines</p> </li> </ul>"},{"location":"api/#thmd.io.script.write_lines","title":"<code>write_lines(filename: str, lines: list)</code>","text":"<p>Funtion to write a list of strings into file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>file name.</p> </li> <li> <code>lines</code>               (<code>list</code>)           \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"api/#thmd.io.script.write_list","title":"<code>write_list(lines: list, filename: str)</code>","text":"<p>Funtion to write a list of strings into file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>file name.</p> </li> <li> <code>lines</code>               (<code>list</code>)           \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"api/#thmd.io.traj","title":"<code>traj</code>","text":"<p>This module contains classes and functions to process molecular dynamics trajectories.</p> <p>Modules:</p> <ul> <li> <code>md_traj</code>           \u2013            </li> <li> <code>mod_calc_global_properties</code>           \u2013            </li> <li> <code>mod_calc_local_properties</code>           \u2013            </li> <li> <code>mod_change_box</code>           \u2013            </li> <li> <code>mod_change_data</code>           \u2013            </li> <li> <code>parser_gromacs</code>           \u2013            </li> <li> <code>parser_pdb_xyz</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.io.traj.md_traj","title":"<code>md_traj</code>","text":"<p>Classes:</p> <ul> <li> <code>Frame</code>           \u2013            <p>Create an Object for a single-FRAME of trajectories from MD simulation.</p> </li> <li> <code>Traj</code>           \u2013            <p>Create an Object for a multi-FRAMEs of trajectories from MD simulation.</p> </li> </ul>"},{"location":"api/#thmd.io.traj.md_traj.Frame","title":"<code>Frame(dump_file: str = None, data_file: str = None, atom_style: str = 'auto', pdb_file: str = None, xyz_file: str = None, from_df: pd.DataFrame = None, box: np.array = None, box_angle: np.array = None)</code>","text":"<p>Create an Object for a single-FRAME of trajectories from MD simulation.</p> <p>This class create a data-object (single configuration) for the analysis of computing data from LAMMPS. The file formats implemented in this class</p> <p></p> <ul> <li>LAMMPS DATA Format</li> <li>LAMMPS DUMP Format</li> <li>PDB format</li> <li>XYZ format</li> </ul> <p>This class implemented several ways to create <code>Frame</code> object</p> <ul> <li>create an empty data object</li> <li>create_DATA object with input data</li> <li>read from DUMP file</li> <li>read from DATA file</li> <li>read frome PDB file</li> </ul> <p>Attributes:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> <li> <code>timestep</code>               (<code>int</code>)           \u2013            <p>the timestep of configuration</p> </li> <li> <code>box</code>               (<code>array</code>)           \u2013            <p>3x2 array, the box size</p> </li> <li> <code>box_angle</code>               (<code>array</code>)           \u2013            <p>1x3 array, the box angle</p> </li> <li> <code>atom</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame of per-atom values</p> </li> <li> <code>prop_key</code>               (<code>list</code>)           \u2013            <p>column-names of properties</p> </li> <li> <code>mass</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame of per-type masses</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>default format for float numbers, don't use %g because it will lost precision</p> </li> </ul> <p>Examples:</p> <pre><code>from thmd.traj  import Frame\n\nda = Frame()                        # empty object\nda = Frame(from_df=df)              # oject with input data\nda = Frame(dump_file='test.cfg')    # from DUMP file\nda = Frame(data_file='mydata.dat')  # from DATA file\nda = Frame(pdb_file='test.pdb')     # from PDB file\n</code></pre> <p>Refs:     [1]. Use chain mutator calls</p> <p>initilize the Frame object</p> <p>Parameters:</p> <ul> <li> <code>dump_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of DUMP file.</p> </li> <li> <code>data_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of DATA file.</p> </li> <li> <code>pdb_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of PBD file.</p> </li> <li> <code>xyz_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of XYZ file.</p> </li> <li> <code>from_df</code>               (<code>DataFrame</code>, default:                   <code>None</code> )           \u2013            <p>create FRAME from data.</p> </li> <li> <code>atom_style</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>atom_style of system. Only need when <code>data_file</code> is used. Possible values: 'atomic', 'molecular', 'charge', 'full', 'auto'</p> </li> <li> <code>box</code>               (<code>np.array list</code>, default:                   <code>None</code> )           \u2013            <p>Define simulation box. Only need when <code>from_df</code> is used.</p> </li> <li> <code>box_angle</code>               (<code>np.array list</code>, default:                   <code>None</code> )           \u2013            <p>Define angle of simulation box. Only need when <code>from_df</code> is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>Frame</code> )          \u2013            <p>object of trajectories</p> </li> </ul> Notes <p>Use mutator, so do not use self.* when define value</p> <p>Methods:</p> <ul> <li> <code>create_DATA</code>             \u2013              <p>The method to create new FRAME object with input data.</p> </li> <li> <code>copy</code>             \u2013              <p>The method to make an indepedent copy of Frame Obj. Then, the change values of the fields of the new object, the old object should not be affected by that.</p> </li> <li> <code>check_exist</code>             \u2013              <p>The method to check whether something is existed in system or not.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            </li> <li> <code>timestep</code>               (<code>int</code>)           \u2013            </li> <li> <code>decimals</code>               (<code>int</code>)           \u2013            </li> <li> <code>box</code>           \u2013            </li> <li> <code>box_angle</code>           \u2013            </li> <li> <code>prop_key</code>               (<code>list[str]</code>)           \u2013            </li> <li> <code>atom</code>           \u2013            </li> <li> <code>mass</code>           \u2013            </li> <li> <code>pair_coeff</code>           \u2013            </li> <li> <code>bond_coeff</code>           \u2013            </li> <li> <code>angle_coeff</code>           \u2013            </li> <li> <code>dihedral_coeff</code>           \u2013            </li> <li> <code>improper_coeff</code>           \u2013            </li> <li> <code>bondBond_coeff</code>           \u2013            </li> <li> <code>bondAngle_coeff</code>           \u2013            </li> <li> <code>middleBondTorsion_coeff</code>           \u2013            </li> <li> <code>endBondTorsion_coeff</code>           \u2013            </li> <li> <code>angleTorsion_coeff</code>           \u2013            </li> <li> <code>angleAngleTorsion_coeff</code>           \u2013            </li> <li> <code>bondBond13_coeff</code>           \u2013            </li> <li> <code>angleAngle_coeff</code>           \u2013            </li> <li> <code>bond</code>           \u2013            </li> <li> <code>angle</code>           \u2013            </li> <li> <code>dihedral</code>           \u2013            </li> <li> <code>improper</code>           \u2013            </li> </ul> <code></code> <code>filename: str = 'md_frame'</code> <code>instance-attribute</code> \u00b6 <code></code> <code>timestep: int = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>decimals: int = 7</code> <code>instance-attribute</code> \u00b6 <code></code> <code>box = np.asarray([[0, 1], [0, 1], [0, 1]], dtype=float)</code> <code>instance-attribute</code> \u00b6 <code></code> <code>box_angle = np.asarray([0, 0, 0], dtype=float)</code> <code>instance-attribute</code> \u00b6 <code></code> <code>prop_key: list[str] = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>_num = {'n_atoms': 0, 'n_atom_types': 0}</code> <code>instance-attribute</code> \u00b6 <code></code> <code>_style = {'atom_style': '', 'pair_style': '', 'bond_style': '', 'angle_style': '', 'dihedral_style': '', 'improper_style': ''}</code> <code>instance-attribute</code> \u00b6 <code></code> <code>atom = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>mass = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>pair_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>bond_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>angle_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>dihedral_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>improper_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>bondBond_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>bondAngle_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>middleBondTorsion_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>endBondTorsion_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>angleTorsion_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>angleAngleTorsion_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>bondBond13_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>angleAngle_coeff = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>bond = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>angle = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>dihedral = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>improper = None</code> <code>instance-attribute</code> \u00b6 <code></code> <code>create_DATA(df: pd.DataFrame, box: np.array = None, box_angle: np.array = None)</code> \u00b6 <p>The method to create new FRAME object with input data.</p> <p>Parameters:</p> <ul> <li> <code>DataFrame</code>               (<code>DataFrame</code>)           \u2013            <p>of input data</p> </li> <li> <code>box</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>3x2 array, option to input boxSize.</p> </li> <li> <code>box_angle</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1x3 array, option to input box_angle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>Frame</code> )          \u2013            <p>update Frame</p> </li> </ul> <p>Examples:</p> <pre><code>da = Frame()\nda.create_DATA(DataFrame=df)\n# or\nda = Frame(from_df=df)\n</code></pre> <code></code> <code>copy()</code> \u00b6 <p>The method to make an indepedent copy of Frame Obj. Then, the change values of the fields of the new object, the old object should not be affected by that.</p> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>Frame</code> )          \u2013            <p>new Frame Obj.</p> </li> </ul> <p>Examples:</p> <pre><code>da1 = da.copy()\n</code></pre> <p>Refs:     [1]. \"shallow copying\" vs \"deep copying\": https://stackoverflow.com/questions/3975376/understanding-dict-copy-shallow-or-deep/3975388#3975388</p> <code></code> <code>check_exist(atom_types=None, mass_types=None)</code> \u00b6 <p>The method to check whether something is existed in system or not.</p> <p>Parameters:</p> <ul> <li> <code>atom_types</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list-of-int of atom-types. Default to None.</p> </li> <li> <code>mass_types</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list-of-int of atom-types. Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mgs</code> (              <code>str</code> )          \u2013            <p>raise Message if error.</p> </li> </ul> <p>Examples:</p> <pre><code>da.isExist(atom_types=[2,3])\n</code></pre> Notes <p>set() also return unique values.</p>"},{"location":"api/#thmd.io.traj.md_traj.Traj","title":"<code>Traj(**kwargs)</code>","text":"<p>Create an Object for a multi-FRAMEs of trajectories from MD simulation. - read frome XYZ file</p> <p>initilize the TrajFrame object</p> Notes <p>Use mutator, so do not use self.* when define value</p> <p>Methods:</p> <ul> <li> <code>readXYZ</code>             \u2013              <p>The method create Multi-FRAME object by reading XYZ file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>decimals</code>               (<code>int</code>)           \u2013            </li> </ul> <code></code> <code>decimals: int = 6</code> <code>instance-attribute</code> \u00b6 <code></code> <code>readXYZ(filename)</code> \u00b6 <p>The method create Multi-FRAME object by reading XYZ file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da = io.TrajFrame(pdb_file='mydata.pdb')\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_calc_global_properties","title":"<code>mod_calc_global_properties</code>","text":"<p>Functions:</p> <ul> <li> <code>compute_mass</code>             \u2013              <p>The method to compute mass of selected atom_types.</p> </li> <li> <code>compute_wt_percent</code>             \u2013              <p>The method to compute weight percentage of some atom_types.</p> </li> </ul>"},{"location":"api/#thmd.io.traj.mod_calc_global_properties.compute_mass","title":"<code>compute_mass(self, atom_types=[])</code>","text":"<p>The method to compute mass of selected atom_types.</p> <p>Parameters:</p> <ul> <li> <code>atom_types</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>atom-types to compute masses. Defaults to [], mean all-types.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>m</code> (              <code>float</code> )          \u2013            <p>total mass of selected atoms.</p> </li> </ul> <p>Examples:</p> <pre><code>da.compute_mass(atom_types=[2,3])\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_calc_global_properties.compute_wt_percent","title":"<code>compute_wt_percent(self, atom_types)</code>","text":"<p>The method to compute weight percentage of some atom_types.</p> <p>Parameters:</p> <ul> <li> <code>atom_types</code>               (<code>list</code>)           \u2013            <p>atom-types compute percentage of weight.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>wt</code> (              <code>float</code> )          \u2013            <p>weight percentage of chosen atoms.</p> </li> </ul> <p>Examples:</p> <pre><code>da.compute_wt_percent(atom_types=[2,3])\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_calc_local_properties","title":"<code>mod_calc_local_properties</code>","text":"<p>Functions:</p> <ul> <li> <code>compute_colvar_sph_harm</code>             \u2013              <p>Compute per-atom vector of spherical harmonics</p> </li> </ul>"},{"location":"api/#thmd.io.traj.mod_calc_local_properties.compute_colvar_sph_harm","title":"<code>compute_colvar_sph_harm(self, l, kind='real', normalization='4pi', bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False, calc_coord=False)</code>","text":"<p>Compute per-atom vector of spherical harmonics</p> <p>Parameters:</p> <ul> <li> <code>l</code>               (<code>int)         </code>)           \u2013            <p>degree of Spherical Harmonic</p> </li> <li> <code>form</code>               (<code> (str</code>)           \u2013            <p>form of return result. Possible <code>complex</code>/<code>real</code>. Default to <code>complex</code></p> </li> </ul>"},{"location":"api/#thmd.io.traj.mod_change_box","title":"<code>mod_change_box</code>","text":"<p>Functions:</p> <ul> <li> <code>combine_frame</code>             \u2013              <p>The method to combine 2 Lammps Frames.</p> </li> <li> <code>unwrap_coord_DATA</code>             \u2013              <p>The method to upwrap coords in DATA file.</p> </li> <li> <code>wrap_coords_DUMP</code>             \u2013              <p>The method to flip coords over the center.</p> </li> <li> <code>flip_coords</code>             \u2013              <p>The method to flip coords over the center.</p> </li> <li> <code>replicate</code>             \u2013              <p>The method to flip coords over the center.</p> </li> <li> <code>scale_box</code>             \u2013              <p>The method to change size of simulation box.</p> </li> </ul>"},{"location":"api/#thmd.io.traj.mod_change_box.combine_frame","title":"<code>combine_frame(self, TrajFrame, merge_type=False, alignment='comXYZ', shift_XYZ=None, separate_XYZ=None, merge_box=True, use_box='box1')</code>","text":"<p>The method to combine 2 Lammps Frames.</p> <p>Parameters:</p> <ul> <li> <code>TrajFrame</code>               (<code>TrajFrame Obj</code>)           \u2013            <p>an Object of TrajFrame</p> </li> <li> <code>merge_type</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>merge the same type in 2 TrajFrame.</p> </li> <li> <code>alignment</code>               (<code>str</code>, default:                   <code>'comXYZ'</code> )           \u2013            <p>choose how to align 2 frame. Defaults to 'comXYZ'. + 'comXYZ': align based on COM + 'minXYZ': align based on left corner + 'maxXYZ': align based on right corner</p> </li> <li> <code>shift_XYZ</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>shift a distance from COM aligment. Defaults to [0,0,0].</p> </li> <li> <code>separate_XYZ</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Separate 2 frame with a specific value. Defaults to [0,0,0].</p> </li> <li> <code>merge_box</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>choose to merge box or not. Defaults to True.</p> </li> <li> <code>use_box</code>               (<code>str</code>, default:                   <code>'box1'</code> )           \u2013            <p>be used as the box size if merge_box=False. Defaults to 'box1'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>Update TrajFrame da1</p> </li> </ul> <p>Examples:</p> <pre><code>da1.combine_frame(da2)\n</code></pre> <p>Todo</p> <ul> <li>combine box_angle</li> </ul> <p>Refs:</p> <pre><code>[1]. Deep copy: https://stackoverflow.com/questions/3975376/understanding-dict-copy-shallow-or-deep/3975388#3975388\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_change_box.unwrap_coord_DATA","title":"<code>unwrap_coord_DATA(self, imgFlag=['x', 'y', 'z'], atom_types=[])</code>","text":"<p>The method to upwrap coords in DATA file.</p> <p>Parameters:</p> <ul> <li> <code>imgFlag</code>               (<code>list</code>, default:                   <code>['x', 'y', 'z']</code> )           \u2013            <p>image Flags in data file. Defaults to ['x','y','z'].</p> </li> <li> <code>atom_types</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>just unwrap some atom-types. Defaults to [], mean unwrap all-types.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> Notes <p>cannot unwrap_coord_data if imgFlags are not available.</p>"},{"location":"api/#thmd.io.traj.mod_change_box.wrap_coords_DUMP","title":"<code>wrap_coords_DUMP(self, dim=[1, 1, 1], inplace=True)</code>","text":"<p>The method to flip coords over the center.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>choose the dimenstion to take flip. Defaults to [1,1,1].</p> </li> <li> <code>inplace</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if <code>True</code> it will replace (or addd x y z columns). If <code>False</code> it will return xyz array.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul>"},{"location":"api/#thmd.io.traj.mod_change_box.flip_coords","title":"<code>flip_coords(self, dim=[1, 1, 1])</code>","text":"<p>The method to flip coords over the center.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>choose the dimenstion to take flip. Defaults to [1,1,1].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> TODOs <p>Remove pandas Warning.</p>"},{"location":"api/#thmd.io.traj.mod_change_box.replicate","title":"<code>replicate(self, dim=[1, 1, 1])</code>","text":"<p>The method to flip coords over the center.</p> <p>Parameters:</p> <ul> <li> <code>dim</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>choose the dimenstion to take flip. Defaults to [1,1,1].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul>"},{"location":"api/#thmd.io.traj.mod_change_box.scale_box","title":"<code>scale_box(self, scale=None, final=None, delta=None, remap=True)</code>","text":"<p>The method to change size of simulation box.</p> <p>Parameters:</p> <ul> <li> <code>scale</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>to set scale ratio on each dimension of the box. scale = [0.7, 0.7, None] : if one dimension is set \"None\" its length is not changed.</p> </li> <li> <code>final</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>to set final length on each dimension of the box.</p> </li> <li> <code>delta</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>to set amount of change on each dimension of the box.</p> </li> <li> <code>remap</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>remap atom coordinate. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da.scale_box(scale=[0.7, 0.7, None])\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_change_data","title":"<code>mod_change_data</code>","text":"<p>Functions:</p> <ul> <li> <code>add_column</code>             \u2013              <p>The method to add new columns to da.atom.</p> </li> <li> <code>delete_column</code>             \u2013              <p>The method to delete columns from da.atom.</p> </li> <li> <code>set_mass</code>             \u2013              <p>The method to set masses of atoms in system. Before use it, need to define element_dict with 2 keys: 'type', 'atom_symbol'</p> </li> <li> <code>change_atom_type</code>             \u2013              <p>The method to change types of atoms in system.</p> </li> <li> <code>merge_atom_type</code>             \u2013              <p>The method to merge types of atoms in system.</p> </li> </ul>"},{"location":"api/#thmd.io.traj.mod_change_data.add_column","title":"<code>add_column(self, data, newColumn=None, replace=False)</code>","text":"<p>The method to add new columns to da.atom.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>pd.DataFrame pd.Series list</code>)           \u2013            <p>Nxm data of new columns</p> </li> <li> <code>newColumn</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>1xN list contains names of columns. Default to None, mean it will take columnNames from DataFrame</p> </li> <li> <code>replace</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>replace column if existed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>Update da.atom</p> </li> </ul> <p>Examples:</p> <pre><code>da.add_column(df, myColumn=['col1','col2'], replace=True)\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_change_data.delete_column","title":"<code>delete_column(self, delColumns)</code>","text":"<p>The method to delete columns from da.atom.</p> <p>Parameters:</p> <ul> <li> <code>delColumns</code>               (<code>list</code>)           \u2013            <p>1xN list contains names of columns to be deleted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>Update da.atom</p> </li> </ul> <p>Examples:</p> <pre><code>da.delete_column(delColumns=['col1','col2'])\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_change_data.set_mass","title":"<code>set_mass(self, element_dict)</code>","text":"<p>The method to set masses of atoms in system. Before use it, need to define element_dict with 2 keys: 'type', 'atom_symbol'     element_dict={'type': list_values, 'atom_symbol':list_values}</p> <p>Parameters:</p> <ul> <li> <code>element_dict</code>               (<code>dict</code>)           \u2013            <p>a dict to define atom-types and atom-symbols.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>Update da.atom</p> </li> </ul> <p>Examples:</p> <pre><code>da.set_mass(element_dict={'type':[1,2,3], 'atom_symbol':['C','H','N']})\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_change_data.change_atom_type","title":"<code>change_atom_type(self, old_type, new_type, save_old_type=True)</code>","text":"<p>The method to change types of atoms in system.</p> <p>Parameters:</p> <ul> <li> <code>old_type</code>               (<code>list</code>)           \u2013            <p>a list of old-types.</p> </li> <li> <code>new_type</code>               (<code>int</code>)           \u2013            <p>one new-type.</p> </li> <li> <code>save_old_type</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>to back up old types. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da.chage_atom_type([1,2,3], 2)\n</code></pre>"},{"location":"api/#thmd.io.traj.mod_change_data.merge_atom_type","title":"<code>merge_atom_type(self, old_type, save_old_type=True)</code>","text":"<p>The method to merge types of atoms in system.</p> <p>Parameters:</p> <ul> <li> <code>old_type</code>               (<code>list</code>)           \u2013            <p>a list of old-types.</p> </li> <li> <code>save_old_type</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>to back up old types. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da.chage_atom_type([1,2,3], 2)\n</code></pre>"},{"location":"api/#thmd.io.traj.parser_gromacs","title":"<code>parser_gromacs</code>","text":""},{"location":"api/#thmd.io.traj.parser_pdb_xyz","title":"<code>parser_pdb_xyz</code>","text":"<p>Functions:</p> <ul> <li> <code>read_PDB</code>             \u2013              <p>The method to create FRAME object by reading PDB file.</p> </li> <li> <code>read_XYZ</code>             \u2013              <p>The method to create FRAME object by reading XYZ file.</p> </li> <li> <code>write_XYZ</code>             \u2013              <p>The <code>method</code> to write XYZ file.</p> </li> <li> <code>write_PDB</code>             \u2013              <p>The method to write PDB file</p> </li> </ul>"},{"location":"api/#thmd.io.traj.parser_pdb_xyz.read_PDB","title":"<code>read_PDB(self, filename)</code>","text":"<p>The method to create FRAME object by reading PDB file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME record_name (str): atom_symbol (str): same as column 'type' in DUMP format residue_name (str): residue_id (int): chain (str): occupancy (float): beta (float):</p> </li> </ul> <p>Examples:</p> <pre><code>da = TrajFrame(pdb_file='mydata.pdb')\n</code></pre>"},{"location":"api/#thmd.io.traj.parser_pdb_xyz.read_XYZ","title":"<code>read_XYZ(self, filename)</code>","text":"<p>The method to create FRAME object by reading XYZ file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da = TrajFrame(pdb_file='mydata.pdb')\n</code></pre>"},{"location":"api/#thmd.io.traj.parser_pdb_xyz.write_XYZ","title":"<code>write_XYZ(self, filename, column=['X', 'xu', 'yu', 'zu'], fmt=None)</code>","text":"<p>The <code>method</code> to write XYZ file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> <li> <code>column</code>               (<code>list</code>, default:                   <code>['X', 'xu', 'yu', 'zu']</code> )           \u2013            <p>list-of-str contains columns to be written. Defaults to ['X','xu','yu','zu']</p> </li> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>string format for output values. Defaults to None, mean use self.fmt</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (              <code>obj</code> )          \u2013            <p>the XYZ file</p> </li> </ul> <p>Examples:</p> <pre><code>da.write_XYZ('test.xyz')\n</code></pre>"},{"location":"api/#thmd.io.traj.parser_pdb_xyz.write_PDB","title":"<code>write_PDB(self, filename, writeBox=False)</code>","text":"<p>The method to write PDB file</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> <li> <code>writeBox</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>write box or not.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (              <code>obj</code> )          \u2013            <p>the PDB file</p> </li> </ul> <p>Examples:</p> <pre><code>da.write_PDB('test.pdb')\n</code></pre>"},{"location":"api/#thmd.latex","title":"<code>latex</code>","text":"<p>Functions:</p> <ul> <li> <code>get_citekeys</code>             \u2013              <p>Extract all citekeys from a list of <code>.tex</code> files.</p> </li> <li> <code>select_entries</code>             \u2013              <p>Select bibliography entries from a Bibtex <code>.bib</code> file</p> </li> <li> <code>write_bibtex</code>             \u2013              <p>Write bibliography data to a Bibtex <code>.bib</code> file</p> </li> <li> <code>minimize_bibtex</code>             \u2013              <p>Minimize the <code>.bib</code> file so that it contains only entries that are cited in the <code>.tex</code> files.</p> </li> <li> <code>check_bibtex</code>             \u2013              <p>Check for missing fields in the bibtex entries. Based on the <code>type</code> of the entry, there are mandatory fields. This function is to check if any of mandatory fields is missing.</p> </li> <li> <code>tex2doc</code>             \u2013              <p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file.</p> </li> <li> <code>tex2pdf</code>             \u2013              <p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file.</p> </li> <li> <code>replace_acronyms</code>             \u2013              <p>Check and replace if acronyms are used in a <code>.tex</code> file.</p> </li> <li> <code>count_cited_journals</code>             \u2013              <p>Count the number of times each journal is cited in the <code>.bib</code> file.</p> </li> </ul>"},{"location":"api/#thmd.latex._DATA_PATH","title":"<code>_DATA_PATH = Path(__file__).parents[0].resolve() / '_data'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.latex._check_pybtex","title":"<code>_check_pybtex() -&gt; None</code>","text":"<p>Check if the <code>pybtex</code> library is installed or not. If not, raise an error.</p>"},{"location":"api/#thmd.latex._check_pandoc","title":"<code>_check_pandoc() -&gt; None</code>","text":"<p>check if pandoc is installed or not. If not, raise an error.</p>"},{"location":"api/#thmd.latex.get_citekeys","title":"<code>get_citekeys(tex_files: Union[str, list]) -&gt; list</code>","text":"<p>Extract all citekeys from a list of <code>.tex</code> files.</p> <p>Parameters:</p> <ul> <li> <code>tex_files</code>               (<code>Union[str, list]</code>)           \u2013            <p>paths to <code>.tex</code> files</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>citekeys</code> (              <code>list</code> )          \u2013            <p>list of citekeys</p> </li> </ul>"},{"location":"api/#thmd.latex.select_entries","title":"<code>select_entries(citekeys: list, bib_file: str) -&gt; BibliographyData</code>","text":"<p>Select bibliography entries from a Bibtex <code>.bib</code> file</p> <p>Parameters:</p> <ul> <li> <code>citekeys</code>               (<code>list</code>)           \u2013            <p>list of citekeys</p> </li> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to a <code>.bib</code> file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BibliographyData</code> (              <code>BibliographyData</code> )          \u2013            <p>selected bibliography entries. See pybtex.database.BibliographyData</p> </li> </ul>"},{"location":"api/#thmd.latex.write_bibtex","title":"<code>write_bibtex(bib_data: BibliographyData, out_file: str = 'reference.bib') -&gt; None</code>","text":"<p>Write bibliography data to a Bibtex <code>.bib</code> file</p> <p>Parameters:</p> <ul> <li> <code>bib_data</code>               (<code>BibliographyData</code>)           \u2013            <p>bibliography entries. See pybtex.database.BibliographyData</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'reference.bib'</code> )           \u2013            <p>path to the output <code>.bib</code> file</p> </li> </ul>"},{"location":"api/#thmd.latex.minimize_bibtex","title":"<code>minimize_bibtex(tex_files: Union[str, list], bib_file: str, out_file: str = 'reference_min.bib') -&gt; None</code>","text":"<p>Minimize the <code>.bib</code> file so that it contains only entries that are cited in the <code>.tex</code> files.</p> <p>Parameters:</p> <ul> <li> <code>tex_files</code>               (<code>Union[str, list]</code>)           \u2013            <p>path to <code>.tex</code> files</p> </li> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to the original <code>.bib</code> file</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'reference_min.bib'</code> )           \u2013            <p>path to the new <code>.bib</code> file</p> </li> </ul>"},{"location":"api/#thmd.latex._check_missing_fields","title":"<code>_check_missing_fields(entry: object, fields: list) -&gt; list</code>","text":""},{"location":"api/#thmd.latex.check_bibtex","title":"<code>check_bibtex(bib_file: str, verbose: bool = True, logfile: bool = False, lower_key=False) -&gt; list</code>","text":"<p>Check for missing fields in the bibtex entries. Based on the <code>type</code> of the entry, there are mandatory fields. This function is to check if any of mandatory fields is missing.</p> <p>Parameters:</p> <ul> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to the original <code>.bib</code> file.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>print output to the console.</p> </li> <li> <code>logfile</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>write output to a log file.</p> </li> <li> <code>lower_key</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>convert the keys in <code>bib_file</code> to lower case.</p> </li> </ul> <p>Examples:</p> <pre><code>from thml.latex import check_bibtex\ncheck_bibtex('reference.bib', verbose=True)\n</code></pre>"},{"location":"api/#thmd.latex.tex2doc","title":"<code>tex2doc(tex_file: str, out_file: str = 'output.docx', bib_file: str = None, **kwargs)</code>","text":"<p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file. Need to install <code>pandoc</code> and <code>panflute</code> first. <pre><code>condac install -c conda-forge pandoc\npip install panflute\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>tex_file</code>               (<code>str</code>)           \u2013            <p>path to the <code>.tex</code> file</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'output.docx'</code> )           \u2013            <p>path to the output <code>.docx</code> file</p> </li> <li> <code>bib_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the <code>.bib</code> file</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>cite_style</code>               (<code>str = 'elsevier_vancouver.csl'</code>)           \u2013            <p>path to the citation style <code>.cls' file. Can download from [here](https://github.com/citation-style-language/styles) or in</code>Zotero_folder/styles`</p> </li> <li> <code>reference_doc</code>               (<code>str</code>)           \u2013            <p>path to the reference <code>.docx</code> file</p> </li> <li> <code>resource_path</code>               (<code>str = './figure'</code>)           \u2013            <p>path to the folder containing the figures and other resources.</p> </li> <li> <code>verbose</code>               (<code>bool = False</code>)           \u2013            <p>print the output of the command</p> </li> <li> <code>pandoc-crossref</code>               (<code>bool = True</code>)           \u2013            <p>use the <code>pandoc-crossref</code> extension for equation numbering</p> </li> </ul>"},{"location":"api/#thmd.latex.tex2pdf","title":"<code>tex2pdf(tex_file: str, out_file: str = 'output.pdf', bib_file: str = None, **kwargs)</code>","text":"<p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file.</p> <p>Parameters:</p> <ul> <li> <code>tex_file</code>               (<code>str</code>)           \u2013            <p>path to the <code>.tex</code> file</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'output.pdf'</code> )           \u2013            <p>path to the output <code>.docx</code> file</p> </li> <li> <code>bib_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the <code>.bib</code> file</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>cite_style</code>               (<code>str = 'elsevier_vancouver.csl'</code>)           \u2013            <p>path to the citation style `.cls' file. Can download from here</p> </li> <li> <code>resource_path</code>               (<code>str = './figure'</code>)           \u2013            <p>path to the folder containing the figures and other resources.</p> </li> <li> <code>verbose</code>               (<code>bool = False</code>)           \u2013            <p>print the output of the command</p> </li> </ul>"},{"location":"api/#thmd.latex.replace_acronyms","title":"<code>replace_acronyms(tex_file: str, acronyms: dict) -&gt; list</code>","text":"<p>Check and replace if acronyms are used in a <code>.tex</code> file.</p> <p>Not implemented yet.</p>"},{"location":"api/#thmd.latex.count_cited_journals","title":"<code>count_cited_journals(bib_file: str) -&gt; dict</code>","text":"<p>Count the number of times each journal is cited in the <code>.bib</code> file.</p> <p>Parameters:</p> <ul> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to the <code>.bib</code> file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>a dictionary containing the journal names and the number of times they are cited.</p> </li> </ul>"},{"location":"api/#thmd.model","title":"<code>model</code>","text":"<p>Modules:</p> <ul> <li> <code>D1tube</code>           \u2013            </li> <li> <code>D2haxagonal</code>           \u2013            </li> <li> <code>D3crystal</code>           \u2013            </li> <li> <code>box_tool</code>           \u2013            </li> <li> <code>combining_LJ_interface</code>           \u2013            </li> <li> <code>coord_rotation</code>           \u2013            </li> <li> <code>forcefield_info</code>           \u2013            <p>This module contains some data for various ForceField. Data obtained from simulation</p> </li> <li> <code>polymer_mbuild</code>           \u2013            <p>This module contains classes and functions to build models of atomic polymers</p> </li> <li> <code>polymer_pysimm</code>           \u2013            <p>This module contains classes to build models of atomic polymers</p> </li> </ul>"},{"location":"api/#thmd.model.D1tube","title":"<code>D1tube</code>","text":"<p>Functions:</p> <ul> <li> <code>lattice_CNT</code>             \u2013              <p>Calculates the 3D Cartesian coordinates of atoms of of (n,m) CNT.</p> </li> </ul>"},{"location":"api/#thmd.model.D1tube._UnitCell_CNT","title":"<code>_UnitCell_CNT(m, n, bond_CC=1.421, basis_atom='AB', diameter=None)</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of 1 units cell of (n,m) CNT, which which n &gt;= m &gt;= 0</p> <p>thangckt, Aug 2022</p> <p>Parameters:</p> <ul> <li> <code>n,m</code>               (<code>int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>               (<code>float</code>, default:                   <code>1.421</code> )           \u2013            <p>Length of C-C bonds</p> </li> <li> <code>basis_atom</code>               (<code>str</code>, default:                   <code>'AB'</code> )           \u2013            <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms  - 'AB': full Garaphene-like crystal  - 'A': semi Graphene-like with atom at A-position  - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li> <code>unitbox</code> (              <code>array</code> )          \u2013            <p>size of unit box</p> </li> <li> <code>param</code> (              <code>dict</code> )          \u2013            <p>dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float): length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float): length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float): Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array_1x2): Chiral vector 'Translate_vector' (array_1x2): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p>"},{"location":"api/#thmd.model.D1tube.lattice_CNT","title":"<code>lattice_CNT(m, n, bond_CC=1.421, aspect=1, basis_atom='AB')</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of of (n,m) CNT.</p> <p>thangckt, Aug 2022</p> <p>Parameters:</p> <ul> <li> <code>n,m</code>               (<code>int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>               (<code>float</code>, default:                   <code>1.421</code> )           \u2013            <p>Length of C-C bonds</p> </li> <li> <code>aspect</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The nanotube aspect ratio L/D.</p> </li> <li> <code>basis_atom</code>               (<code>str</code>, default:                   <code>'AB'</code> )           \u2013            <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms  - 'AB': full Garaphene-like crystal  - 'A': semi Graphene-like with atom at A-position  - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>Simulation box</p> </li> <li> <code>param</code> (              <code>dict</code> )          \u2013            <p>dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float): length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float): length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float): Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array): Chiral vector 'Translate_vector' (array): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p>"},{"location":"api/#thmd.model.D2haxagonal","title":"<code>D2haxagonal</code>","text":"<p>Functions:</p> <ul> <li> <code>lattice_Graphene</code>             \u2013              <p>Calculates the 3D Cartesian coordinates of atoms of (n,m)graphene sheet/ Graphite</p> </li> </ul>"},{"location":"api/#thmd.model.D2haxagonal._UnitCell_2Dhoneycomb","title":"<code>_UnitCell_2Dhoneycomb(m, n, bond_CC=1.421, basis_atom='AB')</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of 1 units cell of (n,m)graphene sheet, which which n &gt;= m &gt;= 0</p> <p>thangckt, Nov 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>n,m</code>               (<code> (int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>               (<code>float</code>, default:                   <code>1.421</code> )           \u2013            <p>Length of C-C bonds</p> </li> <li> <code>basis_atom</code>               (<code>str</code>, default:                   <code>'AB'</code> )           \u2013            <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms  - 'AB': full Garaphene-like crystal  - 'A': semi Graphene-like with atom at A-position  - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>df (DataFrame)  : Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li>           \u2013            <p>unitbox (array) : size of unit box</p> </li> <li>           \u2013            <p>param (dict)        : dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float)    : length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float) : length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float)    : Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array_1x2) : Chiral vector 'Translate_vector' (array_1x2): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p> <p>Refs         <pre><code>Dresselhaus et al. \u201cPhysics of Carbon Nanotubes.\u201d, 1995, doi:10.1016/0008-6223(95)00017-8.\nAntonsen, and Thomas Garm Pedersen. \u201cCharacterisation and Modelling of Carbon Nanotubes,\u201d 2013.\n</code></pre></p>"},{"location":"api/#thmd.model.D2haxagonal._UnitCell_Graphene","title":"<code>_UnitCell_Graphene(m, n, bond_CC=1.421, basis_atom='AB')</code>","text":""},{"location":"api/#thmd.model.D2haxagonal.lattice_Graphene","title":"<code>lattice_Graphene(m, n, bond_CC=1.421, sheet_size=[1, 1], sheet_number=1, layer_bond=3.35, basis_atom='AB')</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of (n,m)graphene sheet/ Graphite</p> <p>thangckt, Nov 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>m</code>               (<code>int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>               (<code>float</code>, default:                   <code>1.421</code> )           \u2013            <p>Length of C-C bonds</p> </li> <li> <code>sheet_size</code>               (<code>list</code>, default:                   <code>[1, 1]</code> )           \u2013            <p>[Xsize, Ysize], size of graphene sheet</p> </li> <li> <code>sheet_number</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>number of sheets</p> </li> <li> <code>layer_bond</code>               (<code>float</code>, default:                   <code>3.35</code> )           \u2013            <p>Length of plane-plane bonds</p> </li> <li> <code>basis_atom</code>               (<code>str</code>, default:                   <code>'AB'</code> )           \u2013            <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms - 'AB': full Garaphene-like crystal - 'A': semi Graphene-like with atom at A-position - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>Simulation box</p> </li> <li> <code>param</code> (              <code>dict</code> )          \u2013            <p>dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float): length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float): length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float): Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array): Chiral vector 'Translate_vector' (array): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p>"},{"location":"api/#thmd.model.D3crystal","title":"<code>D3crystal</code>","text":"<p>Functions:</p> <ul> <li> <code>lattice_orthoRHOMBIC</code>             \u2013              <p>Function to create atomic coordinates for crystal model</p> </li> <li> <code>lattice_CUBIC</code>             \u2013              <p>Shortcut to create CUBIC crystal, as subclass of ortthoRHOMBIC</p> </li> </ul>"},{"location":"api/#thmd.model.D3crystal._UnitCell_orthoRHOMBIC","title":"<code>_UnitCell_orthoRHOMBIC(crystal_type, lattice_constant=[1, 1, 1])</code>","text":"<p>a DICT, contain 1 conventional cell of a Simple crystal UnitCell(FCC, BCC,...), in pricipal axes 100 [001] - V2O5 crystal based on: https://materialsproject.org/materials/mvc-11944/ but change order of lattice constants: c,a,b - This order is the same as: 10.1016/j.triboint.2020.106750</p> <p>Parameters:</p> <ul> <li> <code>crystal_type</code>               (<code>str</code>)           \u2013            <p>'V2O5', 'FCC', 'BCC'</p> </li> <li> <code>lattice_constant</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>lattice constant [a,b,c] corresponding to [x,y,z]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>R</code> (              <code>array</code> )          \u2013            <p>Nx3 array, contain positions of atoms in conventional unit cell.</p> </li> </ul>"},{"location":"api/#thmd.model.D3crystal.lattice_orthoRHOMBIC","title":"<code>lattice_orthoRHOMBIC(crystal_type, lattice_constant, orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], size=[1, 1, 1], bound_cond=[1, 1, 1], tol_on_bound=0.1)</code>","text":"<p>Function to create atomic coordinates for crystal model</p> <p>Parameters:</p> <ul> <li> <code>crystal_type</code>               (<code>str</code>)           \u2013            <p>'V2O5', 'FCC', 'BCC'</p> </li> <li> <code>lattice_constant</code>               (<code>list</code>)           \u2013            <p>lattice constant [a,b,c] corresponding to [x,y,z]</p> </li> <li> <code>orient</code>               (<code>list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array, contain direction vectors define crystal orientation, ex: ([[1,0,0], [0,1,0], [0,0,1]])</p> </li> <li> <code>size</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>[Nx Ny Nz] 1x3 array, size of model, Nx is X-size in lattice constant unit</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 array contain convention for boundary conditions: 1 is peridic; 0 is not</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code> (              <code>array</code> )          \u2013            <p>Nx3 array contain positions of atoms.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of box contain lattice ([[xlo, xhi], [ylo, yhi], [zlo, zhi]])</p> </li> <li> <code>unit_box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of unit cell</p> </li> </ul>"},{"location":"api/#thmd.model.D3crystal.lattice_CUBIC","title":"<code>lattice_CUBIC(crystal_type, lattice_constant, orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], size=[1, 1, 1], bound_cond=[1, 1, 1], tol_on_bound=0.1)</code>","text":"<p>Shortcut to create CUBIC crystal, as subclass of ortthoRHOMBIC</p> <p>Parameters:</p> <ul> <li> <code>crystal_type</code>               (<code>str</code>)           \u2013            <p>'FCC', 'BCC'</p> </li> <li> <code>lattice_constant</code>               (<code>float</code>)           \u2013            <p>lattice constant a</p> </li> <li> <code>orient</code>               (<code>list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array, contain direction vectors define crystal orientation, ex: ([[1,0,0], [0,1,0], [0,0,1]])</p> </li> <li> <code>size</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>[Nx Ny Nz] 1x3 array, size of model, Nx is X-size in lattice constant unit</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 array contain convention for boundary conditions: 1 is peridic; 0 is not</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code> (              <code>array</code> )          \u2013            <p>Nx3 array contain positions of atoms.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of box contain lattice ([[xlo, xhi], [ylo, yhi], [zlo, zhi]])</p> </li> <li> <code>unit_box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of unit cell</p> </li> </ul>"},{"location":"api/#thmd.model.box_tool","title":"<code>box_tool</code>","text":"<p>Functions:</p> <ul> <li> <code>add_periodic_image</code>             \u2013              <p>Function to add \"Periodic Images\" of atoms at Periodic Boundaries (with a specific cutoff distance)</p> </li> <li> <code>wrap_coord_PBC</code>             \u2013              <p>Function to wrap atom positions at Periodic Boundaries</p> </li> <li> <code>shell_fcc</code>             \u2013              <p>Compute nearest-neighbor shells for FCC crystal</p> </li> <li> <code>box_generate</code>             \u2013              <p>Generate orientation and dimensions of simulation box.</p> </li> <li> <code>box_orient</code>             \u2013              <p>Generate orirentations of simulation box.</p> </li> </ul>"},{"location":"api/#thmd.model.box_tool.add_periodic_image","title":"<code>add_periodic_image(points: pd.DataFrame | np.ndarray | list, box: np.ndarray, bound_cond: list = [1, 1, 1], cutoff: float = 6.5) -&gt; pd.DataFrame</code>","text":"<p>Function to add \"Periodic Images\" of atoms at Periodic Boundaries (with a specific cutoff distance) By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>2d-list np.array pd.DataFrame</code>)           \u2013            <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>               (<code>3d-list array</code>)           \u2013            <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> <li> <code>cutoff</code>               (<code>float</code>, default:                   <code>6.5</code> )           \u2013            <p>Cutoff distance</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>contains original atoms and image atoms with remark colum df['image'].</p> </li> </ul> <p>Examples:</p> <p>```py</p> <pre><code>df = add_periodic_image(P, box, bound_cond=[1 1 0], cutoff=5)\n    ```\n</code></pre>"},{"location":"api/#thmd.model.box_tool.wrap_coord_PBC","title":"<code>wrap_coord_PBC(points: pd.DataFrame | np.ndarray | list, box: np.ndarray, bound_cond: list = [1, 1, 1]) -&gt; pd.DataFrame</code>","text":"<p>Function to wrap atom positions at Periodic Boundaries By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>2d-list np.array pd.DataFrame</code>)           \u2013            <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>               (<code>3d-list array</code>)           \u2013            <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>contains atom positions.</p> </li> </ul> <p>Examples:         <code>py     df = wrap_coord_PBC(P, box, bound_cond=[1 1 0], cutoff=5)</code></p>"},{"location":"api/#thmd.model.box_tool.shell_fcc","title":"<code>shell_fcc(a)</code>","text":"<p>Compute nearest-neighbor shells for FCC crystal</p> <p>Parameters:</p> <ul> <li> <code>a</code>               (<code>float</code>)           \u2013            <p>lattice constant</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>shell</code> (              <code>list</code> )          \u2013            <p>5 nearest-neighbor shells</p> </li> </ul>"},{"location":"api/#thmd.model.box_tool.box_generate","title":"<code>box_generate(box_size: list = [1, 1, 1], zDirect: str = '001', xDirect: str = None) -&gt; Dict[str, List]</code>","text":"<p>Generate orientation and dimensions of simulation box.</p> <p>Parameters:</p> <ul> <li> <code>box_size</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>dimension of box on each side as in [100] direction</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>specify the direction of z-side. Defaults to '001', mean nothing is happen.</p> </li> <li> <code>xDirect</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>specify the direction of z-side.  Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>box</code> (              <code>dict</code> )          \u2013            <p>dictionary contain orientation and box_size - 'orient' (list[list]): list-of-vectors of 3 directional vectors. - 'box_size' (list[list]): dimension of box on each side.</p> </li> </ul> <p>Examples:</p> <pre><code>box = box_generate(box_size=[1, 1, 1], zDirect='001')\norient = box['orient']\nbox_size = box['box_size']\n</code></pre>"},{"location":"api/#thmd.model.box_tool.box_orient","title":"<code>box_orient(zDirect: str = '001', xDirect: str = None) -&gt; List[List]</code>","text":"<p>Generate orirentations of simulation box. Args:     zDirect (str): specify the direction of z-side. Defaults to '001', mean nothing is happen.     xDirect (str): specify the direction of z-side.  Defaults to None.</p> <p>Returns:</p> <ul> <li> <code>orient</code> (              <code>list[list]</code> )          \u2013            <p>list-of-vectors of 3 directional vectors.</p> </li> </ul>"},{"location":"api/#thmd.model.combining_LJ_interface","title":"<code>combining_LJ_interface</code>","text":"<p>Functions:</p> <ul> <li> <code>pair_LJ</code>             \u2013              <p>compute parameters (epsilon &amp; sigma) of LJ potential at interface</p> </li> </ul>"},{"location":"api/#thmd.model.combining_LJ_interface.pair_LJ","title":"<code>pair_LJ(dict_group1, dict_group2, unit_style, combining_rule='geometric', pair_style='lj/cut')</code>","text":"<p>compute parameters (epsilon &amp; sigma) of LJ potential at interface Note that in LAMMPS: 'Lorentz_Berthelot'='arithmetic'   https://tinyurl.com/yzpwg2hs</p> <p>Parameters:</p> <ul> <li> <code>dict_group1,</code>               (<code>dict_group2</code>)           \u2013            <p>Dicts contain sig &amp; eps of each element of 2 surfaces. Must contain keys: 'atom_name', 'type', 'sigma', 'epsilon'</p> </li> <li> <code>unit_style</code>           \u2013            <p>'real' or 'metal'</p> </li> </ul> <pre><code>combining_rule='arithmetic' (also 'Lorentz_Berthelot')\n            + 'arithmetic'/'Lorentz_Berthelot'\n            + 'geometric'\n            + 'sixthpower'\n        pair_style='lj/cut': pair_style of Lammps  lj/cut/coul/long\n        external_interaction: require\n</code></pre> Return <p>list-of-string: contain pair_coeffs for LAMMPS</p> Notes <p>energy unit is kcal/mol, but in OPLSaa of Foyer is kJ/mol. types in 2 dict must either completely different or indentical</p> <p>Examples: PMMA/h_BN interface <pre><code>dict_group1 = {'element':['CT','CT','CT','CT','HC','HC','C_2','O_2','OS','CT','HC'],\n        'atom_name':['opls_135','opls_136','opls_137','opls_139','opls_140','opls_282','opls_465','opls_466','opls_467','opls_468','opls_469'],\n        'type':[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n        'sigma': [3.5, 3.5, 3.5, 3.5, 2.5, 2.42, 3.75, 2.96, 3.0, 3.5, 2.42],\n        'epsilon':[0.066, 0.066, 0.066, 0.066, 0.03, 0.015, 0.105, 0.21, 0.17, 0.066, 0.015]}\ndict_group2 = {'element':['B','N'],\n                'atom_name':['B','N'],\n                'type':[12,13],\n                'sigma': [3.453, 3.365],\n                'epsilon':[0.094988, 0.1448671]}\ncombining_LJ(dict_group1, dict_group2, combining_rule='Lorentz_Berthelot', pair_style='lj/cut/coul/long')\n</code></pre></p>"},{"location":"api/#thmd.model.combining_LJ_interface._lorentz","title":"<code>_lorentz(eps1, eps2, sig1, sig2)</code>","text":""},{"location":"api/#thmd.model.combining_LJ_interface._geometric","title":"<code>_geometric(eps1, eps2, sig1, sig2)</code>","text":""},{"location":"api/#thmd.model.combining_LJ_interface._sixthpower","title":"<code>_sixthpower(eps1, eps2, sig1, sig2)</code>","text":""},{"location":"api/#thmd.model.combining_LJ_interface._compute_LJ_param","title":"<code>_compute_LJ_param(combining_rule, eps1, eps2, sig1, sig2)</code>","text":""},{"location":"api/#thmd.model.coord_rotation","title":"<code>coord_rotation</code>","text":"<p>Classes:</p> <ul> <li> <code>CoordTransform</code>           \u2013            <p>We can express a rotation using direction-cosines-matrix (DCM) or Euler-angles (phi,theta,psi)</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>rot1axis</code>             \u2013              <p>Rotate array of points about 1 axis</p> </li> <li> <code>check_right_hand</code>             \u2013              <p>check right_hand_rule orthogonal of 3 vectors</p> </li> <li> <code>guess_right_hand</code>             \u2013              <p>give 2 vectors, then guess the third vector that satisfy right_hand_rule</p> </li> <li> <code>cartesian2spherical</code>             \u2013              <p>Convert cartesian coordinates to Spherical coordinates</p> </li> </ul>"},{"location":"api/#thmd.model.coord_rotation.CoordTransform","title":"<code>CoordTransform(old_orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], new_orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])</code>","text":"<p>We can express a rotation using direction-cosines-matrix (DCM) or Euler-angles (phi,theta,psi)</p> <p>Parameters:</p> <ul> <li> <code>old_orient</code>               (<code>array / list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array/list, contains 3 mutully orthotropic unit vectors of the OLD basis</p> </li> <li> <code>new_orient</code>               (<code>array / list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array/list, contains 3 mutully orthotropic unit vectors of the NEW basis             (all input vector will be normalized to unit vectors)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code> (              <code>obj</code> )          \u2013            <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>oldAxis = array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nnewAxis = array([[1, -1, 0], [1, 1, -2], [1, 1, 1]])\nBT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\n</code></pre> \"Refs\" <ol> <li>Bower, Allan F. Applied Mechanics of Solids. CRC Press, 2009. page 711</li> <li>https://link.aps.org/doi/10.1103/PhysRevB.92.180102</li> <li>https://en.wikipedia.org/wiki/Euler_angles</li> </ol> <p>Methods:</p> <ul> <li> <code>direction_cosine_matrix</code>             \u2013              <p>Calculate direction-cosines-matrix (DCM) between 2 coordinates systems</p> </li> <li> <code>rotation_matrix</code>             \u2013              <p>Calculate Rotation-matrix (R) as transpose of DCM</p> </li> <li> <code>EA2ROT</code>             \u2013              <p>Calculate Rotation_Matrix Euler Angles (EA) between 2 coordinates systems (ZXZ proper Euler angles)</p> </li> <li> <code>euler_angle</code>             \u2013              <p>Calculate Euler Angles (EA) between 2 coordinates systems (intrinsic ZXZ proper Euler angles)</p> </li> <li> <code>euler_angle_PSpincal</code>             \u2013              <p>Calculate Euler Angles (EA) between 2 coordinates systems (proper Eulerian angles)</p> </li> <li> <code>rotate_3d</code>             \u2013              <p>Rotate a set of points (or set of vectors) from a OLD-coords to NEW-coords</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>old_orient</code>           \u2013            </li> <li> <code>new_orient</code>           \u2013            </li> <li> <code>DCM</code>           \u2013            </li> <li> <code>ROT</code>           \u2013            </li> <li> <code>EA</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.model.coord_rotation.CoordTransform.old_orient","title":"<code>old_orient = np.asarray(old_orient)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.coord_rotation.CoordTransform.new_orient","title":"<code>new_orient = np.asarray(new_orient)</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.coord_rotation.CoordTransform.DCM","title":"<code>DCM = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.coord_rotation.CoordTransform.ROT","title":"<code>ROT = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.coord_rotation.CoordTransform.EA","title":"<code>EA = None</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.coord_rotation.CoordTransform.direction_cosine_matrix","title":"<code>direction_cosine_matrix()</code>","text":"<p>Calculate direction-cosines-matrix (DCM) between 2 coordinates systems</p> <p>Returns:</p> <ul> <li> <code>Q</code>          \u2013            <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\nQ = BT.direction_cosine_matrix()\n</code></pre>"},{"location":"api/#thmd.model.coord_rotation.CoordTransform.rotation_matrix","title":"<code>rotation_matrix()</code>","text":"<p>Calculate Rotation-matrix (R) as transpose of DCM By Cao Thang, Apr 2019,  Update: May2020</p>"},{"location":"api/#thmd.model.coord_rotation.CoordTransform.EA2ROT","title":"<code>EA2ROT(euler_angle, unit='rad')</code>","text":"<p>Calculate Rotation_Matrix Euler Angles (EA) between 2 coordinates systems (ZXZ proper Euler angles) This is just for testing, since we dont know whether input angles yield orthogonal axis or not</p> <p>Parameters:</p> <ul> <li> <code>euler_angle</code>               (<code>list</code>)           \u2013            <p>1x3 array/list (phi,theta,psi) in Rad or Deg</p> </li> <li> <code>unit</code>               (<code>str</code>, default:                   <code>'rad'</code> )           \u2013            <p>'rad' or 'deg'      (default is rad)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Q</code> (              <code>array</code> )          \u2013            <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thmd.CoordTransform()\nDCM = BT.EulerAngle(euler_angle=[90,], unit='deg')\n</code></pre> Notes <p>don't use arctan2()</p>"},{"location":"api/#thmd.model.coord_rotation.CoordTransform.euler_angle","title":"<code>euler_angle(unit='rad')</code>","text":"<p>Calculate Euler Angles (EA) between 2 coordinates systems (intrinsic ZXZ proper Euler angles) https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.as_euler.html#r72d546869407-1</p> <p>Parameters:</p> <ul> <li> <code>unit='rad'</code>           \u2013            <p>'rad' or 'deg'      (default is rad)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Angle</code>          \u2013            <p>1x3 array (phi,theta,psi) in Rad  (apply intrinsic ZXZ proper Euler)</p> </li> </ul> <p>Examples:</p> <p>BT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis) phi,theta,psi = BT.EulerAngle(unit='deg')</p> Notes <ul> <li>don't use arctan2()</li> <li>Rotation Matrix is as to tranpose of DCM, use Rotation Matrix to compute EA</li> <li>To avoid devide by zero, we use 1e-64 instead of 0.</li> </ul>"},{"location":"api/#thmd.model.coord_rotation.CoordTransform.euler_angle_PSpincal","title":"<code>euler_angle_PSpincal(euler_order='zxz', unit='rad', tol=1e-07)</code>","text":"<p>Calculate Euler Angles (EA) between 2 coordinates systems (proper Eulerian angles)</p> <p>Parameters:</p> <ul> <li> <code>unit</code>           \u2013            <p>'rad', 'deg'      (default is rad)</p> </li> <li> <code>euler_order='zxz'</code>           \u2013            <p>rotation order, lowercase [\"zyx\",\"zxy\",\"yxz\",\"xzy\",\"xyz\",\"yzx\",\"zyz\",\"zxz\",\"yxy\",\"yzy\",\"xyx\",\"xzx\"]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Angle</code>          \u2013            <p>1x3 array (phi,theta,psi) in Rad  (apply extrinsic ZXZ proper Euler)</p> </li> </ul> Notes <ul> <li>this module may define psi as phi, and vice versa. So becareful</li> <li>should not use PSpincalc, since it produce unknown value?</li> </ul> \"Refs\" <p>[1] navpy not use 'ZXZ': https://navpy.readthedocs.io/en/latest/code_docs/coordinate_transformations.html [2] use this https://pypi.org/project/PSpincalc/ [3] https://github.com/tuxcell/PSpincalc/blob/master/PSpincalc/PSpincalc.py     Ex: https://github.com/tuxcell/PSpincalc/blob/master/examples/examplesPSpincalc.ipynb</p>"},{"location":"api/#thmd.model.coord_rotation.CoordTransform.rotate_3d","title":"<code>rotate_3d(points)</code>","text":"<p>Rotate a set of points (or set of vectors) from a OLD-coords to NEW-coords</p> <p>Parameters:</p> <ul> <li> <code>points</code>           \u2013            <p>Nx3 array, contain coords in OLD coordinates systems</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code>          \u2013            <p>Nx3 array, contain coords in NEW coordinates systems</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\nnewP = BT.rotate_3d(P)\n</code></pre>"},{"location":"api/#thmd.model.coord_rotation.rot1axis","title":"<code>rot1axis(P, theta, axis='X')</code>","text":"<p>Rotate array of points about 1 axis</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code> </code>)           \u2013            <p>Nx3 array, contain input poits</p> </li> <li> <code>theta</code>               (<code> </code>)           \u2013            <p>the rotation angle in Degree</p> </li> <li> <code>axis</code>               (<code> </code>, default:                   <code>'X'</code> )           \u2013            <p>Rotation axis</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>outP</code>          \u2013            <p>Nx3 array, contain points after rotation</p> </li> </ul>"},{"location":"api/#thmd.model.coord_rotation.check_right_hand","title":"<code>check_right_hand(list_3vec=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])</code>","text":"<p>check right_hand_rule orthogonal of 3 vectors</p>"},{"location":"api/#thmd.model.coord_rotation.guess_right_hand","title":"<code>guess_right_hand(list_2vec=[[1, 0, 0], [0, 1, 0]])</code>","text":"<p>give 2 vectors, then guess the third vector that satisfy right_hand_rule</p>"},{"location":"api/#thmd.model.coord_rotation.cartesian2spherical","title":"<code>cartesian2spherical(xyz)</code>","text":"<p>Convert cartesian coordinates to Spherical coordinates</p> <p>Parameters:</p> <ul> <li> <code>xyz</code>               (<code>array</code>)           \u2013            <p>Mx3 array contain Cartesian coordinates (X, Y, Z)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>shpCoord</code> (              <code>array</code> )          \u2013            <p>Mx3 array contain Spherical coordinates (R, theta, phi). Also (radial distance, polar angle, azimuthal(longitude) angle)</p> </li> </ul> Notes <ol> <li>The polar(theta) angle defined from from Z-axis down (zero at the North pole to 180\u00b0 at the South pole)</li> <li> <p>adapted from this</p> </li> <li> <p>There are many conventions that angles can be</p> <ul> <li>In geography, angles are in latitude/longitude or elevation/azimuthal form, polar angle is called <code>latitude</code>, measuze from XY-plane (ranges from -90\u00b0 at the south pole to 90\u00b0 at the north pole, with 0\u00b0 at the Equator)</li> </ul> <p></p> <ul> <li>In mathematics and physics, polar angle measured from Z-axis (zero at the North pole to 180\u00b0 at the South pole)</li> </ul> <p></p> <ul> <li>In <code>scipy</code>, polar angle is defined as Colatitude, which is a non-negative quantity, ranging from zero at the North pole to 180\u00b0 at the South pole (same as commonly used in mathematics and physics)</li> </ul> </li> </ol>"},{"location":"api/#thmd.model.forcefield_info","title":"<code>forcefield_info</code>","text":"<p>This module contains some data for various ForceField. Data obtained from simulation</p> <p>Classes:</p> <ul> <li> <code>EAM</code>           \u2013            <p>Create an Object (class) of Potential, contain some pre-setup information</p> </li> <li> <code>ReaxFF</code>           \u2013            <p>Create an Object (class) of Potential, contain some pre-setup information</p> </li> </ul>"},{"location":"api/#thmd.model.forcefield_info.EAM","title":"<code>EAM(atom_symbol, force_field, model_type='BULK', zDirect='001', thickness=20)</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information</p> <pre><code>    - Cu: Mishin2001,  Mendelev2008, Foiles1986\n</code></pre> <ul> <li>Al: Laird2000,  Mishin1999,  Mendelev2008,  LiuEA2004, Sheng2011</li> <li>V:  Olsson2009</li> </ul> <p>Parameters:</p> <ul> <li> <code>atom_symbol</code>               (<code>str</code>)           \u2013            <p>define element, e.g., 'Al', 'Cu',...</p> </li> <li> <code>force_field</code>               (<code>str</code>)           \u2013            <p>the name of potential 'Cu' : 'Mishin-2001'; 'Foiles-1986';... 'Al' : 'Mishin-1999'; 'Sheng-2011';...</p> </li> <li> <code>model_type</code>               (<code>str</code>, default:                   <code>'BULK'</code> )           \u2013            <p>type of model (BULK or PLATE)</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>define the crystal orient along the z-direction simulation box, e,g., '001'/ '110'/ '111'</p> </li> <li> <code>thickness</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>define thickness in case <code>model_type=PALTE</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code>          \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>atom_symbol</code>               (<code>str</code>)           \u2013            <p>element</p> </li> <li> <code>force_field</code>               (<code>str</code>)           \u2013            <p>forcefield name.</p> </li> <li> <code>cutoff</code>               (<code>float</code>)           \u2013            <p>return cutoff of forcefield.</p> </li> <li> <code>thermal_coeff</code>               (<code>list</code>)           \u2013            <p>return values thermal expansion coefficients of input Structure</p> </li> </ul> <p>Stored DATA (these data are compute from several simulations, or from papers)</p> <p>Methods:</p> <ul> <li> <code>lattice_constant</code>             \u2013              <p>Compute lattice constant at a specific temperature T.</p> </li> <li> <code>atomic_volume_FCC</code>             \u2013              <p>Compute atomic volume at a specific temperature T.</p> </li> <li> <code>melt_barrier</code>             \u2013              <p>Compute free energy barrier/atom of melting. For a system of N atoms  \\(F = f*N^(2/3)\\) , then barrier/atom  \\(f = F/N^(2/3)\\). This method return f(T)</p> </li> <li> <code>estimate_FCCUBIC_liqsol</code>             \u2013              <p>Estimate value of FCCUBIC parameter in bulk solid/liquid at a specific temperature T.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>coeff_FCCUBIC_liqsol_coexist</code>           \u2013            </li> <li> <code>coeff_FCCUBIC_tail_solid</code>           \u2013            </li> <li> <code>coeff_FCCUBIC_tail_liquid</code>           \u2013            </li> <li> <code>atom_symbol</code>           \u2013            </li> <li> <code>force_field</code>           \u2013            </li> <li> <code>thermal_coeff</code>           \u2013            </li> <li> <code>cutoff</code>           \u2013            </li> <li> <code>melt_barrier_coeff</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.model.forcefield_info.EAM.coeff_FCCUBIC_liqsol_coexist","title":"<code>coeff_FCCUBIC_liqsol_coexist = [-0.000467305786, 0.88174401]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.coeff_FCCUBIC_tail_solid","title":"<code>coeff_FCCUBIC_tail_solid = [-0.0017082985, 1.80537817]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.coeff_FCCUBIC_tail_liquid","title":"<code>coeff_FCCUBIC_tail_liquid = [-9.33394967e-06, 0.608209715]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.atom_symbol","title":"<code>atom_symbol = atom_symbol</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.force_field","title":"<code>force_field = force_field</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.thermal_coeff","title":"<code>thermal_coeff = D[thermal_key]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.cutoff","title":"<code>cutoff = Rcut</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.melt_barrier_coeff","title":"<code>melt_barrier_coeff = melt_barrier[melt_barrier_key]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.EAM.lattice_constant","title":"<code>lattice_constant(temp)</code>","text":"<p>Compute lattice constant at a specific temperature T.</p> <p>Parameters:</p> <ul> <li> <code>temp</code>               (<code>float</code>)           \u2013            <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>a</code> (              <code>float</code> )          \u2013            <p>lattice constant as input temperature.</p> </li> </ul>"},{"location":"api/#thmd.model.forcefield_info.EAM.atomic_volume_FCC","title":"<code>atomic_volume_FCC(temp)</code>","text":"<p>Compute atomic volume at a specific temperature T.</p> <p>Parameters:</p> <ul> <li> <code>temp</code>               (<code>float</code>)           \u2013            <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>V</code> (              <code>float</code> )          \u2013            <p>atomic volume (volume/atom) as input temperature.</p> </li> </ul>"},{"location":"api/#thmd.model.forcefield_info.EAM.melt_barrier","title":"<code>melt_barrier(temp)</code>","text":"<p>Compute free energy barrier/atom of melting. For a system of N atoms  \\(F = f*N^(2/3)\\) , then barrier/atom  \\(f = F/N^(2/3)\\). This method return f(T)</p> <p>Parameters:</p> <ul> <li> <code>temp</code>               (<code>float</code>)           \u2013            <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>barrier</code> (              <code>float</code> )          \u2013            <p>free energy barrier/atom of melting as input temperature.</p> </li> </ul>"},{"location":"api/#thmd.model.forcefield_info.EAM.estimate_FCCUBIC_liqsol","title":"<code>estimate_FCCUBIC_liqsol(temp)</code>","text":"<p>Estimate value of FCCUBIC parameter in bulk solid/liquid at a specific temperature T.</p>"},{"location":"api/#thmd.model.forcefield_info.ReaxFF","title":"<code>ReaxFF(atom_symbol, force_field, model_type='BULK', zDirect='001')</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information</p> <p>Methods:</p> <ul> <li> <code>lattice_constant</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>atom_symbol</code>           \u2013            </li> <li> <code>force_field</code>           \u2013            </li> <li> <code>thermal_coeff</code>           \u2013            </li> <li> <code>cutoff</code>           \u2013            </li> <li> <code>melt_barrier_coeff</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.model.forcefield_info.ReaxFF.atom_symbol","title":"<code>atom_symbol = atom_symbol</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.ReaxFF.force_field","title":"<code>force_field = force_field</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.ReaxFF.thermal_coeff","title":"<code>thermal_coeff = D[thermal_key]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.ReaxFF.cutoff","title":"<code>cutoff = Rcut</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.ReaxFF.melt_barrier_coeff","title":"<code>melt_barrier_coeff = melt_barrier[melt_barrier_key]</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.model.forcefield_info.ReaxFF.lattice_constant","title":"<code>lattice_constant(Temp)</code>","text":""},{"location":"api/#thmd.model.polymer_mbuild","title":"<code>polymer_mbuild</code>","text":"<p>This module contains classes and functions to build models of atomic polymers See this Python package: [1] mBuild: https://mbuild.mosdef.org/en/stable/</p> <p>See the files: D:\\code\\code_simulate\\polymer_c21_pickup_hBN_PMMA ef_using_mBuild_foyer.ipynb</p> NOTEs <ol> <li>Due to mbuild cannot be installed with python 3.10, so import this package in functions to avoid checking in thmd</li> </ol> <p>Functions:</p> <ul> <li> <code>PMMA_chain</code>             \u2013              <p>build polyPMMA from monomers</p> </li> <li> <code>PVC_chain</code>             \u2013              </li> <li> <code>packing_lammps</code>             \u2013              <p>Packing polymer chains into box, and write LAMMPS file</p> </li> </ul>"},{"location":"api/#thmd.model.polymer_mbuild.PMMA_chain","title":"<code>PMMA_chain(chain_len)</code>","text":"<p>build polyPMMA from monomers</p> <p>Parameters:</p> <ul> <li> <code>chain_len</code>               (<code>int</code>)           \u2013            <p>number of monomers in each polymer = degree of polymerization</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>chain</code> (              <code>compound</code> )          \u2013            <p>polymer chain</p> </li> </ul>"},{"location":"api/#thmd.model.polymer_mbuild.PVC_chain","title":"<code>PVC_chain(chain_len)</code>","text":""},{"location":"api/#thmd.model.polymer_mbuild.packing_lammps","title":"<code>packing_lammps(chain, chain_num, density=None, box_size=None, forcefield_name=None, forcefield_files=None, atom_style='full', unit_style='metal', combining_rule='geometric', file_name='polymer.dat')</code>","text":"<p>Packing polymer chains into box, and write LAMMPS file Packing based on either density or box_size.</p> <p>Parameters:</p> <ul> <li> <code>chain</code>               (<code>compound</code>)           \u2013            <p>polymer chain</p> </li> <li> <code>chain_num</code>               (<code>int</code>)           \u2013            <p>number of chains to be packed.</p> </li> <li> <code>density</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>density, unit in kg/m3 (= 1e-3 g/cm3)</p> </li> <li> <code>box_size</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>box_size = [3,3,3]</p> </li> <li> <code>forcefield_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>should be 'oplsaa'.</p> </li> <li> <code>forcefield_files</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the *.xml file.</p> </li> <li> <code>atom_style</code>               (<code>str</code>, default:                   <code>'full'</code> )           \u2013            <p>atom_style of LAMMPS.</p> </li> <li> <code>unit_style</code>               (<code>str</code>, default:                   <code>'metal'</code> )           \u2013            <p>can be 'metal'/'real'/'lj'</p> </li> </ul>"},{"location":"api/#thmd.model.polymer_pysimm","title":"<code>polymer_pysimm</code>","text":"<p>This module contains classes to build models of atomic polymers See this Python package: [1] pysimm: A python package for simulation of molecular systems, 10.1016/j.softx.2016.12.002 source code: https://github.com/polysimtools/pysimm</p>"},{"location":"api/#thmd.plot","title":"<code>plot</code>","text":"<p>This module provides functions and class to produce publication-quality figures. The main idea is to create a handy class which setup all necessary parameters for plotting, and then just call its methods to produce the publication-quality figures.</p> <p>The core class is the <code>Plotter</code>, which is built on top of <code>matplotlib.pyplot</code>. The <code>Plotter</code>, therefore, has all useful functions from <code>matplotlib.pyplot</code>.</p> <p>Assume we have a data frame <code>df</code>: <pre><code>import numpy as np\nimport polars as pl\nx = np.arange(0, 1000)\ndf = pl.DataFrame({'x': x, 'y': x**2})\n</code></pre></p> <p>Then, use the <code>Plotter().plt</code> to plot the data as a normal <code>matplotlib.pyplot</code> object. Adapt all functions from <code>matplotlib.pyplot</code>. <pre><code>from thmd.plot import Plotter\nplt = Plotter(style='thang').plt\nplt.plot(df['x'], df['y'])\nplt.show()\n</code></pre></p> Refs <ol> <li>Customizing Matplotlib with style sheets and rcParams</li> <li>Figure size Elsevier<ul> <li>Single column: W = 90 mm (~3.5 in). H = W*\u2158 = 2.8</li> <li>Double column: W = 190 mm (~7.5 in). H = 6</li> </ul> </li> </ol> <p>Classes:</p> <ul> <li> <code>Plotter</code>           \u2013            <p>Class to produce publication-quality figures with matplotlib.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>custom_styles</code>             \u2013              <p>style for matplotlib</p> </li> </ul>"},{"location":"api/#thmd.plot._COLOR","title":"<code>_COLOR = ['black', 'red', 'blue', 'green', 'magenta', 'orange', 'lime', 'cyan', 'violet', 'purple', 'olive', 'gray', 'yellow', 'navy', 'saddlebrown', 'darkgreen', 'lawngreen', 'lightgreen', 'steelblue', 'darkcyan', 'plum', 'slateblue', 'indigo']</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.plot._MARKER","title":"<code>_MARKER = ['o', 's', 'D', 'p', '*', '^', 'd', 'H', 'X', '&gt;', '&lt;', '^']</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.plot._LINE","title":"<code>_LINE = {'solid': 'solid', 'dotted': 'dotted', 'dashed': 'dashed', 'dashdot': 'dashdot', 'loosely dotted': (0, (1, 10)), 'densely dotted': (0, (1, 1)), 'loosely dashed': (0, (5, 10)), 'densely dashed': (0, (5, 1)), 'loosely dashdotted': (0, (3, 10, 1, 10)), 'dashdotted': (0, (3, 5, 1, 5)), 'densely dashdotted': (0, (3, 1, 1, 1)), 'dashdotdotted': (0, (3, 5, 1, 5, 1, 5)), 'loosely dashdotdotted': (0, (3, 10, 1, 10, 1, 10)), 'densely dashdotdotted': (0, (3, 1, 1, 1, 1, 1))}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.plot.Plotter","title":"<code>Plotter()</code>","text":"<p>Class to produce publication-quality figures with matplotlib.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>str</code>)           \u2013            <p>the plotting style.</p> </li> </ul> <p>Examples:</p> <pre><code>from thmd.plot import Plotter\nplt = Plotter().plt\nplt.plot(df['x'], df['y'])\n</code></pre> <p>Methods:</p> <ul> <li> <code>get_plt</code>             \u2013              <p>Shortcut to the <code>matplotlib.pyplot</code> object.</p> </li> <li> <code>set_minor_locator</code>             \u2013              <p>Set minor locator for axes</p> </li> <li> <code>get_PdfPages</code>             \u2013              <p>shortcut to <code>matplotlib.backends.backend_pdf.PdfPages</code>.</p> </li> <li> <code>avail_styles</code>             \u2013              <p>List all available styles.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>COLOR</code>           \u2013            </li> <li> <code>MARKER</code>           \u2013            </li> <li> <code>LINE</code>           \u2013            </li> <li> <code>info</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.plot.Plotter.COLOR","title":"<code>COLOR = _COLOR</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.plot.Plotter.MARKER","title":"<code>MARKER = _MARKER</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.plot.Plotter.LINE","title":"<code>LINE = _LINE</code>  <code>instance-attribute</code>","text":""},{"location":"api/#thmd.plot.Plotter.info","title":"<code>info</code>  <code>property</code>","text":""},{"location":"api/#thmd.plot.Plotter.get_plt","title":"<code>get_plt(style: str = 'thang')</code>","text":"<p>Shortcut to the <code>matplotlib.pyplot</code> object.</p>"},{"location":"api/#thmd.plot.Plotter.set_minor_locator","title":"<code>set_minor_locator(ax: object, xminor=1, yminor=1)</code>","text":"<p>Set minor locator for axes</p>"},{"location":"api/#thmd.plot.Plotter.get_PdfPages","title":"<code>get_PdfPages()</code>","text":"<p>shortcut to <code>matplotlib.backends.backend_pdf.PdfPages</code>.</p>"},{"location":"api/#thmd.plot.Plotter.avail_styles","title":"<code>avail_styles()</code>","text":"<p>List all available styles.</p>"},{"location":"api/#thmd.plot.Plotter._set_style","title":"<code>_set_style(style: str = 'thang')</code>","text":""},{"location":"api/#thmd.plot.custom_styles","title":"<code>custom_styles()</code>","text":"<p>style for matplotlib</p>"},{"location":"api/#thmd.post","title":"<code>post</code>","text":"<p>Modules:</p> <ul> <li> <code>aseAtoms</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.post.aseAtoms","title":"<code>aseAtoms</code>","text":""},{"location":"api/#thmd.qflow","title":"<code>qflow</code>","text":"<p>Modules:</p> <ul> <li> <code>help_function</code>           \u2013            <p>Define support functions for qflow package.</p> </li> <li> <code>machine_unist</code>           \u2013            </li> <li> <code>qsub_script</code>           \u2013            <p>Define the template for qsub job submission.</p> </li> <li> <code>resource_unist</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.qflow.help_function","title":"<code>help_function</code>","text":"<p>Define support functions for qflow package.</p> <p>Functions:</p> <ul> <li> <code>read_nodes</code>             \u2013              <p>Read node list from file.</p> </li> <li> <code>format_ignore_string</code>             \u2013              <p>Format <code>qsub_string</code> for ignore nodes.</p> </li> <li> <code>format_select_string</code>             \u2013              <p>Format <code>qsub_string</code> for selected nodes.</p> </li> </ul>"},{"location":"api/#thmd.qflow.help_function.read_nodes","title":"<code>read_nodes(file_name: str) -&gt; list</code>","text":"<p>Read node list from file.     Support delimiter: '|', ',', ';', ':', ' ', ' '</p> <pre><code>Args:\n    file_name (str): File name.\n\nReturns:\n    list: List of unique nodes.\n</code></pre>"},{"location":"api/#thmd.qflow.help_function.format_ignore_string","title":"<code>format_ignore_string(nodes: list) -&gt; str</code>","text":"<p>Format <code>qsub_string</code> for ignore nodes.</p>"},{"location":"api/#thmd.qflow.help_function.format_select_string","title":"<code>format_select_string(nodes: list) -&gt; str</code>","text":"<p>Format <code>qsub_string</code> for selected nodes.</p>"},{"location":"api/#thmd.qflow.machine_unist","title":"<code>machine_unist</code>","text":"<p>Functions:</p> <ul> <li> <code>Tachyon</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>Eagle</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>Lion</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>Leopard</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>CanCentosGpu</code>             \u2013              <p>Define Machine for running jobs on CAN cluster at UNIST.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>sge_template</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.qflow.machine_unist.sge_template","title":"<code>sge_template = {'context_type': 'SSHContext', 'batch_type': 'SGE', 'local_root': './', 'remote_root': '/home1/p001cao/work/w24_tmp', 'remote_profile': {'hostname': '10.0.7.53', 'username': 'p001cao', 'password': 'p001cao', 'port': 2022, 'timeout': 20}}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.qflow.machine_unist.Tachyon","title":"<code>Tachyon(remote_path: str = '/home1/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/home1/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"api/#thmd.qflow.machine_unist.Eagle","title":"<code>Eagle(remote_path: str = '/uwork/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/uwork/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"api/#thmd.qflow.machine_unist.Lion","title":"<code>Lion(remote_path: str = '/uwork/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/uwork/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"api/#thmd.qflow.machine_unist.Leopard","title":"<code>Leopard(remote_path: str = '/uwork/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/uwork/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"api/#thmd.qflow.machine_unist.CanCentosGpu","title":"<code>CanCentosGpu(remote_path: str = '/home/tha/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on CAN cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/home/tha/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"api/#thmd.qflow.qsub_script","title":"<code>qsub_script</code>","text":"<p>Define the template for qsub job submission.</p> <p>Functions:</p> <ul> <li> <code>qsub_sge_job</code>             \u2013              <p>Return the example script for submiting SGE job.</p> </li> <li> <code>winBAT_submit_dispatcher</code>             \u2013              <p>Return the windows batch script for submitting DP dispatcher.</p> </li> <li> <code>winBAT_cmd</code>             \u2013              <p>Return the example script for running command in cmd.</p> </li> <li> <code>winBAT_wsl</code>             \u2013              <p>Return the example script for running command in cmd.</p> </li> <li> <code>python_dispatcher</code>             \u2013              <p>Return the example script for using dpdispatcher.</p> </li> </ul>"},{"location":"api/#thmd.qflow.qsub_script._DATA_PATH","title":"<code>_DATA_PATH = Path(__file__).parent / 'lib_shell'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.qflow.qsub_script.qsub_sge_job","title":"<code>qsub_sge_job() -&gt; str</code>","text":"<p>Return the example script for submiting SGE job.</p>"},{"location":"api/#thmd.qflow.qsub_script.winBAT_submit_dispatcher","title":"<code>winBAT_submit_dispatcher(conda_env: str = None) -&gt; str</code>","text":"<p>Return the windows batch script for submitting DP dispatcher.</p>"},{"location":"api/#thmd.qflow.qsub_script.winBAT_cmd","title":"<code>winBAT_cmd(command: str, conda_env: str = 'py11') -&gt; str</code>","text":"<p>Return the example script for running command in cmd.</p>"},{"location":"api/#thmd.qflow.qsub_script.winBAT_wsl","title":"<code>winBAT_wsl(command: str, conda_env: str = 'py11') -&gt; str</code>","text":"<p>Return the example script for running command in cmd.</p>"},{"location":"api/#thmd.qflow.qsub_script.python_dispatcher","title":"<code>python_dispatcher() -&gt; str</code>","text":"<p>Return the example script for using dpdispatcher.</p>"},{"location":"api/#thmd.qflow.resource_unist","title":"<code>resource_unist</code>","text":"<p>Functions:</p> <ul> <li> <code>Tachyon_lammps_ib</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only InfiniBand nodes.</p> </li> <li> <code>Tachyon_lammps_tcp</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only use TCP.</p> </li> <li> <code>Tachyon_gpaw_ib</code>             \u2013              <p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> </li> <li> <code>Tachyon_gpaw_ucx</code>             \u2013              <p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> </li> <li> <code>Tachyon_gpaw_tcp</code>             \u2013              </li> <li> <code>Tachyon_lammps_ase</code>             \u2013              </li> <li> <code>Tachyon_ase_ib</code>             \u2013              </li> <li> <code>Tachyon_ase_tcp</code>             \u2013              </li> <li> <code>Lion_lammps</code>             \u2013              <p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> </li> <li> <code>Leopard_lammps</code>             \u2013              </li> <li> <code>Eagle_lammps</code>             \u2013              <p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> </li> <li> <code>CanCentosGpu_lammps</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> </li> <li> <code>CanCentosGpu_gpaw</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> </li> <li> <code>CanCentosGpu_ase</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>tachyon_template</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist._DATA_PATH","title":"<code>_DATA_PATH = Path(__file__).parent / '_data_cluster_UNIST'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.qflow.resource_unist.tachyon_template","title":"<code>tachyon_template = {'group_size': 1, 'queue_name': 'ib.q', 'kwargs': {'pe_name': 'mpi_8', 'job_name': 'zDP'}, 'cpu_per_node': 8, 'custom_flags': ['#$ -l  h_rt=168:00:00', '#$ -l  mem_used=600M'], 'source_list': ['/etc/profile.d/modules.sh'], 'module_list': ['mpi/openmpi4.1.7-clang17-IB', 'lammps/llvmOMPI4-dev'], 'envs': {'OMP_NUM_THREADS': 1, 'OMPI_MCA_btl_openib_allow_ib': 1, 'OMPI_MCA_btl': '^tcp'}}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.qflow.resource_unist._error_nodes_ucx","title":"<code>_error_nodes_ucx()</code>","text":""},{"location":"api/#thmd.qflow.resource_unist._error_nodes_openib","title":"<code>_error_nodes_openib()</code>","text":""},{"location":"api/#thmd.qflow.resource_unist.Tachyon_lammps_ib","title":"<code>Tachyon_lammps_ib(n_cpu: int = 16)</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only InfiniBand nodes.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.Tachyon_lammps_tcp","title":"<code>Tachyon_lammps_tcp(n_cpu: int = 8)</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only use TCP.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.Tachyon_gpaw_ib","title":"<code>Tachyon_gpaw_ib(n_cpu: int = 16)</code>","text":"<p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.Tachyon_gpaw_ucx","title":"<code>Tachyon_gpaw_ucx(n_cpu: int = 16)</code>","text":"<p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.Tachyon_gpaw_tcp","title":"<code>Tachyon_gpaw_tcp(n_cpu: int = 8)</code>","text":""},{"location":"api/#thmd.qflow.resource_unist.Tachyon_lammps_ase","title":"<code>Tachyon_lammps_ase(n_cpu: int = 16)</code>","text":""},{"location":"api/#thmd.qflow.resource_unist.Tachyon_ase_ib","title":"<code>Tachyon_ase_ib(n_cpu: int = 16)</code>","text":""},{"location":"api/#thmd.qflow.resource_unist.Tachyon_ase_tcp","title":"<code>Tachyon_ase_tcp(n_cpu: int = 8)</code>","text":""},{"location":"api/#thmd.qflow.resource_unist.Lion_lammps","title":"<code>Lion_lammps(n_cpu: int = 12, queue_name: str = 'lion-normal.q', pe_name: str = 'lion-normal', time: str = '168:00:00')</code>","text":"<p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Number of CPU to run job. 12x for Lion, 8x for Leopard, 10x for Eagle.</p> </li> <li> <code>queue_name</code>               (<code>str</code>, default:                   <code>'lion-normal.q'</code> )           \u2013            <p>SGE's queue name. Available queues: - Lion: lion-normal.q, lion-short.q, lion-long.q - Leopard: leopard-normal.q, leopard-short.q, leopard-long.q</p> </li> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'lion-normal'</code> )           \u2013            <p>SGE's Parallel environment name: mpi, mpi_1~mpi_20 - Lion: lion-normal, lion-short, lion-long - Leopard: leopard-normal, leopard-short, leopard-long</p> </li> <li> <code>time</code>               (<code>str</code>, default:                   <code>'168:00:00'</code> )           \u2013            <p>Time limit for the job. normal: '168:00:00', long: '540:00:00'</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.Leopard_lammps","title":"<code>Leopard_lammps(n_cpu: int = 8, queue_name: str = 'leopard-normal.q', pe_name: str = 'leopard-normal', time: str = '168:00:00')</code>","text":""},{"location":"api/#thmd.qflow.resource_unist.Eagle_lammps","title":"<code>Eagle_lammps(n_cpu: int = 10, pe_name: str = 'mpi_10')</code>","text":"<p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of CPU to run job. 12x for Lion, 8x for Leopard, 10x for Eagle.</p> </li> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'mpi_10'</code> )           \u2013            <p>SGE's Parallel environment name: mpi, mpi_1~mpi_20 - Eagle: mpi, mpi_1~mpi_20</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.CanCentosGpu_lammps","title":"<code>CanCentosGpu_lammps(n_cpu: int = 12, pe_name: str = 'mpi_12')</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'mpi_12'</code> )           \u2013            <p>SGE's Parallel environment name.</p> </li> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.CanCentosGpu_gpaw","title":"<code>CanCentosGpu_gpaw(n_cpu: int = 12, pe_name: str = 'mpi_12')</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'mpi_12'</code> )           \u2013            <p>SGE's Parallel environment name.</p> </li> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"api/#thmd.qflow.resource_unist.CanCentosGpu_ase","title":"<code>CanCentosGpu_ase(n_cpu: int = 12, pe_name: str = 'mpi_12')</code>","text":""},{"location":"api/#thmd.recipe","title":"<code>recipe</code>","text":"<p>Modules:</p> <ul> <li> <code>git</code>           \u2013            </li> <li> <code>gpaw</code>           \u2013            </li> <li> <code>lammps</code>           \u2013            </li> <li> <code>mace</code>           \u2013            <p>Some notes</p> </li> <li> <code>mlff</code>           \u2013            </li> <li> <code>ovito</code>           \u2013            </li> <li> <code>plumed</code>           \u2013            </li> <li> <code>sevennet</code>           \u2013            <p>Some notes</p> </li> </ul>"},{"location":"api/#thmd.recipe.git","title":"<code>git</code>","text":""},{"location":"api/#thmd.recipe.gpaw","title":"<code>gpaw</code>","text":"<p>Modules:</p> <ul> <li> <code>arg_parser</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_check_PWcutoff</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_check_kpoints</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_check_kpoints_density</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_optimize</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_singlepoint</code>           \u2013            <p>Some notes</p> </li> </ul>"},{"location":"api/#thmd.recipe.gpaw.arg_parser","title":"<code>arg_parser</code>","text":"<p>Some notes</p> RFE <ul> <li>Python CLI variables: https://stackoverflow.com/questions/4033723/how-do-i-access-command-line-arguments</li> <li>argparse: https://stackoverflow.com/questions/20063/whats-the-best-way-to-parse-command-line-arguments</li> <li>Parse a list in argparse: https://stackoverflow.com/questions/15753701/how-can-i-pass-a-list-as-a-command-line-argument-with-argparse</li> </ul> <p>Functions:</p> <ul> <li> <code>args_optimize</code>             \u2013              </li> </ul>"},{"location":"api/#thmd.recipe.gpaw.arg_parser.args_optimize","title":"<code>args_optimize()</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff","title":"<code>cli_gpaw_check_PWcutoff</code>","text":"<p>Some notes - calc.new() will create a new calculator that inherits all parameters from the current calculator, except for <code>txt</code> and <code>timer</code></p> RFE <ul> <li>convergence-checks: https://wiki.fysik.dtu.dk/gpaw/tutorialsexercises/structureoptimization/water/water.html#convergence-checks</li> <li>Gpaw tools: https://github.com/lrgresearch/gpaw-tools/blob/main/optimizations/optimize_ecut.py</li> </ul> <p>Attributes:</p> <ul> <li> <code>output_dir</code>           \u2013            </li> <li> <code>parallel_args</code>           \u2013            </li> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>ecut</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>new_calc</code>           \u2013            </li> <li> <code>pe</code>           \u2013            </li> <li> <code>out_file</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.output_dir","title":"<code>output_dir = Path('output')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.parallel_args","title":"<code>parallel_args = {'sl_auto': True, 'use_elpa': True}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.parser","title":"<code>parser = argparse.ArgumentParser(description='Check convergence of PW energy cutoff')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.extxyz_file","title":"<code>extxyz_file = args.poscar</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.ecut","title":"<code>ecut = args.ecutoff</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz_file', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.calc","title":"<code>calc = GPAW(mode=PW(550), xc='PBE', occupations=FermiDirac(0.01), kpts={'density': 15, 'gamma': False}, parallel=parallel_args)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.new_calc","title":"<code>new_calc = calc.new(mode=PW(ecut), txt=f'{output_dir}/calc_ecut_{ecut}.txt')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.pe","title":"<code>pe = atoms.get_potential_energy() / len(atoms)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.out_file","title":"<code>out_file = f'{output_dir}/check_ecut_{ecut}.txt'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints","title":"<code>cli_gpaw_check_kpoints</code>","text":"<p>Some notes</p> RFE <ul> <li>convergence-checks: https://wiki.fysik.dtu.dk/gpaw/tutorialsexercises/structureoptimization/water/water.html#convergence-checks</li> <li>Gpaw tools: https://github.com/lrgresearch/gpaw-tools/blob/main/optimizations/optimize_kpoints.py</li> <li>Parse a list in argparse: https://stackoverflow.com/questions/15753701/how-can-i-pass-a-list-as-a-command-line-argument-with-argparse</li> </ul> <p>Attributes:</p> <ul> <li> <code>output_dir</code>           \u2013            </li> <li> <code>parallel_args</code>           \u2013            </li> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>pbc</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>pe</code>           \u2013            </li> <li> <code>out_file</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.output_dir","title":"<code>output_dir = Path('output')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.parallel_args","title":"<code>parallel_args = {'sl_auto': True, 'use_elpa': True}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.parser","title":"<code>parser = argparse.ArgumentParser(description='Check convergence of PW energy cutoff')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.extxyz_file","title":"<code>extxyz_file = args.poscar</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.pbc","title":"<code>pbc = [int(item) for item in args.pbc.split(' ')]</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz_file', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.calc","title":"<code>calc = GPAW(mode=PW(550), xc='PBE', occupations=FermiDirac(0.01), kpts={'size': (nkx, nky, nkz), 'gamma': True}, txt=f'{output_dir}/calc_kpoints_{nkx}x{nky}x{nkz}.txt', parallel=parallel_args)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.pe","title":"<code>pe = atoms.get_potential_energy() / len(atoms)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.out_file","title":"<code>out_file = f'{output_dir}/check_kpoints_{nkx}x{nky}x{nkz}.txt'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density","title":"<code>cli_gpaw_check_kpoints_density</code>","text":"<p>Some notes</p> RFE <ul> <li>convergence-checks: https://wiki.fysik.dtu.dk/gpaw/tutorialsexercises/structureoptimization/water/water.html#convergence-checks</li> <li>Gpaw tools: https://github.com/lrgresearch/gpaw-tools/blob/main/optimizations/optimize_kpoints.py</li> </ul> <p>Attributes:</p> <ul> <li> <code>output_dir</code>           \u2013            </li> <li> <code>parallel_args</code>           \u2013            </li> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>kdensity</code>           \u2013            </li> <li> <code>pbc</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>pe</code>           \u2013            </li> <li> <code>out_file</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.output_dir","title":"<code>output_dir = Path('output')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.parallel_args","title":"<code>parallel_args = {'sl_auto': True, 'use_elpa': True}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.parser","title":"<code>parser = argparse.ArgumentParser(description='Check convergence of PW energy cutoff')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.extxyz_file","title":"<code>extxyz_file = args.poscar</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.kdensity","title":"<code>kdensity = args.kdensity</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.pbc","title":"<code>pbc = [int(item) for item in args.pbc.split(' ')]</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz_file', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.calc","title":"<code>calc = GPAW(mode=PW(550), xc='PBE', occupations=FermiDirac(0.01), kpts={'density': kdensity, 'gamma': True}, txt=f'{output_dir}/calc_kdensity_{kdensity}.txt', parallel=parallel_args)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.pe","title":"<code>pe = atoms.get_potential_energy() / len(atoms)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.out_file","title":"<code>out_file = f'{output_dir}/check_kdensity_{kdensity}.txt'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize","title":"<code>cli_gpaw_optimize</code>","text":"<p>Some notes - Must set txt='calc.txt' in GPAW calculator for backward files. - param_yaml must contain     - a dict <code>gpaw</code> with GPAW parameters.     - a dict <code>optimize</code> with ASE optimization parameters.</p> <p>Attributes:</p> <ul> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>configfile</code>           \u2013            </li> <li> <code>pdict</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>gpaw_arg</code>           \u2013            </li> <li> <code>params</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>opt_args</code>           \u2013            </li> <li> <code>relax_dim</code>           \u2013            </li> <li> <code>pbc</code>           \u2013            </li> <li> <code>fmax</code>           \u2013            </li> <li> <code>nsteps</code>           \u2013            </li> <li> <code>atoms_filter</code>           \u2013            </li> <li> <code>opt</code>           \u2013            </li> <li> <code>pot_energy</code>           \u2013            </li> <li> <code>forces</code>           \u2013            </li> <li> <code>stress</code>           \u2013            </li> <li> <code>atoms_fake</code>           \u2013            </li> <li> <code>output_file</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.parser","title":"<code>parser = argparse.ArgumentParser(description='Optimize structure using GPAW')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.configfile","title":"<code>configfile = args.param</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.pdict","title":"<code>pdict = load_setting_file(configfile)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.extxyz_file","title":"<code>extxyz_file = pdict['input_extxyz_path']</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.gpaw_arg","title":"<code>gpaw_arg = pdict.get('gpaw_arg', {})</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.params","title":"<code>params = {'mode': {'name': 'pw', 'ecut': 500}, 'xc': 'PBE', 'convergence': {'energy': 1e-06, 'density': 0.0001, 'eigenstates': 1e-08}, 'occupations': {'name': 'fermi-dirac', 'width': 0.01}, 'txt': 'calc_optimize.txt'}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.calc","title":"<code>calc = GPAW(**params)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.opt_args","title":"<code>opt_args = pdict.get('optimize', {})</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.relax_dim","title":"<code>relax_dim = opt_args.get('relax_dim', None)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.pbc","title":"<code>pbc = atoms.get_pbc()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.fmax","title":"<code>fmax = opt_args.get('fmax', 0.05)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.nsteps","title":"<code>nsteps = opt_args.get('nsteps', 10000)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.atoms_filter","title":"<code>atoms_filter = FrechetCellFilter(atoms, mask=relax_dim)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.opt","title":"<code>opt = BFGS(atoms_filter)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.pot_energy","title":"<code>pot_energy = atoms.get_potential_energy()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.forces","title":"<code>forces = atoms.get_forces()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.stress","title":"<code>stress = atoms.get_stress(voigt=True)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.atoms_fake","title":"<code>atoms_fake = atoms.copy()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_optimize.output_file","title":"<code>output_file = extxyz_file.replace('.extxyz', '_labeled.extxyz')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint","title":"<code>cli_gpaw_singlepoint</code>","text":"<p>Some notes - Must set txt='calc.txt' in GPAW calculator for backward files. - param_yaml must contain     - a dict <code>gpaw</code> with GPAW parameters.</p> <p>Attributes:</p> <ul> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>configfile</code>           \u2013            </li> <li> <code>pdict</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>gpaw_arg</code>           \u2013            </li> <li> <code>params</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>pot_energy</code>           \u2013            </li> <li> <code>forces</code>           \u2013            </li> <li> <code>stress</code>           \u2013            </li> <li> <code>atoms_fake</code>           \u2013            </li> <li> <code>output_file</code>           \u2013            </li> </ul>"},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.parser","title":"<code>parser = argparse.ArgumentParser(description='Optimize structure using GPAW')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.configfile","title":"<code>configfile = args.param</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.pdict","title":"<code>pdict = load_setting_file(configfile)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.extxyz_file","title":"<code>extxyz_file = pdict['input_extxyz_path']</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.gpaw_arg","title":"<code>gpaw_arg = pdict.get('gpaw_arg', {})</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.params","title":"<code>params = {'mode': {'name': 'pw', 'ecut': 500}, 'xc': 'PBE', 'convergence': {'energy': 1e-06, 'density': 0.0001, 'eigenstates': 1e-08}, 'occupations': {'name': 'fermi-dirac', 'width': 0.01}, 'txt': 'calc_singlepoint.txt'}</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.calc","title":"<code>calc = GPAW(**params)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.pot_energy","title":"<code>pot_energy = atoms.get_potential_energy()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.forces","title":"<code>forces = atoms.get_forces()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.stress","title":"<code>stress = atoms.get_stress(voigt=True)</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.atoms_fake","title":"<code>atoms_fake = atoms.copy()</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.gpaw.cli_gpaw_singlepoint.output_file","title":"<code>output_file = extxyz_file.replace('.extxyz', '_labeled.extxyz')</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.lammps","title":"<code>lammps</code>","text":""},{"location":"api/#thmd.recipe.mace","title":"<code>mace</code>","text":"<p>Some notes</p> RFE <ul> <li>SevenNet repo: https://github.com/MDIL-SNU/SevenNet</li> </ul> <p>Functions:</p> <ul> <li> <code>cli_mace_optimize</code>             \u2013              <p>Return filepath of the script for running optimization using SevenNet.</p> </li> </ul>"},{"location":"api/#thmd.recipe.mace._DATA_PATH","title":"<code>_DATA_PATH = Path(__file__).parent / 'lib_mace'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.mace.cli_mace_optimize","title":"<code>cli_mace_optimize(copy_to: str = None) -&gt; str</code>","text":"<p>Return filepath of the script for running optimization using SevenNet.</p>"},{"location":"api/#thmd.recipe.mlff","title":"<code>mlff</code>","text":""},{"location":"api/#thmd.recipe.ovito","title":"<code>ovito</code>","text":"<p>Functions:</p> <ul> <li> <code>scale_RGB</code>             \u2013              <p>Function to convert RGB color code from scale 0-255 to scale 0-1.</p> </li> <li> <code>mod_set_prop_atom_name</code>             \u2013              <p>Modifier to set atom names</p> </li> <li> <code>mod_set_prop_atom_color_PMMAori</code>             \u2013              <p>Modifier to assign atom colors based on atom_names.</p> </li> <li> <code>delete_pipelines</code>             \u2013              <p>delete all existed viewports, pipelines, and scene</p> </li> </ul>"},{"location":"api/#thmd.recipe.ovito.scale_RGB","title":"<code>scale_RGB(RGB=(255, 255, 255))</code>","text":"<p>Function to convert RGB color code from scale 0-255 to scale 0-1.</p> <p>Parameters:</p> <ul> <li> <code>RGB</code>               (<code>tuple</code>, default:                   <code>(255, 255, 255)</code> )           \u2013            <p>RGB code in scale 0-255</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rgb</code> (              <code>tuple</code> )          \u2013            <p>RGB code in scale 0-1</p> </li> </ul> <p>Examples:</p> <pre><code>rgb = scale_RGB((255,255,255)))\n</code></pre> Quote <ol> <li>rgb-values-to-0-to-1-scale</li> </ol>"},{"location":"api/#thmd.recipe.ovito.mod_set_prop_atom_name","title":"<code>mod_set_prop_atom_name(frame, data)</code>","text":"<p>Modifier to set atom names</p> <p>Examples:</p> <pre><code>from thmd.visual.ovito_modifier import mod_set_prop_atom_name\nfrom ovito.io import import_file\n\npipeline = import_file(\"test.cfg\")\npipeline.add_to_scene()\n## add mod\ndict_name = {'type_id':[1, 2], 'atom_name':['C', 'H']}\npipeline.modifiers.append(mod_set_prop_atom_name)\n</code></pre> Note <ul> <li>So far, can not a custom argument to modifier, see here. So we need to define a <code>global variable</code> before using this function     <pre><code>dict_name = {'type_id':(1, 2), 'atom_name':('C', 'H')}\n</code></pre></li> <li>Do not use 'return` in modifier</li> <li>the underscore notation mean modifiable version of the quantity in ovito</li> </ul> Quote <ol> <li>Pass custom args to modifier</li> <li>ovito.data.Property             - type.id, type.name, type.color, type.radius</li> </ol>"},{"location":"api/#thmd.recipe.ovito.mod_set_prop_atom_color_PMMAori","title":"<code>mod_set_prop_atom_color_PMMAori(frame, data)</code>","text":"<p>Modifier to assign atom colors based on atom_names.</p> <p>Examples:</p> <pre><code>from thmd.visual.ovito_modifier import mod_set_prop_atom_color_PMMAori\nfrom ovito.io import import_file\n\npipeline = import_file(\"test.cfg\")\npipeline.add_to_scene()\n## add mod\npipeline.modifiers.append(mod_set_prop_atom_color_PMMAori)\n</code></pre>"},{"location":"api/#thmd.recipe.ovito.delete_pipelines","title":"<code>delete_pipelines(viewports: list[object] = [], pipelines: list[object] = [], scene: object = None)</code>","text":"<p>delete all existed viewports, pipelines, and scene</p> <p>Parameters:</p> <ul> <li> <code>viewports</code>               (<code>obj</code>, default:                   <code>[]</code> )           \u2013            <p>list of ovito viewport objects</p> </li> <li> <code>pipelines</code>               (<code>obj</code>, default:                   <code>[]</code> )           \u2013            <p>list of ovito pipeline objects</p> </li> <li> <code>scene</code>               (<code>obj</code>, default:                   <code>None</code> )           \u2013            <p>ovito scene object</p> </li> </ul>"},{"location":"api/#thmd.recipe.plumed","title":"<code>plumed</code>","text":"<p>Functions:</p> <ul> <li> <code>script_FCCUBIC</code>             \u2013              <p>PLUMED script to compute FCCUBIC</p> </li> <li> <code>script_LOCAL_CRYSTALINITY</code>             \u2013              <p>PLUMED script to compute LOCAL_CRYSTALINITY</p> </li> <li> <code>script_LOGMFD</code>             \u2013              <p>PLUMED script to compute LOGFMD</p> </li> </ul>"},{"location":"api/#thmd.recipe.plumed.script_FCCUBIC","title":"<code>script_FCCUBIC(a_fcc, zDirect, label='mcv', alpha=27, partialCompute=False, atoms='@mdatoms', atomsA=None, atomsB=None, options='')</code>","text":"<p>PLUMED script to compute FCCUBIC</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>               (<code>float</code>)           \u2013            <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>               (<code>str</code>)           \u2013            <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>'mcv'</code> )           \u2013            <p>label of PLUMED command</p> </li> <li> <code>alpha</code>               (<code>int</code>, default:                   <code>27</code> )           \u2013            <p>ALPHA parameter to compute FCCUBIC colvar.</p> </li> <li> <code>atoms</code>               (<code>str</code>, default:                   <code>'@mdatoms'</code> )           \u2013            <p>specify atom-ids in computed group.</p> </li> <li> <code>partialCompute</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>compute for some atoms.</p> </li> <li> <code>atomsA</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>specify atom-ids in group A.</p> </li> <li> <code>atomsB</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>specify atom-ids in group B.</p> </li> <li> <code>options</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"api/#thmd.recipe.plumed.script_LOCAL_CRYSTALINITY","title":"<code>script_LOCAL_CRYSTALINITY(a_fcc, zDirect, label='mcv', vectors=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], atoms='@mdatoms', options='')</code>","text":"<p>PLUMED script to compute LOCAL_CRYSTALINITY</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>               (<code>float</code>)           \u2013            <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>               (<code>str</code>)           \u2013            <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>'mcv'</code> )           \u2013            <p>label of PLUMED command</p> </li> <li> <code>vectors</code>               (<code>list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>2xN list of lists, to specify directions of reciprocal vectors.</p> </li> <li> <code>atoms</code>               (<code>str</code>, default:                   <code>'@mdatoms'</code> )           \u2013            <p>specify atom-ids in computed group.</p> </li> <li> <code>options</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"api/#thmd.recipe.plumed.script_LOGMFD","title":"<code>script_LOGMFD(ARG, FICT, FICT_MIN, FICT_MAX, TEMP, DELTA_T, INTERVAL, KAPPA, deltaF, deltaX, kB, label='mfd', FLOG=5000, MFDstat='VS')</code>","text":"<p>PLUMED script to compute LOGFMD</p> <p>Parameters:</p> <ul> <li> <code>ARG</code>               (<code>str</code>)           \u2013            <p>the scalar input for this action</p> </li> <li> <code>FICT</code>               (<code>float</code>)           \u2013            <p>The initial values of the fictitious dynamical variables</p> </li> <li> <code>FICT_MIN</code>               (<code>float</code>)           \u2013            <p>Boundaries of CV_space</p> </li> <li> <code>FICT_MAX</code>               (<code>float</code>)           \u2013            <p>Boundaries of CV_space</p> </li> <li> <code>TEMP</code>               (<code>float</code>)           \u2013            <p>Temperature of the fictitious dynamical variables</p> </li> <li> <code>DELTA_T</code>               (<code>float</code>)           \u2013            <p>Time step for the fictitious dynamical variables (MFD step)</p> </li> <li> <code>INTERVAL</code>               (<code>int</code>)           \u2013            <p>Period of MD steps ( Nm) to update fictitious dynamical variables</p> </li> <li> <code>KAPPA</code>               (<code>int</code>)           \u2013            <p>Spring constant of the harmonic restraining potential for the fictitious dynamical variables</p> </li> <li> <code>deltaF</code>               (<code>float</code>)           \u2013            <p>Energy Barrier to estimate ALPHA (Alpha parameter for LogMFD)</p> </li> <li> <code>deltaX</code>               (<code>float</code>)           \u2013            <p>CV distance at each MFDstep, to estimate MFICT, VFICT (mass &amp; velocity of fictitious dynamical variable)</p> </li> <li> <code>kB</code>               (<code>float</code>)           \u2013            <p>Boltzmann constant</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>'mfd'</code> )           \u2013            <p>label of PLUMED command</p> </li> <li> <code>FLOG</code>               (<code>float</code>, default:                   <code>5000</code> )           \u2013            <p>The initial free energy value in the LogMFD, initial F(X)</p> </li> <li> <code>MFDstat</code>               (<code>str</code>, default:                   <code>'VS'</code> )           \u2013            <p>Type of thermostat for the fictitious dynamical variables. NVE, NVT, VS are available.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"api/#thmd.recipe.sevennet","title":"<code>sevennet</code>","text":"<p>Some notes</p> RFE <ul> <li>SevenNet repo: https://github.com/MDIL-SNU/SevenNet</li> </ul> <p>Functions:</p> <ul> <li> <code>cli_7net_optimize</code>             \u2013              <p>Return filepath of the script for running optimization using SevenNet.</p> </li> </ul>"},{"location":"api/#thmd.recipe.sevennet._DATA_PATH","title":"<code>_DATA_PATH = Path(__file__).parent / 'lib_7net'</code>  <code>module-attribute</code>","text":""},{"location":"api/#thmd.recipe.sevennet.cli_7net_optimize","title":"<code>cli_7net_optimize(copy_to: str = None) -&gt; str</code>","text":"<p>Return filepath of the script for running optimization using SevenNet.</p>"},{"location":"api/#thmd.util","title":"<code>util</code>","text":"<p>Modules:</p> <ul> <li> <code>check_installation</code>           \u2013            </li> <li> <code>compute_angle</code>           \u2013            </li> <li> <code>compute_distance</code>           \u2013            </li> <li> <code>compute_tensor</code>           \u2013            </li> <li> <code>detect_sign_change</code>           \u2013            </li> <li> <code>fit</code>           \u2013            </li> <li> <code>grid_box</code>           \u2013            </li> <li> <code>many_stuff</code>           \u2013            </li> <li> <code>row_operation</code>           \u2013            </li> <li> <code>string_index</code>           \u2013            </li> <li> <code>unit</code>           \u2013            <p>This module to convert unit of some physical properties</p> </li> </ul>"},{"location":"api/#thmd.util.check_installation","title":"<code>check_installation</code>","text":"<p>Functions:</p> <ul> <li> <code>check_install_ovito</code>             \u2013              </li> <li> <code>check_install_googlesearch</code>             \u2013              </li> </ul>"},{"location":"api/#thmd.util.check_installation.check_install_ovito","title":"<code>check_install_ovito()</code>","text":""},{"location":"api/#thmd.util.check_installation.check_install_googlesearch","title":"<code>check_install_googlesearch()</code>","text":""},{"location":"api/#thmd.util.compute_angle","title":"<code>compute_angle</code>","text":"<p>Functions:</p> <ul> <li> <code>angle_vector2vectors</code>             \u2013              <p>copmute angles between a vector with set of vectors</p> </li> </ul>"},{"location":"api/#thmd.util.compute_angle.angle_vector2vectors","title":"<code>angle_vector2vectors(fixVector, arrayVectors, unit='rad')</code>","text":"<p>copmute angles between a vector with set of vectors</p>"},{"location":"api/#thmd.util.compute_distance","title":"<code>compute_distance</code>","text":"<p>Functions:</p> <ul> <li> <code>dist2_point2points</code>             \u2013              <p>Compute bond_len and postion_vetors from 1 point to a list of points</p> </li> <li> <code>dist2_points2line</code>             \u2013              <p>Compute bond_len and postion_vetors from 1 point to a list of points</p> </li> <li> <code>closest_points2line</code>             \u2013              <p>Find all points locate inside a checkin-distance \"dist\" from a line.</p> </li> <li> <code>closest_points2multilines</code>             \u2013              <p>Find all points locate inside a checkin-distance \"dist\" from multilines.</p> </li> </ul>"},{"location":"api/#thmd.util.compute_distance.dist2_point2points","title":"<code>dist2_point2points(point, points)</code>","text":"<p>Compute bond_len and postion_vetors from 1 point to a list of points</p> <p>Parameters:</p> <ul> <li> <code>point</code>               (<code>list array</code>)           \u2013            <p>coordinate of 1 point.</p> </li> <li> <code>points</code>               (<code>list array</code>)           \u2013            <p>2d-list of coordinates of points/point.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>pd.DataFrame constains distance and component of connecting vectors.</p> </li> </ul>"},{"location":"api/#thmd.util.compute_distance.dist2_points2line","title":"<code>dist2_points2line(points, line=[(0, 0, 0), (0, 0, 0)])</code>","text":"<p>Compute bond_len and postion_vetors from 1 point to a list of points Ref: https://stackoverflow.com/questions/39840030/distance-between-point-and-a-line-from-two-points</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list array DataFrame</code>)           \u2013            <p>list of coordinates of points/point.</p> </li> <li> <code>line</code>               (<code>list array</code>, default:                   <code>[(0, 0, 0), (0, 0, 0)]</code> )           \u2013            <p>2d-array contains coordinates to define a line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>d</code> (              <code>float list</code> )          \u2013            <p>distances between points and a line.</p> </li> </ul>"},{"location":"api/#thmd.util.compute_distance.closest_points2line","title":"<code>closest_points2line(points, line=[(0, 0, 0), (0, 0, 0)], distance=0, Xbound=None, Ybound=None, Zbound=None)</code>","text":"<p>Find all points locate inside a checkin-distance \"dist\" from a line.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list array</code>)           \u2013            <p>list of coordinates of points/point.</p> </li> <li> <code>line</code>               (<code>list array</code>, default:                   <code>[(0, 0, 0), (0, 0, 0)]</code> )           \u2013            <p>[[x1,y1,z1], [x1,y2,z2]]: 2d-list contains coordinates to define a line.</p> </li> <li> <code>distance</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>the checkin-distance.</p> </li> <li> <code>Xbound</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>define the boundaries for checking. Xbound='line': use the lengths of lines as bounds. Xbound=None: extend to INF. Xbound = (xlo, xhi)</p> </li> <li> <code>Ybound</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>define the boundaries for checking.</p> </li> <li> <code>Zbound</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>define the boundaries for checking.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds_idx</code> (              <code>Series</code> )          \u2013            <p>Series of indices of points within the checkin-distance</p> </li> </ul>"},{"location":"api/#thmd.util.compute_distance.closest_points2multilines","title":"<code>closest_points2multilines(points, multilines=[], distance=0, Xbound=None, Ybound=None, Zbound=None)</code>","text":"<p>Find all points locate inside a checkin-distance \"dist\" from multilines. The Bound is set as the line-lengths.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list array</code>)           \u2013            <p>list of coordinates of points/point.</p> </li> <li> <code>multilines</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>list of pair-points, each pair-point contains coordinates of 2 points to define a line used in 'closest_points2line'.</p> </li> <li> <code>distance</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>the checkin-distance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds_idx</code> (              <code>Series</code> )          \u2013            <p>Series of indices of points within the checkin-distance</p> </li> </ul>"},{"location":"api/#thmd.util.compute_tensor","title":"<code>compute_tensor</code>","text":"<p>Functions:</p> <ul> <li> <code>ke_tensor</code>             \u2013              <p>Compute Kinetic Energy tensors, and Temp</p> </li> <li> <code>stress_tensor</code>             \u2013              <p>Compute local pressure/stress</p> </li> </ul>"},{"location":"api/#thmd.util.compute_tensor.ke_tensor","title":"<code>ke_tensor(vel, mass, kb)</code>","text":"<p>Compute Kinetic Energy tensors, and Temp Args:         vel (array): Nx3 array of per-atom velocity         mass (array): Nx3 array of atomic mass         inUNIT (str): ['angstrom','ps','amu','eV'], outUNIT=['eV','K'] Returns:         Kinetic energy tensor, Kinetic scalar, Temperature scalar</p>"},{"location":"api/#thmd.util.compute_tensor.stress_tensor","title":"<code>stress_tensor(per_atom_stress_tensor, atomic_volume, unitFac=1)</code>","text":"<p>Compute local pressure/stress Args:         per_atom_stress_tensor : Nx6 array of the per-atom stress tensor         atomVol    : Nx1 vector of atomVol         inUNIT=['bar','angstrom'], outUNIT=['bar'] \u2192 unitFac=1e-4 for ['GPa'] Returns:         pressure scalar         Stress tensor</p>"},{"location":"api/#thmd.util.detect_sign_change","title":"<code>detect_sign_change</code>","text":"<p>Functions:</p> <ul> <li> <code>detect_sign_change</code>             \u2013              <p>determine points where line y=y(x) change its sign</p> </li> </ul>"},{"location":"api/#thmd.util.detect_sign_change.detect_sign_change","title":"<code>detect_sign_change(y, x=[])</code>","text":"<p>determine points where line y=y(x) change its sign</p> <p>Parameters:</p> <ul> <li> <code>y</code>           \u2013            <p>Nx1 arrays, contains dependent variable y</p> </li> <li> <code>x</code>           \u2013            <p>(Optinal) Nx1 arrays, contains independent variable x of line y(x)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>idx</code>          \u2013            <p>1d array of indices where sign changes</p> </li> </ul>"},{"location":"api/#thmd.util.fit","title":"<code>fit</code>","text":"<p>Modules:</p> <ul> <li> <code>curve_intersect</code>           \u2013            </li> <li> <code>fit_root</code>           \u2013            </li> <li> <code>user_lmfit</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>curve_intersect_shapely</code>             \u2013              <p>find the intersection points between 2 lines</p> </li> <li> <code>polyfit</code>             \u2013              <p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients.</p> </li> <li> <code>find_slope</code>             \u2013              <p>Compute slope of a linear relation y = A + B*x.</p> </li> <li> <code>find_roots</code>             \u2013              <p>find roots for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_extrema</code>             \u2013              <p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_convergence</code>             \u2013              <p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> </li> <li> <code>extrapolate</code>             \u2013              </li> </ul>"},{"location":"api/#thmd.util.fit.curve_intersect_shapely","title":"<code>curve_intersect_shapely(line1, line2)</code>","text":"<p>find the intersection points between 2 lines Args:         line1 (array like): Nx2 arrays, contains data points of curve 1         line2 (array like): Nx2 arrays, contains data points of curve 2</p> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul>"},{"location":"api/#thmd.util.fit.polyfit","title":"<code>polyfit(x, y, deg=1, sigma_y=None, uncert=False, **kwargs)</code>","text":"<p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients. The fitted polynomial(s) are in the form</p> <pre><code>p(x) = a0 + a1*x + a2*x^2 + ... + an*x^n\n</code></pre> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>deg</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>degree of polynomial</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> <li> <code>uncert</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return uncertainties of coefficients. Defaults to False.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional arguments, adapt all args from <code>np.polyfit</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients</p> </li> <li> <code>uncert</code> (              <code>array</code> )          \u2013            <p>1D array of standard deviation of coefficients</p> </li> </ul>"},{"location":"api/#thmd.util.fit.find_slope","title":"<code>find_slope(x, y)</code>","text":"<p>Compute slope of a linear relation y = A + B*x.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> </ul> Return <p>slope (float): the slope to linear relation</p>"},{"location":"api/#thmd.util.fit.find_roots","title":"<code>find_roots(x, y, order=1)</code>","text":"<p>find roots for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>order of polynomial. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>roots</code> (              <code>list</code> )          \u2013            <p>list of roots</p> </li> </ul>"},{"location":"api/#thmd.util.fit.find_extrema","title":"<code>find_extrema(x, y, order=2, retun_fit=False)</code>","text":"<p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>order of polynomial. Defaults to 2.</p> </li> <li> <code>retun_fit</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return fitted params. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>list</code> )          \u2013            <p>list of flex points.</p> </li> </ul>"},{"location":"api/#thmd.util.fit.find_convergence","title":"<code>find_convergence(x, y, tol=1e-06, grid_size=None, convergence_side='right')</code>","text":"<p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x values</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y values</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>tolerance of the slope (dy/dx). Defaults to 1e-6.</p> </li> <li> <code>grid_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>set grid size of x if need to interpolate finer data. Defaults to None.</p> </li> <li> <code>convergence_side</code>               (<code>str</code>, default:                   <code>'right'</code> )           \u2013            <p>find the first x on the left or right side. Defaults to \"right\".</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>best_x, best_y (float): found x and y value that y converge with a tolerance &lt; tol.</p> </li> </ul> Notes <p>Value <code>df['dy'] = df['y'].diff()</code> depends on grid size. Should use <code>df['dy'] = df['y'].diff()/ df['x'].diff()</code>.</p> References <ol> <li>https://docs.scipy.org/doc/scipy/tutorial/interpolate.html</li> </ol>"},{"location":"api/#thmd.util.fit.extrapolate","title":"<code>extrapolate(x, y, left_side: list = None, right_side: list = None, grid_size=0.1) -&gt; tuple[list, list]</code>","text":""},{"location":"api/#thmd.util.fit.curve_intersect","title":"<code>curve_intersect</code>","text":"<p>Functions:</p> <ul> <li> <code>curve_intersect_shapely</code>             \u2013              <p>find the intersection points between 2 lines</p> </li> </ul>"},{"location":"api/#thmd.util.fit.curve_intersect.curve_intersect_shapely","title":"<code>curve_intersect_shapely(line1, line2)</code>","text":"<p>find the intersection points between 2 lines Args:         line1 (array like): Nx2 arrays, contains data points of curve 1         line2 (array like): Nx2 arrays, contains data points of curve 2</p> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul>"},{"location":"api/#thmd.util.fit.curve_intersect.___curve_intersect_numpy","title":"<code>___curve_intersect_numpy(curve1, curve2, degree=3, bounds=None)</code>","text":"<p>find the intersection points between 2 curves</p> <p>Parameters:</p> <ul> <li> <code>curve1</code>               (<code>array like</code>)           \u2013            <p>Nx2 arrays in form (x,y), contains data points of curve 1</p> </li> <li> <code>curve2</code>               (<code>array like</code>)           \u2013            <p>Nx2 arrays in form (x,y), contains data points of curve 2</p> </li> <li> <code>degree</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>degree of polynomial function to fit the curve</p> </li> <li> <code>bounds</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>(min, max) of x, to select points in bounds</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul> Refs <p>[1] http://t.ly/2_a-K</p>"},{"location":"api/#thmd.util.fit.fit_root","title":"<code>fit_root</code>","text":"<p>Functions:</p> <ul> <li> <code>polyfit</code>             \u2013              <p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients.</p> </li> <li> <code>find_slope</code>             \u2013              <p>Compute slope of a linear relation y = A + B*x.</p> </li> <li> <code>find_roots</code>             \u2013              <p>find roots for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_extrema</code>             \u2013              <p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_convergence</code>             \u2013              <p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> </li> <li> <code>extrapolate</code>             \u2013              </li> </ul>"},{"location":"api/#thmd.util.fit.fit_root.polyfit","title":"<code>polyfit(x, y, deg=1, sigma_y=None, uncert=False, **kwargs)</code>","text":"<p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients. The fitted polynomial(s) are in the form</p> <pre><code>p(x) = a0 + a1*x + a2*x^2 + ... + an*x^n\n</code></pre> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>deg</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>degree of polynomial</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> <li> <code>uncert</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return uncertainties of coefficients. Defaults to False.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional arguments, adapt all args from <code>np.polyfit</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients</p> </li> <li> <code>uncert</code> (              <code>array</code> )          \u2013            <p>1D array of standard deviation of coefficients</p> </li> </ul>"},{"location":"api/#thmd.util.fit.fit_root.find_slope","title":"<code>find_slope(x, y)</code>","text":"<p>Compute slope of a linear relation y = A + B*x.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> </ul> Return <p>slope (float): the slope to linear relation</p>"},{"location":"api/#thmd.util.fit.fit_root.find_roots","title":"<code>find_roots(x, y, order=1)</code>","text":"<p>find roots for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>order of polynomial. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>roots</code> (              <code>list</code> )          \u2013            <p>list of roots</p> </li> </ul>"},{"location":"api/#thmd.util.fit.fit_root.find_extrema","title":"<code>find_extrema(x, y, order=2, retun_fit=False)</code>","text":"<p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>order of polynomial. Defaults to 2.</p> </li> <li> <code>retun_fit</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return fitted params. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>list</code> )          \u2013            <p>list of flex points.</p> </li> </ul>"},{"location":"api/#thmd.util.fit.fit_root.find_convergence","title":"<code>find_convergence(x, y, tol=1e-06, grid_size=None, convergence_side='right')</code>","text":"<p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x values</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y values</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>tolerance of the slope (dy/dx). Defaults to 1e-6.</p> </li> <li> <code>grid_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>set grid size of x if need to interpolate finer data. Defaults to None.</p> </li> <li> <code>convergence_side</code>               (<code>str</code>, default:                   <code>'right'</code> )           \u2013            <p>find the first x on the left or right side. Defaults to \"right\".</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>best_x, best_y (float): found x and y value that y converge with a tolerance &lt; tol.</p> </li> </ul> Notes <p>Value <code>df['dy'] = df['y'].diff()</code> depends on grid size. Should use <code>df['dy'] = df['y'].diff()/ df['x'].diff()</code>.</p> References <ol> <li>https://docs.scipy.org/doc/scipy/tutorial/interpolate.html</li> </ol>"},{"location":"api/#thmd.util.fit.fit_root.extrapolate","title":"<code>extrapolate(x, y, left_side: list = None, right_side: list = None, grid_size=0.1) -&gt; tuple[list, list]</code>","text":""},{"location":"api/#thmd.util.fit.fit_root.___uncertainty_weighted_fit_linear","title":"<code>___uncertainty_weighted_fit_linear(x, y, sigma_y=None)</code>","text":"<p>Compute uncertainties in coefficients A and B of y = A + B*x from the weighted least square fitting.</p> <p>Apply when the measured data y_i has different uncertainties sigma_y_i, the weights w_i = 1/(sigma_y_i^2).</p> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients A and B</p> </li> <li> <code>uncertainties</code> (              <code>tuple</code> )          \u2013            <p>1D array (sigma_intercept, sigma_slope) of standard deviation of A and B</p> </li> </ul> References <ol> <li>Taylor_1997_An introduction to error analysis: the study of uncertainties in physical measurements, page 198.</li> <li>https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfit.html</li> </ol>"},{"location":"api/#thmd.util.fit.user_lmfit","title":"<code>user_lmfit</code>","text":"<p>Classes:</p> <ul> <li> <code>UserLmfit</code>           \u2013            <p>The class contains set of objective function of fitting use by LMFIT package</p> </li> </ul>"},{"location":"api/#thmd.util.fit.user_lmfit.UserLmfit","title":"<code>UserLmfit</code>","text":"<p>The class contains set of objective function of fitting use by LMFIT package NOTEs: - defined function followed the convection of LMFIT: the first argument of the function is taken as the independent variable, held in independent_vars, and the rest of the functions positional arguments (and, in certain cases, keyword arguments \u2013 see below) are used for Parameter names. https://lmfit.github.io/lmfit-py/model.html - This Class defines curve-forms that are not vailable in LMFIT's built-in models</p> <ul> <li> <p>Attributes:         swType       : (default='RATIONAL') Type of witching function,         r0, d0       : The r_0 parameter of the switching function</p> </li> <li> <p>Methods:         fFunc    : compute &amp; return value and derivation of sw function         fDmax    : estimate value of Dmax</p> </li> </ul> <p>Ex: func = thmd.CurveLib.Linear(x)</p> <p>Methods:</p> <ul> <li> <code>Linear</code>             \u2013              <p>this func is available in LMFIT, just play as an example here</p> </li> <li> <code>inverseTemperature</code>             \u2013              </li> <li> <code>ExpDecay</code>             \u2013              </li> <li> <code>sizeEffect</code>             \u2013              <p>system size-dependence on term N^(\u2154</p> </li> <li> <code>unNormalGaussian</code>             \u2013              <p>The unNormalize Gaussian function</p> </li> <li> <code>NormalGaussian</code>             \u2013              <p>The Normalize Gaussian function</p> </li> <li> <code>sum_2unNormalGaussian</code>             \u2013              <p>The sum of 2 Gaussian function</p> </li> <li> <code>sum_3unNormalGaussian</code>             \u2013              <p>The sum of 3 Gaussian function</p> </li> <li> <code>sum_4unNormalGaussian</code>             \u2013              <p>The sum of 4 Gaussian function</p> </li> <li> <code>sum_5unNormalGaussian</code>             \u2013              <p>The sum of 5 Gaussian function</p> </li> <li> <code>sum_2NormalGaussian</code>             \u2013              <p>The sum of 2 Gaussian function</p> </li> <li> <code>sum_3NormalGaussian</code>             \u2013              <p>The sum of 3 Gaussian function</p> </li> <li> <code>sum_4NormalGaussian</code>             \u2013              <p>The sum of 4 Gaussian function</p> </li> <li> <code>sum_5NormalGaussian</code>             \u2013              <p>The sum of 5 Gaussian function</p> </li> <li> <code>DoseResp</code>             \u2013              <p>Dose-response curve with variable Hill slope given by parameter 'p'.</p> </li> <li> <code>BiDoseResp</code>             \u2013              <p>Biphasic Dose Response Function,</p> </li> <li> <code>Carreau</code>             \u2013              <p>Carreau-Yasuda model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates</p> </li> <li> <code>Cross</code>             \u2013              <p>Cross model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates</p> </li> <li> <code>GammaCFD</code>             \u2013              <p>Gamma cumulative distribution function</p> </li> </ul> <code></code> <code>Linear(x, a0, a1)</code> \u00b6 <p>this func is available in LMFIT, just play as an example here</p> <code></code> <code>inverseTemperature(x, a, b)</code> \u00b6 <code></code> <code>ExpDecay(x, A, lambd)</code> \u00b6 <code></code> <code>sizeEffect(x, a, b)</code> \u00b6 <p>system size-dependence on term N^(\u2154</p> <code></code> <code>unNormalGaussian(x, amp, cen, sig)</code> \u00b6 <p>The unNormalize Gaussian function</p> <code></code> <code>NormalGaussian(x, amp, cen, sig)</code> \u00b6 <p>The Normalize Gaussian function</p> <code></code> <code>sum_2unNormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code> \u00b6 <p>The sum of 2 Gaussian function</p> <code></code> <code>sum_3unNormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code> \u00b6 <p>The sum of 3 Gaussian function</p> <code></code> <code>sum_4unNormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code> \u00b6 <p>The sum of 4 Gaussian function</p> <code></code> <code>sum_5unNormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code> \u00b6 <p>The sum of 5 Gaussian function</p> <code></code> <code>sum_2NormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code> \u00b6 <p>The sum of 2 Gaussian function</p> <code></code> <code>sum_3NormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code> \u00b6 <p>The sum of 3 Gaussian function</p> <code></code> <code>sum_4NormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code> \u00b6 <p>The sum of 4 Gaussian function</p> <code></code> <code>sum_5NormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code> \u00b6 <p>The sum of 5 Gaussian function</p> <code></code> <code>DoseResp(x, A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</code> \u00b6 <p>Dose-response curve with variable Hill slope given by parameter 'p'. Origin's Category: Pharmacology * Params:                 Names=A1,A2,LOGx0,p                 Meanings=bottom asymptote,top asymptote, center, hill slope Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</p> <code></code> <code>BiDoseResp(x, A1=-3.3, A2=-2.9, LOGx01=175000, LOGx02=480000, h1=0.1, h2=0.2, p=0.5)</code> \u00b6 <p>Biphasic Dose Response Function, Origin's Category: Pharmacology * Params:                 Names=A1, A2, LOGx01, LOGx02, h1, h2, p                 Meanings=Bottom, Top, 1<sup>st</sup> EC50, 2<sup>nd</sup> EC50, slope1, slope2, proportion Initiate params: pars = mod.make_params(A1=0, A2=100, LOGx01=-8, LOGx02=-4, h1=0.8, h2=1.2, p=0.5)</p> <code></code> <code>Carreau(x, A1=60, A2=3, t=3.0, a=2.2, n=0.3)</code> \u00b6 <p>Carreau-Yasuda model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,a,n    &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,transition control factor,power index Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, t=2.0, a=2.2, n=0.2)</p> <code></code> <code>Cross(x, A1=0.1, A2=3, t=1000, m=0.9)</code> \u00b6 <p>Cross model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,m      &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,power index Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p> <code></code> <code>GammaCFD(x, y0, A1, a, b)</code> \u00b6 <p>Gamma cumulative distribution function Origin's Category: Statistics * Params:                 Names = y0,A1,a,b          (A1,a,b &gt;0)                 Meanings = Offset,Amplitude,Shape,Scale Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p>"},{"location":"api/#thmd.util.grid_box","title":"<code>grid_box</code>","text":"<p>Functions:</p> <ul> <li> <code>grid_box_2d</code>             \u2013              <p>devide box into 2d grid, return list of atom-IDs in each slab and list of slab-centers</p> </li> <li> <code>grid_box_1d</code>             \u2013              <p>devide box into 1d slabs, return list of atom-IDs in each slab and list of slab-centers</p> </li> </ul>"},{"location":"api/#thmd.util.grid_box.grid_box_2d","title":"<code>grid_box_2d(points, box, plane='XY', mode='bin_number', grid_size=[20, 20])</code>","text":"<p>devide box into 2d grid, return list of atom-IDs in each slab and list of slab-centers Args:         P          : Nx3 array contain positions of atoms         box        : simulation box         mode       : \"bin_number\" or \"bin_size\"         mode_value : corresponding 'Number-of-bins' or 'size-of-bin'         plane      : on which plane the box will be gridded Returns:         atomIDinCell : 1xBinNumber array of 1xM-vector, contain indices of atoms of each Cell         cellCenter   : 1xBinNumber array of scalar, is center of each slab</p>"},{"location":"api/#thmd.util.grid_box.grid_box_1d","title":"<code>grid_box_1d(points, box, axis='Z', mode='bin_number', grid_size=20)</code>","text":"<p>devide box into 1d slabs, return list of atom-IDs in each slab and list of slab-centers Args:         P          : Nx3 array contain positions of atoms         box        : simulation box         mode       : \"bin_number\" or \"bin_size\"         mode_value : corresponding 'Number-of-bins' or 'size-of-bin'         axis       : on which axis the box will be slabbed Returns:         atomIDinCell : 1xBinNumber array of 1xM arrays, contain indices of atoms of each Slab, array of arrays         geoCenter    : 1xBinNumber array of scalar, is geometry center of each slab         massCenter   : 1xBinNumber array of scalar, is mass center of each slab</p>"},{"location":"api/#thmd.util.many_stuff","title":"<code>many_stuff</code>","text":"<p>Functions:</p> <ul> <li> <code>memory_usage</code>             \u2013              <p>return the memory usage in MB</p> </li> <li> <code>natSorted</code>             \u2013              <p>https://stackoverflow.com/questions/4836710/is-there-a-built-in-function-for-string-natural-sort</p> </li> <li> <code>split_list</code>             \u2013              <p>Should use <code>np.array_split</code> instead</p> </li> <li> <code>find_nearest_value</code>             \u2013              </li> </ul>"},{"location":"api/#thmd.util.many_stuff.memory_usage","title":"<code>memory_usage()</code>","text":"<p>return the memory usage in MB</p>"},{"location":"api/#thmd.util.many_stuff.natSorted","title":"<code>natSorted(mylist)</code>","text":"<p>https://stackoverflow.com/questions/4836710/is-there-a-built-in-function-for-string-natural-sort</p>"},{"location":"api/#thmd.util.many_stuff.split_list","title":"<code>split_list(a, n)</code>","text":"<p>Should use <code>np.array_split</code> instead Args:             a (list): list to be splitted             n (int): number of chunks     Returns:             generator: a generator of splitted list</p>"},{"location":"api/#thmd.util.many_stuff.find_nearest_value","title":"<code>find_nearest_value(array, value)</code>","text":""},{"location":"api/#thmd.util.row_operation","title":"<code>row_operation</code>","text":"<p>Functions:</p> <ul> <li> <code>unique_row</code>             \u2013              <p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X</p> </li> <li> <code>match_row</code>             \u2013              <p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X</p> </li> <li> <code>asvoid</code>             \u2013              <p>Base on: https://stackoverflow.com/questions/38674027/find-the-row-indexes-of-several-values-in-a-numpy-array</p> </li> </ul>"},{"location":"api/#thmd.util.row_operation.unique_row","title":"<code>unique_row(X, tol_decimal=2)</code>","text":"<p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X Args:             X, find_rows    : NxN numpy arrays             tol_decimal : number of digits for round off input data</p>"},{"location":"api/#thmd.util.row_operation.match_row","title":"<code>match_row(X, find_rows, tol_decimal=2)</code>","text":"<p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X Args:             X, find_rows    : NxN numpy arrays             tol_decimal : number of digits for round off input data</p>"},{"location":"api/#thmd.util.row_operation.asvoid","title":"<code>asvoid(arr)</code>","text":"<p>Base on: https://stackoverflow.com/questions/38674027/find-the-row-indexes-of-several-values-in-a-numpy-array</p>"},{"location":"api/#thmd.util.string_index","title":"<code>string_index</code>","text":"<p>Functions:</p> <ul> <li> <code>string_index</code>             \u2013              <p>groupSURF index by consecutive-series</p> </li> </ul>"},{"location":"api/#thmd.util.string_index.string_index","title":"<code>string_index(idx_list)</code>","text":"<p>groupSURF index by consecutive-series</p>"},{"location":"api/#thmd.util.unit","title":"<code>unit</code>","text":"<p>This module to convert unit of some physical properties pressure</p> <p>Consider to use this module: https://unyt.readthedocs.io/en/stable/usage.html</p> <p>Functions:</p> <ul> <li> <code>pressure</code>             \u2013              <p>convert unit of pressure</p> </li> <li> <code>force</code>             \u2013              <p>convert unit of force</p> </li> <li> <code>energy</code>             \u2013              <p>convert unit of energy</p> </li> <li> <code>constant</code>             \u2013              <p>list of constants</p> </li> </ul>"},{"location":"api/#thmd.util.unit.pressure","title":"<code>pressure(key_word='all_key')</code>","text":"<p>convert unit of pressure Pa: Pascal atm: standard atmosphere at: technical atmosphere</p> <p>kgf/cm2 = kg/cm2 1 Pa = 1 N/m^2 1 kgf/cm2 = 1</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>               (<code>str</code>, default:                   <code>'all_key'</code> )           \u2013            <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (              <code>float</code> )          \u2013            <p>multiply factor of conversion</p> </li> </ul> <p>Examples:</p> <pre><code>key_word='Pa_atm': convert from Pa (Pascal) to atm (Standard atmosphere)\n</code></pre>"},{"location":"api/#thmd.util.unit.force","title":"<code>force(key_word='all_key')</code>","text":"<p>convert unit of force N: Newton kgf = m.g: kilogram-force (weight: one kilogram of mass in a 9.80665 m/s2 gravitational field) lbf: pound-force p: pond</p> <p>1 N = 1 J/m    (Work = Force.distance) 1 kcal = 4184 J = 4184 N.m = 4184.10^10 N.Angstrom 69.4786 pN = 1 kcal/mol Angstrom.     https://tinyurl.com/yb2gnlhc</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>               (<code>str</code>, default:                   <code>'all_key'</code> )           \u2013            <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (              <code>float</code> )          \u2013            <p>multiply factor of conversion</p> </li> </ul>"},{"location":"api/#thmd.util.unit.energy","title":"<code>energy(key_word='all_key')</code>","text":"<p>convert unit of energy J: Joule W.h: watt-hour cal: calorie (th) hp.h: horsepower hour eV: electron-volt</p> <p>1 J = 1 N.m    (Work = Force.distance) 1J = 1 W.s</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>               (<code>str</code>, default:                   <code>'all_key'</code> )           \u2013            <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (              <code>float</code> )          \u2013            <p>multiply factor of conversion</p> </li> </ul> <p>Notes         <pre><code>## convert eV to kcal/mol\neV2J = 1/unit_convert.energy('J_eV')\nJ2Jmol = unit_convert.constant('1/mol')\nkj2kcal = 1/unit_convert.energy('kcal/mol_kJ/mol')\neV2kcalmol = eV2J * J2Jmol * 1e-3 *kj2kcal\n</code></pre></p>"},{"location":"api/#thmd.util.unit.constant","title":"<code>constant(key_word='all_key')</code>","text":"<p>list of constants Na = 6.02214076e23  (=1/mol): Avogadro number</p> <p>Parameters:</p> <ul> <li> <code>Ex</code>           \u2013            <p>key_word='Pa_atm': convert from Pa (Pascal) to atm (Standard atmosphere)</p> </li> </ul> <p>Returns:         factor: float, multiply factor of conversion</p>"},{"location":"calc_colvar/","title":"Calc colvar","text":""},{"location":"calc_colvar/#thmd.calc.colvar","title":"<code>thmd.calc.colvar</code>","text":"<p>This module contains classes and functions to compute Order parameters, Collective variables,...</p> <p>Modules:</p> <ul> <li> <code>cv_CoordNum</code>           \u2013            </li> <li> <code>cv_PairANGLE</code>           \u2013            </li> <li> <code>cv_Steinhardt</code>           \u2013            </li> <li> <code>cv_fccCUBIC</code>           \u2013            </li> <li> <code>cv_localCRYSTALLINITY</code>           \u2013            </li> <li> <code>cv_slip_atom</code>           \u2013            </li> <li> <code>find_neighbor</code>           \u2013            </li> <li> <code>sph_harmonics</code>           \u2013            </li> <li> <code>switch_function</code>           \u2013            </li> <li> <code>voronoi</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>RATIONAL</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>HEAVISIDE</code>           \u2013            </li> <li> <code>CUBIC</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>SMAP</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.RATIONAL","title":"<code>RATIONAL(r0, d0=0.0, n=6, m=12, dmax_tol=0.001)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>r0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>d0</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The d_0 parameter of the switching function</p> </li> <li> <code>n</code>               (<code> (float</code>, default:                   <code>6</code> )           \u2013            <p>The n parameter of the switching function</p> </li> <li> <code>m</code>               (<code> (float</code>, default:                   <code>12</code> )           \u2013            <p>The m parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> Notes <p>Dmin != D0 D0, R0    : are the parameter of switching function Dmin, Dmax : are the bounds at which the switching take affect</p> <p>Examples:</p> <pre><code>sw = thmd.SwitchFunc.RATIONAL(r0=6.3, d0=0.0, n=10)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>dmax</code>             \u2013              </li> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>r0</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>n</code>           \u2013            </li> <li> <code>m</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.RATIONAL.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.RATIONAL.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.RATIONAL.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.RATIONAL.m","title":"<code>m = m</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.RATIONAL.dmax","title":"<code>dmax(dmax_tol)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.RATIONAL.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function Input x can be a scalar or a 1d numpy ndarray</p>"},{"location":"calc_colvar/#thmd.calc.colvar.HEAVISIDE","title":"<code>HEAVISIDE(r0)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute value of sw function</p> </li> <li> <code>der</code>             \u2013              <p>compute derivative of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dmax</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.HEAVISIDE.dmax","title":"<code>dmax = r0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.HEAVISIDE.eval","title":"<code>eval(x: Union[float, list, np.ndarray]) -&gt; np.ndarray</code>","text":"<p>compute value of sw function</p>"},{"location":"calc_colvar/#thmd.calc.colvar.HEAVISIDE.der","title":"<code>der(x: float | list | np.ndarray) -&gt; np.ndarray</code>","text":"<p>compute derivative of sw function</p>"},{"location":"calc_colvar/#thmd.calc.colvar.CUBIC","title":"<code>CUBIC(d0, dmax)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>d0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>dmax</code>               (<code>float</code>)           \u2013            <p>The d_0 parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> <p>Examples:</p> <pre><code>        sw = thmd.SwitchFunc.CUBIC(d0=0.0, dmax=2)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>d0</code>           \u2013            </li> <li> <code>dmax</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.CUBIC.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.CUBIC.dmax","title":"<code>dmax = dmax</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.CUBIC.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float or ndarray</code>)           \u2013            <p>input values</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>f</code> (              <code>float or ndarray</code> )          \u2013            <p>value of the switching function</p> </li> <li> <code>df</code> (              <code>(float or ndarray, optional)</code> )          \u2013            <p>value of the derivative of the switching function. Just return if <code>compute_der=True</code></p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.SMAP","title":"<code>SMAP(r0, a=10, b=20, d0=0, tol=0.0001)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              </li> <li> <code>findDmax</code>             \u2013              </li> <li> <code>findDmin</code>             \u2013              </li> <li> <code>find_Dmin_Dmax</code>             \u2013              <p>find Dmin and Dmax of function based on given tolerance</p> </li> <li> <code>estimate_ab</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> <li> <code>estimate_ab_old_manual</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>a</code>           \u2013            </li> <li> <code>b</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>r0</code>           \u2013            </li> <li> <code>tol</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.a","title":"<code>a = a</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.b","title":"<code>b = b</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.tol","title":"<code>tol = tol</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.eval","title":"<code>eval(x, compute_der=False)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.findDmax","title":"<code>findDmax(tol=None, upper_bound=100, gridSize=0.0001)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.findDmin","title":"<code>findDmin(tol=None, lower_bound=None, gridSize=0.0001)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.find_Dmin_Dmax","title":"<code>find_Dmin_Dmax(tol=None, gridSize=0.0001, upper_bound=50)</code>","text":"<p>find Dmin and Dmax of function based on given tolerance</p>"},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.estimate_ab","title":"<code>estimate_ab(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version employs <code>scipy.optimize.minimize</code></p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>)           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.SMAP.estimate_ab_old_manual","title":"<code>estimate_ab_old_manual(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001, search_step=0.1)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version use manual search.</p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_CoordNum","title":"<code>cv_CoordNum</code>","text":"<p>Functions:</p> <ul> <li> <code>coord_number</code>             \u2013              <p>The Coordination is the size of input \"Points\", this function just weight it with a switching function</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_CoordNum.coord_number","title":"<code>coord_number(Points, **kwargs)</code>","text":"<p>The Coordination is the size of input \"Points\", this function just weight it with a switching function * Compulsory Inputs: ** optional Inputs:         switchFunc=[1,1...,1] : Nx1 array, contain values of switching function s(Rj) (Rj is positions of atom j) Returns:         coord  : scalar, Order Parameter     Examples: S = thmd.OrderPara.Coordination([1,0,0; 0,1,0], SW=sw) By Cao Thang, Aug 2020</p>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_PairANGLE","title":"<code>cv_PairANGLE</code>","text":"<p>Functions:</p> <ul> <li> <code>PairANGLE</code>             \u2013              <p>Order Parameter based on pair functions of Angles in the first shell:</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_PairANGLE.PairANGLE","title":"<code>PairANGLE(Points, CENTER, SIGMA, **kwargs)</code>","text":"<p>Order Parameter based on pair functions of Angles in the first shell:</p> Agrs <p>Points   : Nx3 Matrix, contain bonding vectors between neighboring  atoms j and ref atom i CENTER=[pi/3, pi/2, 2*pi/3, pi] : list, centers of Gaussians SIGMA =[0.03,0.04,0.04,0.03]   : list, sigmas of Gaussians switchFunc=[1,1...,1] : Nx1 array, contain values of switching function s(Rj) (Rj is positions of atom j)</p> <p>Returns:</p> <ul> <li> <code>gamma</code> (              <code>float</code> )          \u2013            <p>Order Parameter</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.OrderPara.FCCcubic([1,0,0; 0,1,0], SW=sw)\n</code></pre> Notes <p>Require to best chose Rcut for Switching function</p> Refs <ol> <li>Gobbob et al., \"Nucleation of Molecular Crystals Driven by Relative Information Entropy\"</li> </ol>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_Steinhardt","title":"<code>cv_Steinhardt</code>","text":"<p>Functions:</p> <ul> <li> <code>Ql_Steinhardt</code>             \u2013              <p>compute origincal Stainhardt of l-th order</p> </li> <li> <code>Local_Ql_Steinhardt</code>             \u2013              <p>compute Local Stainhardt of l-th order (modified Steinhardt as: 10.1021/acs.jctc.6b01073)</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_Steinhardt.Ql_Steinhardt","title":"<code>Ql_Steinhardt(ql_i)</code>","text":"<p>compute origincal Stainhardt of l-th order Args:         ql_i   : a vector of (2l+1) complex components, qlm(i) vector of atom i Returns:         Ql      : scalar value of l-th order Stainhardt parameter</p>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_Steinhardt.Local_Ql_Steinhardt","title":"<code>Local_Ql_Steinhardt(ql_i, qlm_j, SW)</code>","text":"<p>compute Local Stainhardt of l-th order (modified Steinhardt as: 10.1021/acs.jctc.6b01073) Args:         ql_i   : 1x(2l+1) array, vector of (2l+1) complex components, qlm(i) vector of atom i         qlm_j   : Nx(2l+1) array, rows are vectors of (2l+1) complex components, qlm(j) of all neighbors j of atom i Returns:         Local_Ql_i      : scalar value of l-th order Stainhardt parameter of atom i * PreRequire: compute ql_i complex vector for all atoms before this function can be used</p>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_fccCUBIC","title":"<code>cv_fccCUBIC</code>","text":"<p>Functions:</p> <ul> <li> <code>fccCUBIC</code>             \u2013              <p>Function to Calculate FCC CUBIC parameters.</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_fccCUBIC.fccCUBIC","title":"<code>fccCUBIC(points, alpha=27, zDirect='001', switch_function=None)</code>","text":"<p>Function to Calculate FCC CUBIC parameters.</p> <p>By thangckt, Mar 2020</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Nx3 np.array</code>)           \u2013            <p>array contains bonding vectors between neighboring  atoms j and ref atom i</p> </li> <li> <code>alpha</code>               (<code>int</code>, default:                   <code>27</code> )           \u2013            <p>coefficient of harmonic function. Default to 27.</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>direction of Z-direction, available '001'  '110'  '111'. Default to '001'.</p> </li> <li> <code>switch_function</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list contain values of switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>param</code> (              <code>float</code> )          \u2013            <p>Order Parameter.</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.colvar.fccCUBIC([1,0,0; 0,1,0], alpha=3, zDirect='001', switch_function=sw)\n</code></pre> Notes <p>Must choose suitable Rcut for Switching function.</p>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_localCRYSTALLINITY","title":"<code>cv_localCRYSTALLINITY</code>","text":"<p>Functions:</p> <ul> <li> <code>localCRYSTALLINITY</code>             \u2013              <p>Function to Calculate Order Parameter with multi_vectors K.</p> </li> <li> <code>compute_Gvectors_FCC</code>             \u2013              <p>Function to convert reciprocal vectors G to be used in <code>localCRYSTALLINITY</code>.</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_localCRYSTALLINITY.localCRYSTALLINITY","title":"<code>localCRYSTALLINITY(points: np.array, g_vectors: list[list], switch_function=None)</code>","text":"<p>Function to Calculate Order Parameter with multi_vectors K.</p> <p>By thangckt, Apr 2019</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Nx3 np.array</code>)           \u2013            <p>array contains bonding vectors between neighboring  atoms j and ref atom i     g_vectors (tuple): 2d-tuple contains \"directions_vectors\" for g_vectors  (ex: ((4*pi/a)(1,0,0), (4*pi/a)(0,1,0)). The actual g_vectors will be computed in function. Default to ((1,0,0)).</p> </li> <li> <code>switch_function</code>               (<code>object</code>, default:                   <code>None</code> )           \u2013            <p>switching function s(Rj) (Rj is positions of atom j). Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>aveLC</code> (              <code>float</code> )          \u2013            <p>is average Order Parameter , tage over on input g_factors, 0 &lt;= LC &lt;=1</p> </li> <li> <code>LC</code> (              <code>list</code> )          \u2013            <p>list of real numbers, are Order Parameters corresponding to each g-vector 0 &lt;= LC &lt;=1</p> </li> <li> <code>S</code> (              <code>list</code> )          \u2013            <p>(not computed) Kx1 vetor of complex numbers, are Static Structure Factors corresponding to each g-vector</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.colvar.localCRYSTALLINITY([1,0,0; 0,1,0], switch_function=sw, zDirect='001')\n</code></pre> Notes <p>If multi g-vectors is input, then OrderPara is take by averaging over all g-vectors.</p>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_localCRYSTALLINITY.compute_Gvectors_FCC","title":"<code>compute_Gvectors_FCC(g_directions: list[list] = [[1, 0, 0]], lattice_constant: float = 1.0, zDirect: str = '001') -&gt; list[list]</code>","text":"<p>Function to convert reciprocal vectors G to be used in <code>localCRYSTALLINITY</code>.</p> <p>Parameters:</p> <ul> <li> <code>g_directions</code>               (<code>list</code>, default:                   <code>[[1, 0, 0]]</code> )           \u2013            <p>2d-list contains \"directions_vectors\" for g_vectors  (ex: ((1,0,0), (0,1,0)). The actual g_vectors will be computed. Default to ((1,0,0)).</p> </li> <li> <code>lattice_constant</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>lattice constant of crystal. Default to 1.</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>direction of Z-direction, available '001'  '110'  '111'. Default to '001'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>g_vectors</code> (              <code>list</code> )          \u2013            <p>2d-list contains g_vectors</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_slip_atom","title":"<code>cv_slip_atom</code>","text":"<p>Functions:</p> <ul> <li> <code>slip_atom</code>             \u2013              <p>Function to Calculate FCC CUBIC parameters.</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.cv_slip_atom.slip_atom","title":"<code>slip_atom(points, d_ref, d_diff)</code>","text":"<p>Function to Calculate FCC CUBIC parameters.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>Nx3 np.array</code>)           \u2013            <p>array contains bonding vectors between neighboring  atoms j and ref atom i</p> </li> <li> <code>d_ref</code>               (<code>float</code>)           \u2013            <p>reference distance.</p> </li> <li> <code>d_diff</code>               (<code>float</code>)           \u2013            <p>difference distance to referred as dislocation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>param</code> (              <code>float</code> )          \u2013            <p>Order Parameter.</p> </li> </ul> <p>Examples:</p> <pre><code>S = thmd.colvar.fccCUBIC([1,0,0; 0,1,0], alpha=3, zDirect='001', switch_function=sw)\n</code></pre> Notes <p>Must choose suitable Rcut for Switching function.</p>"},{"location":"calc_colvar/#thmd.calc.colvar.find_neighbor","title":"<code>find_neighbor</code>","text":"<p>Functions:</p> <ul> <li> <code>find_neighbor_gen</code>             \u2013              <p>find Nearest_Neighbors, return generator of Nearest_IDs, \"Nearest relative-Position vetors from atom i\"</p> </li> <li> <code>find_neighbor_list</code>             \u2013              <p>find Nearest_Neighbors, return list of Nearest_IDs, \"Nearest relative-Position vetors from atom i\"</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.find_neighbor.find_neighbor_gen","title":"<code>find_neighbor_gen(points: Union[np.array, list[list]], box: Union[np.array, list[list]], bound_cond: list = [1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False) -&gt; Generator[list, list[list], None]</code>","text":"<p>find Nearest_Neighbors, return generator of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>thangckt, Sep 2019. Update: Aug 2022 to use generator</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>array</code>)           \u2013            <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>               (<code>array</code>)           \u2013            <p>simulation box</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code> (              <code>generator</code> )          \u2013            <p>this output a GEN contains (Idx_neigh, Rij_vectors)</p> </li> </ul> <p>Examples:</p> <pre><code>GEN = colvar.find_neighbors_gen(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> old version <pre><code>access items in generator with:\n        for Near_ID, Rij_vector in GEN:\n                print (Near_ID, Rij_vector)\n\n- Idx_neigh    : Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms\n- Rij_vectors : Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)\n</code></pre>"},{"location":"calc_colvar/#thmd.calc.colvar.find_neighbor.find_neighbor_list","title":"<code>find_neighbor_list(points, box, bound_cond=[1, 1, 1], cutoff_neighbor=None, k_neighbor=None, k_cutoff=20, keep_ref=False)</code>","text":"<p>find Nearest_Neighbors, return list of Nearest_IDs, \"Nearest relative-Position vetors from atom i\" Ver 2: spatial.cKDTree</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>array</code>)           \u2013            <p>Nx3 array contain positions of atoms</p> </li> <li> <code>box</code>               (<code>array</code>)           \u2013            <p>simulation box</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>boundary condition</p> </li> <li> <code>cutoff_neighbor</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>find neighbors within a Cutoff.</p> </li> <li> <code>k_neighbor</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>find k nearest neighbors</p> </li> <li> <code>keep_ref</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>include referal-atom in result</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Idx_neigh</code> (              <code>array</code> )          \u2013            <p>Nx1 list of Mx1-vectors, contain Image_IDs(id of the original atoms before make periodicity) of Nearest atoms</p> </li> <li> <code>Rij_vectors</code> (              <code>array</code> )          \u2013            <p>Nx1 list of Mx3-Matrices, contain Nearest Rij relative-Position vetors from Ref.atom i (Nearest Positions)</p> </li> </ul> <p>Examples:</p> <pre><code>Idx_neigh, Rij_vectors = colvar.find_neighbors_list(P, box, bound_cond = [1, 1, 1], cutoff_neighbor=9, keep_ref=False)\n</code></pre> Notes <p>don't compute Rij_Bond to save memory Rij_Bonds (np.array): Nx1 list of scalars, contain Rij_bonds from Ref.atom to Nearest_atoms (Nearest-bonds)</p>"},{"location":"calc_colvar/#thmd.calc.colvar.sph_harmonics","title":"<code>sph_harmonics</code>","text":"<p>Functions:</p> <ul> <li> <code>yl_i</code>             \u2013              <p>Compute vector of Spherical Harmonics for a set of point (ylm vector have (2l+1) components)</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.sph_harmonics.yl_i","title":"<code>yl_i(l, Rij, SW=None, kind='real', normalization='4pi', deg=False)</code>","text":"<p>Compute vector of Spherical Harmonics for a set of point (ylm vector have (2l+1) components)</p> <p>Parameters:</p> <ul> <li> <code>l</code>               (<code>int)         </code>)           \u2013            <p>degree of Spherical Harmonic</p> </li> <li> <code>Rij</code>               (<code>array - like</code>)           \u2013            <p>Nx3 array contain Rij of nearest neighbors compute from atom i</p> </li> <li> <code>SW</code>               (<code> (array-like</code>, default:                   <code>None</code> )           \u2013            <p>Nx1 values of switching function. Default to 'None'</p> </li> <li> <code>kind</code>               (<code> (str</code>, default:                   <code>'real'</code> )           \u2013            <p>kind of return result. Possible <code>complex</code>/<code>real</code>. Default to <code>complex</code></p> </li> <li> <code>normalization</code>               (<code>str</code>, default:                   <code>'4pi'</code> )           \u2013            <p>'4pi', 'ortho', 'schmidt', or 'unnorm' for geodesy 4pi normalized, orthonormalized, Schmidt semi-normalized, or unnormalized spherical harmonic functions, respectively. Default to '4pi'</p> </li> <li> <code>deg</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, theta and phi are expressed in degrees. Default to <code>False</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>yl</code> (              <code>array - like</code> )          \u2013            <p>vector of (2l+1) components</p> </li> </ul> Notes <p>This functions used the function <code>spharm_lm()</code> from pyshtools</p> Refs <ol> <li>Visualizing the real forms of the spherical harmonics</li> <li>In <code>scipy.special.sph_harm</code> function the azimuthal coordinate, theta, comes before the polar coordinate, phi; anh may return complex number only</li> </ol>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function","title":"<code>switch_function</code>","text":"<p>Classes:</p> <ul> <li> <code>RATIONAL</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>HEAVISIDE</code>           \u2013            </li> <li> <code>CUBIC</code>           \u2013            <p>Create an Object of SWITCHING FUNCTION</p> </li> <li> <code>SMAP</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.RATIONAL","title":"<code>RATIONAL(r0, d0=0.0, n=6, m=12, dmax_tol=0.001)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>r0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>d0</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The d_0 parameter of the switching function</p> </li> <li> <code>n</code>               (<code> (float</code>, default:                   <code>6</code> )           \u2013            <p>The n parameter of the switching function</p> </li> <li> <code>m</code>               (<code> (float</code>, default:                   <code>12</code> )           \u2013            <p>The m parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> Notes <p>Dmin != D0 D0, R0    : are the parameter of switching function Dmin, Dmax : are the bounds at which the switching take affect</p> <p>Examples:</p> <pre><code>sw = thmd.SwitchFunc.RATIONAL(r0=6.3, d0=0.0, n=10)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> <li> <code>dmax</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>r0</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>n</code>           \u2013            </li> <li> <code>m</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.RATIONAL.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.RATIONAL.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.RATIONAL.n","title":"<code>n = n</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.RATIONAL.m","title":"<code>m = m</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.RATIONAL.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function Input x can be a scalar or a 1d numpy ndarray</p>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.RATIONAL.dmax","title":"<code>dmax(dmax_tol)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.HEAVISIDE","title":"<code>HEAVISIDE(r0)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute value of sw function</p> </li> <li> <code>der</code>             \u2013              <p>compute derivative of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dmax</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.HEAVISIDE.dmax","title":"<code>dmax = r0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.HEAVISIDE.eval","title":"<code>eval(x: Union[float, list, np.ndarray]) -&gt; np.ndarray</code>","text":"<p>compute value of sw function</p>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.HEAVISIDE.der","title":"<code>der(x: float | list | np.ndarray) -&gt; np.ndarray</code>","text":"<p>compute derivative of sw function</p>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.CUBIC","title":"<code>CUBIC(d0, dmax)</code>","text":"<p>Create an Object of SWITCHING FUNCTION</p> <p>Parameters:</p> <ul> <li> <code>d0</code>               (<code>float</code>)           \u2013            <p>The r_0 parameter of the switching function</p> </li> <li> <code>dmax</code>               (<code>float</code>)           \u2013            <p>The d_0 parameter of the switching function</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>object</code> )          \u2013            <p>Object of the switching function</p> </li> </ul> <p>Examples:</p> <pre><code>        sw = thmd.SwitchFunc.CUBIC(d0=0.0, dmax=2)\n</code></pre> <p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              <p>compute &amp; return value and derivation of sw function</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>d0</code>           \u2013            </li> <li> <code>dmax</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.CUBIC.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.CUBIC.dmax","title":"<code>dmax = dmax</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.CUBIC.eval","title":"<code>eval(x, compute_der=False)</code>","text":"<p>compute &amp; return value and derivation of sw function</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>float or ndarray</code>)           \u2013            <p>input values</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>f</code> (              <code>float or ndarray</code> )          \u2013            <p>value of the switching function</p> </li> <li> <code>df</code> (              <code>(float or ndarray, optional)</code> )          \u2013            <p>value of the derivative of the switching function. Just return if <code>compute_der=True</code></p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP","title":"<code>SMAP(r0, a=10, b=20, d0=0, tol=0.0001)</code>","text":"<p>create some intiatial attributes...</p> <p>Methods:</p> <ul> <li> <code>eval</code>             \u2013              </li> <li> <code>findDmax</code>             \u2013              </li> <li> <code>findDmin</code>             \u2013              </li> <li> <code>find_Dmin_Dmax</code>             \u2013              <p>find Dmin and Dmax of function based on given tolerance</p> </li> <li> <code>estimate_ab</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> <li> <code>estimate_ab_old_manual</code>             \u2013              <p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>a</code>           \u2013            </li> <li> <code>b</code>           \u2013            </li> <li> <code>d0</code>           \u2013            </li> <li> <code>r0</code>           \u2013            </li> <li> <code>tol</code>           \u2013            </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.a","title":"<code>a = a</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.b","title":"<code>b = b</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.d0","title":"<code>d0 = d0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.r0","title":"<code>r0 = r0</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.tol","title":"<code>tol = tol</code>  <code>instance-attribute</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.eval","title":"<code>eval(x, compute_der=False)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.findDmax","title":"<code>findDmax(tol=None, upper_bound=100, gridSize=0.0001)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.findDmin","title":"<code>findDmin(tol=None, lower_bound=None, gridSize=0.0001)</code>","text":""},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.find_Dmin_Dmax","title":"<code>find_Dmin_Dmax(tol=None, gridSize=0.0001, upper_bound=50)</code>","text":"<p>find Dmin and Dmax of function based on given tolerance</p>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.estimate_ab","title":"<code>estimate_ab(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version employs <code>scipy.optimize.minimize</code></p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>)           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.switch_function.SMAP.estimate_ab_old_manual","title":"<code>estimate_ab_old_manual(target_Dmin, target_Dmax, init_a=None, init_b=None, tol=0.001, search_step=0.1)</code>","text":"<p>Estimate a and b parameters of SMAP function based on given <code>R0</code>, <code>Dmax</code> and <code>Dmin</code>. This version use manual search.</p> <p>Parameters:</p> <ul> <li> <code>target_Dmin</code>               (<code>float</code>)           \u2013            <p>target Dmin</p> </li> <li> <code>target_Dmax</code>               (<code>float</code>)           \u2013            <p>target Dmax</p> </li> <li> <code>search_step</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>incremental value of A/B for searching. Defaults to 0.2.</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>tolerance of Dmin/Dmax. Defaults to 1e-3. Should be smaller than 1e-3 (larger value will cause problem)</p> </li> <li> <code>A</code>               (<code>int</code>)           \u2013            <p>initial value of A. Defaults to 10.</p> </li> <li> <code>B</code>               (<code>int</code>)           \u2013            <p>initial value of B. Defaults to 20.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>A</code> (              <code>float</code> )          \u2013            <p>found A</p> </li> <li> <code>B</code> (              <code>float</code> )          \u2013            <p>found B</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi","title":"<code>voronoi</code>","text":"<p>Classes:</p> <ul> <li> <code>Voro3D</code>           \u2013            <p>Voro ++ library</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>layer_extractor</code>             \u2013              <p>Extract atoms of outermost layers, based on Voronoi analysis</p> </li> <li> <code>surface_detect</code>             \u2013              <p>Extract atoms on free surface, are atoms have Voronoi with max(faceArea) &gt;= max_edge**2</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi.Voro3D","title":"<code>Voro3D()</code>","text":"<p>Voro ++ library</p> <p>Methods:</p> <ul> <li> <code>fAtomicVol_Bulk_gen</code>             \u2013              <p>compute atomic-volume of each atom in Bulk models</p> </li> <li> <code>fAtomicVol_Plate_gen</code>             \u2013              <p>compute atomic-volume of each atom in Plate models</p> </li> <li> <code>fAtomicVol_Bulk</code>             \u2013              <p>compute atomic-volume of each atom in Bulk models</p> </li> <li> <code>fAtomicVol_Plate</code>             \u2013              <p>compute atomic-volume of each atom in Plate models</p> </li> </ul>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi.Voro3D.fAtomicVol_Bulk_gen","title":"<code>fAtomicVol_Bulk_gen(P, box, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Bulk models Args:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p> <p>Examples:</p> <pre><code>gen2 = thmd.fAtomicVol_Bulk_gen(P, box, coord_number=False)   # gen2 = (tomicVol_i, cell_neighbor_i)\ngen3 = thmd.fAtomicVol_Bulk_gen(P, box, coord_number=True)    # gen3 = (tomicVol_i, cell_neighbor_i, coord_i)\n</code></pre>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi.Voro3D.fAtomicVol_Plate_gen","title":"<code>fAtomicVol_Plate_gen(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value Args:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi.Voro3D.fAtomicVol_Bulk","title":"<code>fAtomicVol_Bulk(P, box, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Bulk models Args:         P        : Nx3 Matrix contain positions of atoms         box      : simulation box **Optional:         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi.Voro3D.fAtomicVol_Plate","title":"<code>fAtomicVol_Plate(P, box, bound_cond=(1, 1, 0), max_edge=3.1, surf_deep=15, virtual_surface=True, offset=False, coord_number=False)</code>","text":"<p>compute atomic-volume of each atom in Plate models update Ver2: copy layer 2<sup>nd</sup> and 3<sup>rd</sup> to cover free surface, offset distance = inter-layer distance. So, no need to input offset value Args:         P        : Nx3 Matrix contain positions of atoms         box   : simulation box</p> <p>**Optional:         bound_cond=(1, 1, 0)  : tuple of boundary condtions         max_edge=3.1 : value to to compute face-area = max_edge**2         surf_deep=15 : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory         virtual_surface=True  : apply virtual surface to cover real surface before compute Voronoi                 + offset=False: extract 2 layers near outmost layer, and use to cover surface, offset_distance is auto computed based on atomic arrangement                 + offset=true: extract 1 layer near outmost layer, and use to cover surface with offset_distance = offset value         coord_number=False : compute coordiation number Returns:         atomicVol            : 1xM array of atomic volume         coord, cell_neighbor : 1xN list, Nxlist index of neighbors of each atom in original input points</p>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi.layer_extractor","title":"<code>layer_extractor(P, bound_cond=(1, 1, 0), layer_num=1, max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms of outermost layers, based on Voronoi analysis Args:           P   : Nx3 Matrix contain positions of atoms           bound_cond=(1, 1, 0)  : tuple of boundary condtions           layer_num   : number of Layers need to extract (layer_num=0 will extract all layers)           max_edge  : value to to compute face-area = max_edge**2           surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory           method   : 'max_face_perimeter'  or   'max_face_area' Returns:         hiLayerIndex, loLayerIndex: list of lists (1xM index of atoms in each layer) By Cao Thang, Jan 2020</p>"},{"location":"calc_colvar/#thmd.calc.colvar.voronoi.surface_detect","title":"<code>surface_detect(P, bound_cond=(1, 1, 0), max_edge=3.0, surf_deep=15, method='max_face_perimeter')</code>","text":"<p>Extract atoms on free surface, are atoms have Voronoi with max(faceArea) &gt;= max_edge**2 Agrs:     P   : Nx3 Matrix contain positions of atoms     bound_cond=(1, 1, 0)  : tuple of boundary condtions     max_edge  : value to to compute face-area = max_edge**2     surf_deep : = max(peak) - min(valey), unit in Angstrom, use to reduce input data to save memory     method   : 'max_face_perimeter'  or   'max_face_area'</p> <p>Returns:</p> <ul> <li>           \u2013            <p>hiSurIndex, loSurIndex: 1xM array, index of surface atoms in the original input points</p> </li> </ul> Notes <p>experimental choose: max_edge=0.73*latticeConst only 1 pair of surface is detect each time</p>"},{"location":"calc_free_energy/","title":"Calc free energy","text":""},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd","title":"<code>thmd.calc.free_energy.logmfd</code>","text":"<p>Classes:</p> <ul> <li> <code>LogMFD_FCCUBIC</code>           \u2013            <p>Create an Object (class) of Potential, contain some pre-setup information for Energy barrier for LogMFD calculation.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>replica_logPD_integration</code>             \u2013              <p>The function to compute LogPD-based MeanForce</p> </li> <li> <code>replica_MD_average</code>             \u2013              <p>compute Replica_MD_Average from output of MD.</p> </li> <li> <code>exp_normalize</code>             \u2013              </li> <li> <code>read_df</code>             \u2013              <p>define lamda(x)</p> </li> <li> <code>replica_SteerMD</code>             \u2013              <p>compute Average Work from output of SteerMD.</p> </li> <li> <code>find_basin_logmfd_profile</code>             \u2013              <p>Args:</p> </li> </ul>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC","title":"<code>LogMFD_FCCUBIC(Element, Potential_Name, modelType='Bulk', zDirect='001')</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information for Energy barrier for LogMFD calculation. Energy barrier of System does not depend on CV (same value for energy CV: meanCV, nAtomLiquid,...) * Attributes:         Element         :         Cutoff          : force cutoff of potential         Potential_Name  :         * Energy barrier Coeff: an estimation of per-atom energy barrier for melting,                                 for a system of N atoms  \ud835\udc39=\ud835\udc53\u2217\ud835\udc41^(\u2154) , then perAtom barrier  \ud835\udc53=\ud835\udc39/\ud835\udc41^(\u2154)                                 This method return f(T)         * histo_point_coeff: the CV-value at which histogram of solid and liquid meets, coeff of function f(T) = a0 + a1T</p> <ul> <li>Methods:         Latt_Const      : compute lattice constant at a specific temperature</li> </ul> <p>Element         : 'Al', 'Cu',... Potential_Name  :         'Cu' : 'Mishin-2001'; 'Foiles-1986';...         'Al' : 'Mishin-1999'; 'Sheng-2011';... modelType       : 'Bulk' or 'Plate' zDirect         : '001' or '110' or '111' or thickness       : thickness of plate</p> <p>Methods:</p> <ul> <li> <code>meltingBarrier</code>             \u2013              <p>for a system of N atoms  \ud835\udc39=\ud835\udc53\u2217\ud835\udc41^(\u2154) , then perAtom barrier  \ud835\udc53=\ud835\udc39/\ud835\udc41^(\u2154). This method return f(T)</p> </li> <li> <code>histo_point</code>             \u2013              <p>Value of CV at intersection point of histogram as function y = a + bx</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Element</code>           \u2013            </li> <li> <code>Potential_Name</code>           \u2013            </li> <li> <code>melt_barrier_coeff</code>           \u2013            </li> <li> <code>histo_point_coeff</code>           \u2013            </li> </ul>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC.Element","title":"<code>Element = Element</code>  <code>instance-attribute</code>","text":""},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC.Potential_Name","title":"<code>Potential_Name = Potential_Name</code>  <code>instance-attribute</code>","text":""},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC.melt_barrier_coeff","title":"<code>melt_barrier_coeff = melt_barrier_coeff[melt_barrier_key]</code>  <code>instance-attribute</code>","text":""},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC.histo_point_coeff","title":"<code>histo_point_coeff = histo_point_coeff</code>  <code>instance-attribute</code>","text":""},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC.meltingBarrier","title":"<code>meltingBarrier(Temp)</code>","text":"<p>for a system of N atoms  \ud835\udc39=\ud835\udc53\u2217\ud835\udc41^(\u2154) , then perAtom barrier  \ud835\udc53=\ud835\udc39/\ud835\udc41^(\u2154). This method return f(T)</p>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.LogMFD_FCCUBIC.histo_point","title":"<code>histo_point(Temp)</code>","text":"<p>Value of CV at intersection point of histogram as function y = a + bx</p>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.replica_logPD_integration","title":"<code>replica_logPD_integration(logmfd_files: list[str], replica_files: list[str], beta: float = 1.0)</code>","text":"<p>The function to compute LogPD-based MeanForce</p> <p>Parameters:</p> <ul> <li> <code>logmfd_files</code>               (<code>list[str]</code>)           \u2013            <p>list of <code>logmfd.out</code> files</p> </li> <li> <code>replica_files</code>               (<code>list[str]</code>)           \u2013            <p>list of <code>replica.out</code> files</p> </li> <li> <code>beta</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>kB is Boltzmann constant (can be set to 1.0, regardless of kB unit). Defaults to beta = 1.0/(TEMP*kB)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>file</code> (              <code>obj</code> )          \u2013            <p>contains logPD-based MeanForce</p> </li> </ul> <p>Examples:</p> <pre><code>free_energy.replica_logPD_intergration(logmfd_files, replica_files)\n</code></pre> <p>Requisites:</p> <pre><code>1. Run logMFD simulations to produce `replica_*/logmfd.out` and `replica_*/replica.out`\n\n```\n&lt;logmfd.out&gt;\n1:iter_md, 2:Flog(t), \u2026, 6: X(t), 7: V(t), 8: Force(t)\n1   F(1), \u2026, X(1), V(1), Force(0)\n2   F(3), \u2026, X(2), V(2), Force(1)\n```\n\n```\n&lt;replica.out&gt;\niter_md, work, weight, cv\n1  work(1)   weight(1)  cv(0)\n2  work(2)   weight(2)  cv(1)\n```\n</code></pre> Notes <ol> <li>About the printed values in <code>&lt;replica.out&gt;</code> and <code>&lt;logmfd.out&gt;</code> as emails replied by Tetsuya Morishita. (check thangckt email)</li> <li>Specify type of function <code>cumulative_trapezoid:np.float64</code> to be used in <code>numba</code> <pre><code>cumulative_trapezoid:np.float64 = cumulative_trapezoid,   # this to specify `type` for function `cumulative_trapezoid`\nlogMFD:pd.DataFrame = read_data.logMFD,\nmatrix_auto:pd.DataFrame = read_data.matrix_auto):\n</code></pre></li> </ol> Refs <p>[1].https://pubs.acs.org/doi/10.1021/acs.jctc.7b00252 Free Energy Reconstruction from Logarithmic Mean-Force Dynamics Using Multiple Nonequilibrium TrajectoriesFree [2] Exp-normalize trick: https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/</p> 2023 Apr <p>CV-value in <code>replica.out</code> and <code>logmfd.out</code> are the same, so don't need to shift value in <code>replica.out</code> as below: <pre><code>Force = [elem['CV1_force'].shift(-1) for elem in logmfd ]\n</code></pre></p>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.replica_MD_average","title":"<code>replica_MD_average(MD_out_files: list[str])</code>","text":"<p>compute Replica_MD_Average from output of MD.</p> <p>Parameters:</p> <ul> <li> <code>MD_out_files</code>               (<code>list[str]</code>)           \u2013            <p>list of \"MDout_replica.txt\" files</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>logPD file: contains logPD-based MeanForce</p> </li> </ul> Requisites <ol> <li><code>Replica_*</code> files from separate MD simulations</li> </ol> <p>Thang, Jul2020 (update: Sep 2021)</p>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.exp_normalize","title":"<code>exp_normalize(x)</code>","text":""},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.read_df","title":"<code>read_df(file, engine='LAMMPS')</code>","text":"<p>define lamda(x)</p>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.replica_SteerMD","title":"<code>replica_SteerMD(SteerMD_files, beta=1.0, engine='Lammps')</code>","text":"<p>compute Average Work from output of SteerMD.</p> <p>Parameters:</p> <ul> <li> <code>SteerMD_files</code>           \u2013            <p>|<code>list</code>| of \"SteerMD.txt\" files</p> </li> <li> <code>beta</code>               (<code>= 1.0/(TEMP*kB</code>, default:                   <code>1.0</code> )           \u2013            <p>kB is Boltzmann constant (can be set to 1.0, regardless of kB unit)</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>aveSteerMD file: contains logPD-based MeanForce</p> </li> </ul> <p>Requisites: 1. Replica_* files from separate MD simulations</p> Refs <p>[1]. https://github.com/sandeshkalantre/jarzynski/blob/master/code/Simulations%20on%20Harmonic%20Oscillator%20Model.ipynb [2]. https://www.plumed.org/doc-v2.6/user-doc/html/belfast-5.html#belfast-5-work [3]. Exp-normalize trick: https://timvieira.github.io/blog/post/2014/02/11/exp-normalize-trick/</p>"},{"location":"calc_free_energy/#thmd.calc.free_energy.logmfd.find_basin_logmfd_profile","title":"<code>find_basin_logmfd_profile(ldf: list[pd.DataFrame], mfd_interval: list[float], hill_region: list = [0.2, 0.6]) -&gt; list[pd.DataFrame]</code>","text":"<p>Parameters:</p> <ul> <li> <code>ldf</code>               (<code>list[DataFrame]</code>)           \u2013            <p>list of <code>pd.DataFrames</code> of <code>LogMFD.out</code> files</p> </li> <li> <code>mfd_interval</code>               (<code>list</code>)           \u2013            <p>interval of MFDstep in PLUMED input files</p> </li> <li> <code>hill_region</code>               (<code>1x2 list</code>, default:                   <code>[0.2, 0.6]</code> )           \u2013            <p>the region of CV that contains saddle point. The Left/Right basin is located at left/right of this region. This region should exclude the bassins.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df_min_right</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of right basin minima</p> </li> <li> <code>df_min_left</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of left basin minima</p> </li> <li> <code>df_max</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of maxima energy</p> </li> <li> <code>df_diff</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of energy difference between minima and maxima</p> </li> </ul>"},{"location":"calc_free_energy/#thmd.calc.free_energy.TImethod","title":"<code>thmd.calc.free_energy.TImethod</code>","text":"<p>Functions:</p> <ul> <li> <code>AS_integration</code>             \u2013              <p>Compute Free energy difference in TI method - Lambda integration along Adiabatic Switching path</p> </li> <li> <code>RS_integration</code>             \u2013              <p>Compute Free energy difference in TI method - Lambda integration along Reversible Scaling path</p> </li> <li> <code>Helmholtz_excess_UF</code>             \u2013              <p>this func. is to compute the excess Helmholtz freeEnergy as Eq.(25) by R.Paula Leite 2016.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>kB</code>           \u2013            </li> </ul>"},{"location":"calc_free_energy/#thmd.calc.free_energy.TImethod.kB","title":"<code>kB = sc.value('Boltzmann constant in eV/K')</code>  <code>module-attribute</code>","text":""},{"location":"calc_free_energy/#thmd.calc.free_energy.TImethod.AS_integration","title":"<code>AS_integration(forwFile, backFile)</code>","text":"<p>Compute Free energy difference in TI method - Lambda integration along Adiabatic Switching path</p> <p>Parameters:</p> <ul> <li> <code>forwFile</code>               (<code>str</code>)           \u2013            <p>file name of forward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>backFile</code>               (<code>str</code>)           \u2013            <p>file name of backward integration (must contain 2 first columns are: dE, lambda)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>W</code> (              <code>float</code> )          \u2013            <p>irreversible TI work</p> </li> <li> <code>Q</code> (              <code>float</code> )          \u2013            <p>dissipation</p> </li> </ul>"},{"location":"calc_free_energy/#thmd.calc.free_energy.TImethod.RS_integration","title":"<code>RS_integration(forwFile, backFile, T0=0, F0=0, kB=kB)</code>","text":"<p>Compute Free energy difference in TI method - Lambda integration along Reversible Scaling path</p> <p>Parameters:</p> <ul> <li> <code>forwFile</code>               (<code>str</code>)           \u2013            <p>file name of forward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>backFile</code>               (<code>str</code>)           \u2013            <p>file name of backward integration (must contain 2 first columns are: dE, lambda)</p> </li> <li> <code>T0</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>reference temperature. Default is 0.</p> </li> <li> <code>F0</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>free energy at reference temperature. Default is 0.</p> </li> <li> <code>kB</code>               (<code>float</code>, default:                   <code>kB</code> )           \u2013            <p>Boltzmann constant (chose unit to consist with F0). Default is kB in unit eV/K.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>array</code> )          \u2013            <p>temperature</p> </li> <li> <code>Ft</code> (              <code>array</code> )          \u2013            <p>free energy as a function of temperature.</p> </li> <li> <code>W</code> (              <code>array</code> )          \u2013            <p>cumulative work</p> </li> </ul>"},{"location":"calc_free_energy/#thmd.calc.free_energy.TImethod.Helmholtz_excess_UF","title":"<code>Helmholtz_excess_UF(p, x)</code>","text":"<p>this func. is to compute the excess Helmholtz freeEnergy as Eq.(25) by R.Paula Leite 2016. J.Chem.Phys.145,no.19:194101. https://doi.org/10.1063/1.4967775.                         p  :           # UFM p-parameter                         x = b*rho  :   # adimensional variable, involved UFM-sigma parameter, rho in unit [1/A^3]</p> <ol> <li>the excess_Helmholtz free enegy in eV : (beta*Fexc)/N</li> </ol> <ol> <li>the pressure : beta*b*P</li> </ol>"},{"location":"io_read_block/","title":"Io read block","text":""},{"location":"io_read_block/#thmd.io.read_block","title":"<code>thmd.io.read_block</code>","text":"<p>Classes:</p> <ul> <li> <code>LmpLogFile</code>           \u2013            <p>Create an Object of LOG file.</p> </li> <li> <code>LmpRDF</code>           \u2013            <p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> </li> <li> <code>LmpAveChunk</code>           \u2013            <p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> </li> <li> <code>PlumHistogram</code>           \u2013            <p>Create an Object of DUMP file</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>average_df_list</code>             \u2013              <p>compute average of list of DataFrame</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpLogFile","title":"<code>LmpLogFile(logfile=None)</code>","text":"<p>Create an Object of LOG file.</p> Notes <ul> <li>run 0 without data</li> </ul> Udpate <ul> <li>2024-10-10: use Polars DataFrame instead of Pandas Series</li> </ul> <p>Parameters:</p> <ul> <li> <code>logfile</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>file_name of LOG file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpLogFile</code> )          \u2013            <p>LmpLogFile object</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>read_log</code>             \u2013              <p>Read LAMMPS logfile</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpLogFile.read_log","title":"<code>read_log(logfile)</code>","text":"<p>Read LAMMPS logfile Args:         logfile (str): input LOG file</p> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpLogFile</code> )          \u2013            <p>LmpLogFile object</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpRDF","title":"<code>LmpRDF(file_name: str)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file name</p> </li> <li> <code>frame</code>               (<code>DataFrame</code>)           \u2013            <p>3d pandas Frame (multi-row-index DataFrame)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>             \u2013              <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>             \u2013              <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpAveChunk</code> )          \u2013            <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('rdf.txt')\n</code></pre> <p>Methods:</p> <ul> <li> <code>read_RDF</code>             \u2013              <p>Args:</p> </li> <li> <code>compute_AveRDF</code>             \u2013              <p>compute average of RDF over all frames</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpRDF.read_RDF","title":"<code>read_RDF(file_name: str)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpRDF</code> )          \u2013            <p>LmpRDF object</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpRDF.compute_AveRDF","title":"<code>compute_AveRDF()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Average of RDF</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpAveChunk","title":"<code>LmpAveChunk(file_name)</code>","text":"<p>class to read Radial Distribution Fuction (RDF) file from Lammps compute</p> <p>Attributes:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file name.</p> </li> <li> <code>frame</code>               (<code>DataFrame</code>)           \u2013            <p>3d pandas Frame (multi-row-index DataFrame).</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ReadRDF       </code>             \u2013              <p>read RDF file</p> </li> <li> <code>AverageRDF    </code>             \u2013              <p>the Average RDF</p> </li> </ul> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpAveChunk</code> )          \u2013            <p>LmpAveChunk object</p> </li> </ul> <p>Examples:</p> <pre><code>RDF = LmpAveChunk('LmpAveChunk.txt')\n</code></pre> <p>Methods:</p> <ul> <li> <code>read_AveChunk</code>             \u2013              <p>Args:</p> </li> <li> <code>compute_AveChunk</code>             \u2013              <p>compute average of RDF over all frames</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpAveChunk.read_AveChunk","title":"<code>read_AveChunk(file_name)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>input RDF file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>LmpAveChunk</code> )          \u2013            <p>LmpAveChunk object</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.LmpAveChunk.compute_AveChunk","title":"<code>compute_AveChunk()</code>","text":"<p>compute average of RDF over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Average of RDF</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.PlumHistogram","title":"<code>PlumHistogram(file_name)</code>","text":"<p>Create an Object of DUMP file</p> <p>Methods:</p> <ul> <li> <code>read_histogram       </code>             \u2013              <p>read Histogram file</p> </li> <li> <code>average_histogram    </code>             \u2013              <p>the Average Histogram</p> </li> <li> <code>AreaHisto       </code>             \u2013              <p>Area under pdf curve</p> </li> <li> <code>find_tail</code>             \u2013              <p>find limit of histogram</p> </li> <li> <code>find_center</code>             \u2013              <p>find center of histogram</p> </li> </ul> <p>Examples:</p> <pre><code>from thmd.io.read_block import PlumHistogram\nRDF = PlumHistogram(file_name='myRDF.txt')\n</code></pre> <p>initiate object</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>file_name</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>PlumHistogram</code> )          \u2013            <p>PlumHistogram object</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>read_histogram</code>             \u2013              <p>Args:</p> </li> <li> <code>compute_average_histogram</code>             \u2013              <p>compute average of histogram over all frames</p> </li> <li> <code>areaHisto</code>             \u2013              </li> <li> <code>fit_std_gaussian</code>             \u2013              <p>Fit the average-histogarm to Standard Gaussian function</p> </li> <li> <code>find_tail</code>             \u2013              <p>Find tail of distribution function</p> </li> <li> <code>find_center</code>             \u2013              <p>Find tail of distribution function</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.PlumHistogram.read_histogram","title":"<code>read_histogram(file_name: str)</code>","text":"<p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>input HISTOGRAM file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>PlumHistogram</code> )          \u2013            <p>update PlumHistogram object</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.PlumHistogram.compute_average_histogram","title":"<code>compute_average_histogram()</code>","text":"<p>compute average of histogram over all frames</p> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>DataFrame of avergave histogram</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.PlumHistogram.areaHisto","title":"<code>areaHisto()</code>","text":""},{"location":"io_read_block/#thmd.io.read_block.PlumHistogram.fit_std_gaussian","title":"<code>fit_std_gaussian()</code>","text":"<p>Fit the average-histogarm to Standard Gaussian function</p> <p>Returns:</p> <ul> <li> <code>amp, miu, sigma) (tuple</code>           \u2013            <p>parameters of Gaussian function</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.PlumHistogram.find_tail","title":"<code>find_tail(tol=0.0001, gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>tol</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>tolerance</p> </li> <li> <code>gridSize</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>left_tail</code> (              <code>float</code> )          \u2013            <p>limit on the left side</p> </li> <li> <code>right_tail</code> (              <code>float</code> )          \u2013            <p>limit on the right side</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.PlumHistogram.find_center","title":"<code>find_center(gridSize=1e-06)</code>","text":"<p>Find tail of distribution function</p> <p>Parameters:</p> <ul> <li> <code>gridSize</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>size of grid</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Xcenter</code> (              <code>float</code> )          \u2013            <p>center of the distribution function</p> </li> </ul>"},{"location":"io_read_block/#thmd.io.read_block.average_df_list","title":"<code>average_df_list(list_df: list[pl.DataFrame]) -&gt; pl.DataFrame</code>","text":"<p>compute average of list of DataFrame</p> <p>Parameters:</p> <ul> <li> <code>list_df</code>               (<code>list</code>)           \u2013            <p>list of DataFrame</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Average of list of DataFrame</p> </li> </ul>"},{"location":"io_read_data/","title":"Io read data","text":""},{"location":"io_read_data/#thmd.io.read_data","title":"<code>thmd.io.read_data</code>","text":"<p>This module contains functions to read numeric data from various formats of TEXT files.</p> <p>Functions:</p> <ul> <li> <code>matrix_lost</code>             \u2013              <p>Function to read data in matrix form, in which number of values in each line are NOT equal (missing values)</p> </li> <li> <code>matrix</code>             \u2013              <p>Function to read Data that is as a regular matrix.</p> </li> <li> <code>logMFD</code>             \u2013              <p>Function to read data from LogMFD calculation.</p> </li> <li> <code>lammps_var</code>             \u2013              <p>Function to extract variable values from LAMMPS input file.</p> </li> <li> <code>plumed_var</code>             \u2013              <p>Function to extract variable values from PLUMED input file.</p> </li> <li> <code>list_matrix_in_dir</code>             \u2013              <p>read data from all *.txt files in current and sub-folders.</p> </li> </ul>"},{"location":"io_read_data/#thmd.io.read_data.matrix_lost","title":"<code>matrix_lost(file_name: str, header_line: int = None, column_names: list[str] = None, comment: str = '#', sep: str = ' ', read_note: bool = False) -&gt; pl.DataFrame</code>","text":"<p>Function to read data in matrix form, in which number of values in each line are NOT equal (missing values) This cannot be read by Numpy, <code>polars</code>,...</p> <p>The names of columns are extracted from <code>header_line</code> or set by <code>column_names</code>. If both <code>column_names</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file.</p> </li> <li> <code>header_line</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>the lines to extract column-names. Defaults to None.</p> </li> <li> <code>column_names</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>comment</code>               (<code>str</code>, default:                   <code>'#'</code> )           \u2013            <p>comment-line mark. Defaults to \"#\".</p> </li> <li> <code>sep</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>separator. Defaults to \" \".</p> </li> <li> <code>read_note</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>read 'note' column (any text beyond comment mark). Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>polars DataFrame</p> </li> </ul> Notes <ul> <li>To return 2 lists from list comprehension, it is better (may faster) running 2 separated list comprehensions.</li> <li><code>.strip()</code> function removes trailing and leading space in string.</li> </ul>"},{"location":"io_read_data/#thmd.io.read_data.matrix","title":"<code>matrix(file_name: str, header_line: int = None, column_names: list[str] = None, usecols: tuple[int] = None) -&gt; pl.DataFrame</code>","text":"<p>Function to read Data that is as a regular matrix. The names of columns are exatract based on <code>column_names</code> or <code>header_line</code>. If both <code>column_names</code> and <code>header_line</code> are not available, the default column's name is: 0 1 2...</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file.</p> </li> <li> <code>header_line</code>               (<code>int</code>, default:                   <code>None</code> )           \u2013            <p>the line to extract column-names. Defaults to None.</p> </li> <li> <code>column_names</code>               (<code>list[str]</code>, default:                   <code>None</code> )           \u2013            <p>Names of columns to extract. Defaults to None.</p> </li> <li> <code>usecols</code>               (<code>tuple[int]</code>, default:                   <code>None</code> )           \u2013            <p>only extract some columns. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p><code>polars</code> DataFrame</p> </li> </ul>"},{"location":"io_read_data/#thmd.io.read_data.logMFD","title":"<code>logMFD(file_name, dim=1) -&gt; pl.DataFrame</code>","text":"<p>Function to read data from LogMFD calculation.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the logmfd.out file.</p> </li> <li> <code>dim</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>dimension of LogMFD calulation. Defaults to 1.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>description</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p><code>polars</code> DataFrame</p> </li> </ul>"},{"location":"io_read_data/#thmd.io.read_data.lammps_var","title":"<code>lammps_var(file_name, var_names=None)</code>","text":"<p>Function to extract variable values from LAMMPS input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_names</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list of varibalbes to be extracted. Default to None. mean extract all variables.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p><code>polars</code> DataFrame contains variable in Lammps file</p> </li> </ul>"},{"location":"io_read_data/#thmd.io.read_data.plumed_var","title":"<code>plumed_var(file_name, var_name, block_name=None)</code>","text":"<p>Function to extract variable values from PLUMED input file.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>the text file in LAMMPS input format.</p> </li> <li> <code>var_name</code>               (<code>str</code>)           \u2013            <p>list of keyworks in PLUMED, ex: INTERVAL,...</p> </li> <li> <code>block_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>block command in Plumed, ex: METAD, LOGMFD. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>value</code> (              <code>float</code> )          \u2013            <p>value of plumed_var.</p> </li> </ul> Refs <p>Include negative decimal numbers in regular expression</p>"},{"location":"io_read_data/#thmd.io.read_data.list_matrix_in_dir","title":"<code>list_matrix_in_dir(search_key='deform_', file_ext='.txt', read_note=False, recursive=True)</code>","text":"<p>read data from all *.txt files in current and sub-folders.</p> <p>Parameters:</p> <ul> <li> <code>search_key</code>               (<code>str</code>, default:                   <code>'deform_'</code> )           \u2013            <p>a string to search file_name.</p> </li> <li> <code>file_ext</code>               (<code>str</code>, default:                   <code>'.txt'</code> )           \u2013            <p>file extension. Default to '.txt'</p> </li> <li> <code>read_note</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>read 'note' column in pl.DataFrame. Default to False.</p> </li> <li> <code>recursive</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>search in sub-folders. Default to True.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ldf</code> (              <code>list</code> )          \u2013            <p>list of DataFrames.</p> </li> <li> <code>files</code> (              <code>list</code> )          \u2013            <p>list of filenames.</p> </li> </ul>"},{"location":"io_script/","title":"Io script","text":""},{"location":"io_script/#thmd.io.script","title":"<code>thmd.io.script</code>","text":"<p>This module contains functions to read/write some specific scripts.</p> <p>Functions:</p> <ul> <li> <code>read_lines</code>             \u2013              <p>Function to read lines in a script that match some KEY_WORDs.</p> </li> <li> <code>read_plumed_block</code>             \u2013              <p>Function to read block_command in PLUMED script.</p> </li> <li> <code>write_lines</code>             \u2013              <p>Funtion to write a list of strings into file.</p> </li> <li> <code>write_list</code>             \u2013              <p>Funtion to write a list of strings into file.</p> </li> </ul>"},{"location":"io_script/#thmd.io.script.read_lines","title":"<code>read_lines(file_name: str, keywords: list = [])</code>","text":"<p>Function to read lines in a script that match some KEY_WORDs.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>a text file of any format.</p> </li> <li> <code>keywords</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>list-of-Keywords to extract a line, ex: METAD, LOGMFD. Default to [], mean read all lines.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (              <code>list</code> )          \u2013            <p>a list of lines.</p> </li> <li> <code>rest_lines</code> (              <code>list</code> )          \u2013            <p>a list of rest lines.</p> </li> </ul>"},{"location":"io_script/#thmd.io.script.read_plumed_block","title":"<code>read_plumed_block(file_name: str, block_name: str = ' ') -&gt; list</code>","text":"<p>Function to read block_command in PLUMED script.</p> <p>Parameters:</p> <ul> <li> <code>file_name</code>               (<code>str</code>)           \u2013            <p>a text file of PLUMED format.</p> </li> <li> <code>block_name</code>               (<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>block command in PLUMED, ex: METAD, LOGMFD</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>lines</code> (              <code>list</code> )          \u2013            <p>block_of_commandlines</p> </li> </ul>"},{"location":"io_script/#thmd.io.script.write_lines","title":"<code>write_lines(filename: str, lines: list)</code>","text":"<p>Funtion to write a list of strings into file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>file name.</p> </li> <li> <code>lines</code>               (<code>list</code>)           \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"io_script/#thmd.io.script.write_list","title":"<code>write_list(lines: list, filename: str)</code>","text":"<p>Funtion to write a list of strings into file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>file name.</p> </li> <li> <code>lines</code>               (<code>list</code>)           \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"io_traj/","title":"Io traj","text":""},{"location":"io_traj/#thmd.io.traj","title":"<code>thmd.io.traj</code>","text":"<p>This module contains classes and functions to process molecular dynamics trajectories.</p> <p>Classes:</p> <ul> <li> <code>Frame</code>           \u2013            <p>Create an Object for a single-FRAME of trajectories from MD simulation.</p> </li> <li> <code>Traj</code>           \u2013            <p>Create an Object for a multi-FRAMEs of trajectories from MD simulation.</p> </li> </ul>"},{"location":"io_traj/#thmd.io.traj.Frame","title":"<code>Frame(dump_file: str = None, data_file: str = None, atom_style: str = 'auto', pdb_file: str = None, xyz_file: str = None, from_df: pd.DataFrame = None, box: np.array = None, box_angle: np.array = None)</code>","text":"<p>Create an Object for a single-FRAME of trajectories from MD simulation.</p> <p>This class create a data-object (single configuration) for the analysis of computing data from LAMMPS. The file formats implemented in this class</p> <p></p> <ul> <li>LAMMPS DATA Format</li> <li>LAMMPS DUMP Format</li> <li>PDB format</li> <li>XYZ format</li> </ul> <p>This class implemented several ways to create <code>Frame</code> object</p> <ul> <li>create an empty data object</li> <li>create_DATA object with input data</li> <li>read from DUMP file</li> <li>read from DATA file</li> <li>read frome PDB file</li> </ul> <p>Attributes:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> <li> <code>timestep</code>               (<code>int</code>)           \u2013            <p>the timestep of configuration</p> </li> <li> <code>box</code>               (<code>array</code>)           \u2013            <p>3x2 array, the box size</p> </li> <li> <code>box_angle</code>               (<code>array</code>)           \u2013            <p>1x3 array, the box angle</p> </li> <li> <code>atom</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame of per-atom values</p> </li> <li> <code>prop_key</code>               (<code>list</code>)           \u2013            <p>column-names of properties</p> </li> <li> <code>mass</code>               (<code>DataFrame</code>)           \u2013            <p>DataFrame of per-type masses</p> </li> <li> <code>fmt</code>               (<code>str</code>)           \u2013            <p>default format for float numbers, don't use %g because it will lost precision</p> </li> </ul> <p>Examples:</p> <pre><code>from thmd.traj  import Frame\n\nda = Frame()                        # empty object\nda = Frame(from_df=df)              # oject with input data\nda = Frame(dump_file='test.cfg')    # from DUMP file\nda = Frame(data_file='mydata.dat')  # from DATA file\nda = Frame(pdb_file='test.pdb')     # from PDB file\n</code></pre> <p>Refs:     [1]. Use chain mutator calls</p> <p>initilize the Frame object</p> <p>Parameters:</p> <ul> <li> <code>dump_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of DUMP file.</p> </li> <li> <code>data_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of DATA file.</p> </li> <li> <code>pdb_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of PBD file.</p> </li> <li> <code>xyz_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>filename of XYZ file.</p> </li> <li> <code>from_df</code>               (<code>DataFrame</code>, default:                   <code>None</code> )           \u2013            <p>create FRAME from data.</p> </li> <li> <code>atom_style</code>               (<code>str</code>, default:                   <code>'auto'</code> )           \u2013            <p>atom_style of system. Only need when <code>data_file</code> is used. Possible values: 'atomic', 'molecular', 'charge', 'full', 'auto'</p> </li> <li> <code>box</code>               (<code>np.array list</code>, default:                   <code>None</code> )           \u2013            <p>Define simulation box. Only need when <code>from_df</code> is used.</p> </li> <li> <code>box_angle</code>               (<code>np.array list</code>, default:                   <code>None</code> )           \u2013            <p>Define angle of simulation box. Only need when <code>from_df</code> is used.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>Frame</code> )          \u2013            <p>object of trajectories</p> </li> </ul> Notes <p>Use mutator, so do not use self.* when define value</p> <p>Methods:</p> <ul> <li> <code>create_DATA</code>             \u2013              <p>The method to create new FRAME object with input data.</p> </li> <li> <code>copy</code>             \u2013              <p>The method to make an indepedent copy of Frame Obj. Then, the change values of the fields of the new object, the old object should not be affected by that.</p> </li> <li> <code>check_exist</code>             \u2013              <p>The method to check whether something is existed in system or not.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            </li> <li> <code>timestep</code>               (<code>int</code>)           \u2013            </li> <li> <code>decimals</code>               (<code>int</code>)           \u2013            </li> <li> <code>box</code>           \u2013            </li> <li> <code>box_angle</code>           \u2013            </li> <li> <code>prop_key</code>               (<code>list[str]</code>)           \u2013            </li> <li> <code>atom</code>           \u2013            </li> <li> <code>mass</code>           \u2013            </li> <li> <code>pair_coeff</code>           \u2013            </li> <li> <code>bond_coeff</code>           \u2013            </li> <li> <code>angle_coeff</code>           \u2013            </li> <li> <code>dihedral_coeff</code>           \u2013            </li> <li> <code>improper_coeff</code>           \u2013            </li> <li> <code>bondBond_coeff</code>           \u2013            </li> <li> <code>bondAngle_coeff</code>           \u2013            </li> <li> <code>middleBondTorsion_coeff</code>           \u2013            </li> <li> <code>endBondTorsion_coeff</code>           \u2013            </li> <li> <code>angleTorsion_coeff</code>           \u2013            </li> <li> <code>angleAngleTorsion_coeff</code>           \u2013            </li> <li> <code>bondBond13_coeff</code>           \u2013            </li> <li> <code>angleAngle_coeff</code>           \u2013            </li> <li> <code>bond</code>           \u2013            </li> <li> <code>angle</code>           \u2013            </li> <li> <code>dihedral</code>           \u2013            </li> <li> <code>improper</code>           \u2013            </li> </ul>"},{"location":"io_traj/#thmd.io.traj.Frame.filename","title":"<code>filename: str = 'md_frame'</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.timestep","title":"<code>timestep: int = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.decimals","title":"<code>decimals: int = 7</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.box","title":"<code>box = np.asarray([[0, 1], [0, 1], [0, 1]], dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.box_angle","title":"<code>box_angle = np.asarray([0, 0, 0], dtype=float)</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.prop_key","title":"<code>prop_key: list[str] = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.atom","title":"<code>atom = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.mass","title":"<code>mass = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.pair_coeff","title":"<code>pair_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.bond_coeff","title":"<code>bond_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.angle_coeff","title":"<code>angle_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.dihedral_coeff","title":"<code>dihedral_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.improper_coeff","title":"<code>improper_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.bondBond_coeff","title":"<code>bondBond_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.bondAngle_coeff","title":"<code>bondAngle_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.middleBondTorsion_coeff","title":"<code>middleBondTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.endBondTorsion_coeff","title":"<code>endBondTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.angleTorsion_coeff","title":"<code>angleTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.angleAngleTorsion_coeff","title":"<code>angleAngleTorsion_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.bondBond13_coeff","title":"<code>bondBond13_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.angleAngle_coeff","title":"<code>angleAngle_coeff = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.bond","title":"<code>bond = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.angle","title":"<code>angle = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.dihedral","title":"<code>dihedral = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.improper","title":"<code>improper = None</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Frame.create_DATA","title":"<code>create_DATA(df: pd.DataFrame, box: np.array = None, box_angle: np.array = None)</code>","text":"<p>The method to create new FRAME object with input data.</p> <p>Parameters:</p> <ul> <li> <code>DataFrame</code>               (<code>DataFrame</code>)           \u2013            <p>of input data</p> </li> <li> <code>box</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>3x2 array, option to input boxSize.</p> </li> <li> <code>box_angle</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1x3 array, option to input box_angle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>Frame</code> )          \u2013            <p>update Frame</p> </li> </ul> <p>Examples:</p> <pre><code>da = Frame()\nda.create_DATA(DataFrame=df)\n# or\nda = Frame(from_df=df)\n</code></pre>"},{"location":"io_traj/#thmd.io.traj.Frame.copy","title":"<code>copy()</code>","text":"<p>The method to make an indepedent copy of Frame Obj. Then, the change values of the fields of the new object, the old object should not be affected by that.</p> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>Frame</code> )          \u2013            <p>new Frame Obj.</p> </li> </ul> <p>Examples:</p> <pre><code>da1 = da.copy()\n</code></pre> <p>Refs:     [1]. \"shallow copying\" vs \"deep copying\": https://stackoverflow.com/questions/3975376/understanding-dict-copy-shallow-or-deep/3975388#3975388</p>"},{"location":"io_traj/#thmd.io.traj.Frame.check_exist","title":"<code>check_exist(atom_types=None, mass_types=None)</code>","text":"<p>The method to check whether something is existed in system or not.</p> <p>Parameters:</p> <ul> <li> <code>atom_types</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list-of-int of atom-types. Default to None.</p> </li> <li> <code>mass_types</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>list-of-int of atom-types. Default to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>mgs</code> (              <code>str</code> )          \u2013            <p>raise Message if error.</p> </li> </ul> <p>Examples:</p> <pre><code>da.isExist(atom_types=[2,3])\n</code></pre> Notes <p>set() also return unique values.</p>"},{"location":"io_traj/#thmd.io.traj.Traj","title":"<code>Traj(**kwargs)</code>","text":"<p>Create an Object for a multi-FRAMEs of trajectories from MD simulation. - read frome XYZ file</p> <p>initilize the TrajFrame object</p> Notes <p>Use mutator, so do not use self.* when define value</p> <p>Methods:</p> <ul> <li> <code>readXYZ</code>             \u2013              <p>The method create Multi-FRAME object by reading XYZ file.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>decimals</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"io_traj/#thmd.io.traj.Traj.decimals","title":"<code>decimals: int = 6</code>  <code>instance-attribute</code>","text":""},{"location":"io_traj/#thmd.io.traj.Traj.readXYZ","title":"<code>readXYZ(filename)</code>","text":"<p>The method create Multi-FRAME object by reading XYZ file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>name of input file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Obj</code> (              <code>TrajFrame</code> )          \u2013            <p>update FRAME</p> </li> </ul> <p>Examples:</p> <pre><code>da = io.TrajFrame(pdb_file='mydata.pdb')\n</code></pre>"},{"location":"latex/","title":"latex","text":""},{"location":"latex/#thmd.latex","title":"<code>thmd.latex</code>","text":"<p>Functions:</p> <ul> <li> <code>get_citekeys</code>             \u2013              <p>Extract all citekeys from a list of <code>.tex</code> files.</p> </li> <li> <code>select_entries</code>             \u2013              <p>Select bibliography entries from a Bibtex <code>.bib</code> file</p> </li> <li> <code>write_bibtex</code>             \u2013              <p>Write bibliography data to a Bibtex <code>.bib</code> file</p> </li> <li> <code>minimize_bibtex</code>             \u2013              <p>Minimize the <code>.bib</code> file so that it contains only entries that are cited in the <code>.tex</code> files.</p> </li> <li> <code>check_bibtex</code>             \u2013              <p>Check for missing fields in the bibtex entries. Based on the <code>type</code> of the entry, there are mandatory fields. This function is to check if any of mandatory fields is missing.</p> </li> <li> <code>tex2doc</code>             \u2013              <p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file.</p> </li> <li> <code>tex2pdf</code>             \u2013              <p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file.</p> </li> <li> <code>replace_acronyms</code>             \u2013              <p>Check and replace if acronyms are used in a <code>.tex</code> file.</p> </li> <li> <code>count_cited_journals</code>             \u2013              <p>Count the number of times each journal is cited in the <code>.bib</code> file.</p> </li> </ul>"},{"location":"latex/#thmd.latex.get_citekeys","title":"<code>get_citekeys(tex_files: Union[str, list]) -&gt; list</code>","text":"<p>Extract all citekeys from a list of <code>.tex</code> files.</p> <p>Parameters:</p> <ul> <li> <code>tex_files</code>               (<code>Union[str, list]</code>)           \u2013            <p>paths to <code>.tex</code> files</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>citekeys</code> (              <code>list</code> )          \u2013            <p>list of citekeys</p> </li> </ul>"},{"location":"latex/#thmd.latex.select_entries","title":"<code>select_entries(citekeys: list, bib_file: str) -&gt; BibliographyData</code>","text":"<p>Select bibliography entries from a Bibtex <code>.bib</code> file</p> <p>Parameters:</p> <ul> <li> <code>citekeys</code>               (<code>list</code>)           \u2013            <p>list of citekeys</p> </li> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to a <code>.bib</code> file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BibliographyData</code> (              <code>BibliographyData</code> )          \u2013            <p>selected bibliography entries. See pybtex.database.BibliographyData</p> </li> </ul>"},{"location":"latex/#thmd.latex.write_bibtex","title":"<code>write_bibtex(bib_data: BibliographyData, out_file: str = 'reference.bib') -&gt; None</code>","text":"<p>Write bibliography data to a Bibtex <code>.bib</code> file</p> <p>Parameters:</p> <ul> <li> <code>bib_data</code>               (<code>BibliographyData</code>)           \u2013            <p>bibliography entries. See pybtex.database.BibliographyData</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'reference.bib'</code> )           \u2013            <p>path to the output <code>.bib</code> file</p> </li> </ul>"},{"location":"latex/#thmd.latex.minimize_bibtex","title":"<code>minimize_bibtex(tex_files: Union[str, list], bib_file: str, out_file: str = 'reference_min.bib') -&gt; None</code>","text":"<p>Minimize the <code>.bib</code> file so that it contains only entries that are cited in the <code>.tex</code> files.</p> <p>Parameters:</p> <ul> <li> <code>tex_files</code>               (<code>Union[str, list]</code>)           \u2013            <p>path to <code>.tex</code> files</p> </li> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to the original <code>.bib</code> file</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'reference_min.bib'</code> )           \u2013            <p>path to the new <code>.bib</code> file</p> </li> </ul>"},{"location":"latex/#thmd.latex.check_bibtex","title":"<code>check_bibtex(bib_file: str, verbose: bool = True, logfile: bool = False, lower_key=False) -&gt; list</code>","text":"<p>Check for missing fields in the bibtex entries. Based on the <code>type</code> of the entry, there are mandatory fields. This function is to check if any of mandatory fields is missing.</p> <p>Parameters:</p> <ul> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to the original <code>.bib</code> file.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>print output to the console.</p> </li> <li> <code>logfile</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>write output to a log file.</p> </li> <li> <code>lower_key</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>convert the keys in <code>bib_file</code> to lower case.</p> </li> </ul> <p>Examples:</p> <pre><code>from thml.latex import check_bibtex\ncheck_bibtex('reference.bib', verbose=True)\n</code></pre>"},{"location":"latex/#thmd.latex.tex2doc","title":"<code>tex2doc(tex_file: str, out_file: str = 'output.docx', bib_file: str = None, **kwargs)</code>","text":"<p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file. Need to install <code>pandoc</code> and <code>panflute</code> first. <pre><code>condac install -c conda-forge pandoc\npip install panflute\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>tex_file</code>               (<code>str</code>)           \u2013            <p>path to the <code>.tex</code> file</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'output.docx'</code> )           \u2013            <p>path to the output <code>.docx</code> file</p> </li> <li> <code>bib_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the <code>.bib</code> file</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>cite_style</code>               (<code>str = 'elsevier_vancouver.csl'</code>)           \u2013            <p>path to the citation style <code>.cls' file. Can download from [here](https://github.com/citation-style-language/styles) or in</code>Zotero_folder/styles`</p> </li> <li> <code>reference_doc</code>               (<code>str</code>)           \u2013            <p>path to the reference <code>.docx</code> file</p> </li> <li> <code>resource_path</code>               (<code>str = './figure'</code>)           \u2013            <p>path to the folder containing the figures and other resources.</p> </li> <li> <code>verbose</code>               (<code>bool = False</code>)           \u2013            <p>print the output of the command</p> </li> <li> <code>pandoc-crossref</code>               (<code>bool = True</code>)           \u2013            <p>use the <code>pandoc-crossref</code> extension for equation numbering</p> </li> </ul>"},{"location":"latex/#thmd.latex.tex2pdf","title":"<code>tex2pdf(tex_file: str, out_file: str = 'output.pdf', bib_file: str = None, **kwargs)</code>","text":"<p>Convert a Latex source <code>.tex</code> file to a Microsoft Word <code>.docx</code> file.</p> <p>Parameters:</p> <ul> <li> <code>tex_file</code>               (<code>str</code>)           \u2013            <p>path to the <code>.tex</code> file</p> </li> <li> <code>out_file</code>               (<code>str</code>, default:                   <code>'output.pdf'</code> )           \u2013            <p>path to the output <code>.docx</code> file</p> </li> <li> <code>bib_file</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the <code>.bib</code> file</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>cite_style</code>               (<code>str = 'elsevier_vancouver.csl'</code>)           \u2013            <p>path to the citation style `.cls' file. Can download from here</p> </li> <li> <code>resource_path</code>               (<code>str = './figure'</code>)           \u2013            <p>path to the folder containing the figures and other resources.</p> </li> <li> <code>verbose</code>               (<code>bool = False</code>)           \u2013            <p>print the output of the command</p> </li> </ul>"},{"location":"latex/#thmd.latex.replace_acronyms","title":"<code>replace_acronyms(tex_file: str, acronyms: dict) -&gt; list</code>","text":"<p>Check and replace if acronyms are used in a <code>.tex</code> file.</p> <p>Not implemented yet.</p>"},{"location":"latex/#thmd.latex.count_cited_journals","title":"<code>count_cited_journals(bib_file: str) -&gt; dict</code>","text":"<p>Count the number of times each journal is cited in the <code>.bib</code> file.</p> <p>Parameters:</p> <ul> <li> <code>bib_file</code>               (<code>str</code>)           \u2013            <p>path to the <code>.bib</code> file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code> (              <code>dict</code> )          \u2013            <p>a dictionary containing the journal names and the number of times they are cited.</p> </li> </ul>"},{"location":"model/","title":"model","text":""},{"location":"model/#thmd.model","title":"<code>thmd.model</code>","text":"<p>Modules:</p> <ul> <li> <code>D1tube</code>           \u2013            </li> <li> <code>D2haxagonal</code>           \u2013            </li> <li> <code>D3crystal</code>           \u2013            </li> <li> <code>box_tool</code>           \u2013            </li> <li> <code>combining_LJ_interface</code>           \u2013            </li> <li> <code>coord_rotation</code>           \u2013            </li> <li> <code>forcefield_info</code>           \u2013            <p>This module contains some data for various ForceField. Data obtained from simulation</p> </li> <li> <code>polymer_mbuild</code>           \u2013            <p>This module contains classes and functions to build models of atomic polymers</p> </li> <li> <code>polymer_pysimm</code>           \u2013            <p>This module contains classes to build models of atomic polymers</p> </li> </ul>"},{"location":"model/#thmd.model.D1tube","title":"<code>D1tube</code>","text":"<p>Functions:</p> <ul> <li> <code>lattice_CNT</code>             \u2013              <p>Calculates the 3D Cartesian coordinates of atoms of of (n,m) CNT.</p> </li> </ul>"},{"location":"model/#thmd.model.D1tube.lattice_CNT","title":"<code>lattice_CNT(m, n, bond_CC=1.421, aspect=1, basis_atom='AB')</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of of (n,m) CNT.</p> <p>thangckt, Aug 2022</p> <p>Parameters:</p> <ul> <li> <code>n,m</code>               (<code>int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>               (<code>float</code>, default:                   <code>1.421</code> )           \u2013            <p>Length of C-C bonds</p> </li> <li> <code>aspect</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The nanotube aspect ratio L/D.</p> </li> <li> <code>basis_atom</code>               (<code>str</code>, default:                   <code>'AB'</code> )           \u2013            <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms  - 'AB': full Garaphene-like crystal  - 'A': semi Graphene-like with atom at A-position  - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>Simulation box</p> </li> <li> <code>param</code> (              <code>dict</code> )          \u2013            <p>dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float): length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float): length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float): Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array): Chiral vector 'Translate_vector' (array): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p>"},{"location":"model/#thmd.model.D2haxagonal","title":"<code>D2haxagonal</code>","text":"<p>Functions:</p> <ul> <li> <code>lattice_Graphene</code>             \u2013              <p>Calculates the 3D Cartesian coordinates of atoms of (n,m)graphene sheet/ Graphite</p> </li> </ul>"},{"location":"model/#thmd.model.D2haxagonal.lattice_Graphene","title":"<code>lattice_Graphene(m, n, bond_CC=1.421, sheet_size=[1, 1], sheet_number=1, layer_bond=3.35, basis_atom='AB')</code>","text":"<p>Calculates the 3D Cartesian coordinates of atoms of (n,m)graphene sheet/ Graphite</p> <p>thangckt, Nov 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>m</code>               (<code>int</code>)           \u2013            <p>Chiral indices n&gt;=m&gt;=0</p> </li> <li> <code>bond_CC</code>               (<code>float</code>, default:                   <code>1.421</code> )           \u2013            <p>Length of C-C bonds</p> </li> <li> <code>sheet_size</code>               (<code>list</code>, default:                   <code>[1, 1]</code> )           \u2013            <p>[Xsize, Ysize], size of graphene sheet</p> </li> <li> <code>sheet_number</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>number of sheets</p> </li> <li> <code>layer_bond</code>               (<code>float</code>, default:                   <code>3.35</code> )           \u2013            <p>Length of plane-plane bonds</p> </li> <li> <code>basis_atom</code>               (<code>str</code>, default:                   <code>'AB'</code> )           \u2013            <p>'AB'/'A'/'B': to create semi-Graphene lattice for adoptting Hydrogen atoms - 'AB': full Garaphene-like crystal - 'A': semi Graphene-like with atom at A-position - 'B': semi Graphene-like with atom at B-position</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>Nx3 array, contain positions of atoms of 1 units cell of (n,m)graphene sheet.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>Simulation box</p> </li> <li> <code>param</code> (              <code>dict</code> )          \u2013            <p>dict contains characteristic parameters of graphene lattice. 'Chiral_len' (float): length of Translational unit vector, corresponding to length on Y direction 'Translate_len' (float): length of Chiral vector, corresponding to length on X direction 'Chiral_ang' (float): Chiral angle of Graphene sheet in Degree. 'Chiral_vector' (array): Chiral vector 'Translate_vector' (array): translations vector</p> </li> </ul> <p>Notes         <pre><code>n=1, m=0 : is the unit cell for Zigzag\nn=1, m=1 : is the unit cell for Armchair\nn&gt;m      : unit cell is automatically computed\n</code></pre></p>"},{"location":"model/#thmd.model.D3crystal","title":"<code>D3crystal</code>","text":"<p>Functions:</p> <ul> <li> <code>lattice_orthoRHOMBIC</code>             \u2013              <p>Function to create atomic coordinates for crystal model</p> </li> <li> <code>lattice_CUBIC</code>             \u2013              <p>Shortcut to create CUBIC crystal, as subclass of ortthoRHOMBIC</p> </li> </ul>"},{"location":"model/#thmd.model.D3crystal.lattice_orthoRHOMBIC","title":"<code>lattice_orthoRHOMBIC(crystal_type, lattice_constant, orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], size=[1, 1, 1], bound_cond=[1, 1, 1], tol_on_bound=0.1)</code>","text":"<p>Function to create atomic coordinates for crystal model</p> <p>Parameters:</p> <ul> <li> <code>crystal_type</code>               (<code>str</code>)           \u2013            <p>'V2O5', 'FCC', 'BCC'</p> </li> <li> <code>lattice_constant</code>               (<code>list</code>)           \u2013            <p>lattice constant [a,b,c] corresponding to [x,y,z]</p> </li> <li> <code>orient</code>               (<code>list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array, contain direction vectors define crystal orientation, ex: ([[1,0,0], [0,1,0], [0,0,1]])</p> </li> <li> <code>size</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>[Nx Ny Nz] 1x3 array, size of model, Nx is X-size in lattice constant unit</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 array contain convention for boundary conditions: 1 is peridic; 0 is not</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code> (              <code>array</code> )          \u2013            <p>Nx3 array contain positions of atoms.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of box contain lattice ([[xlo, xhi], [ylo, yhi], [zlo, zhi]])</p> </li> <li> <code>unit_box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of unit cell</p> </li> </ul>"},{"location":"model/#thmd.model.D3crystal.lattice_CUBIC","title":"<code>lattice_CUBIC(crystal_type, lattice_constant, orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], size=[1, 1, 1], bound_cond=[1, 1, 1], tol_on_bound=0.1)</code>","text":"<p>Shortcut to create CUBIC crystal, as subclass of ortthoRHOMBIC</p> <p>Parameters:</p> <ul> <li> <code>crystal_type</code>               (<code>str</code>)           \u2013            <p>'FCC', 'BCC'</p> </li> <li> <code>lattice_constant</code>               (<code>float</code>)           \u2013            <p>lattice constant a</p> </li> <li> <code>orient</code>               (<code>list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array, contain direction vectors define crystal orientation, ex: ([[1,0,0], [0,1,0], [0,0,1]])</p> </li> <li> <code>size</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>[Nx Ny Nz] 1x3 array, size of model, Nx is X-size in lattice constant unit</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 array contain convention for boundary conditions: 1 is peridic; 0 is not</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code> (              <code>array</code> )          \u2013            <p>Nx3 array contain positions of atoms.</p> </li> <li> <code>box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of box contain lattice ([[xlo, xhi], [ylo, yhi], [zlo, zhi]])</p> </li> <li> <code>unit_box</code> (              <code>array</code> )          \u2013            <p>3x2 array contain size of unit cell</p> </li> </ul>"},{"location":"model/#thmd.model.box_tool","title":"<code>box_tool</code>","text":"<p>Functions:</p> <ul> <li> <code>add_periodic_image</code>             \u2013              <p>Function to add \"Periodic Images\" of atoms at Periodic Boundaries (with a specific cutoff distance)</p> </li> <li> <code>wrap_coord_PBC</code>             \u2013              <p>Function to wrap atom positions at Periodic Boundaries</p> </li> <li> <code>shell_fcc</code>             \u2013              <p>Compute nearest-neighbor shells for FCC crystal</p> </li> <li> <code>box_generate</code>             \u2013              <p>Generate orientation and dimensions of simulation box.</p> </li> <li> <code>box_orient</code>             \u2013              <p>Generate orirentations of simulation box.</p> </li> </ul>"},{"location":"model/#thmd.model.box_tool.add_periodic_image","title":"<code>add_periodic_image(points: pd.DataFrame | np.ndarray | list, box: np.ndarray, bound_cond: list = [1, 1, 1], cutoff: float = 6.5) -&gt; pd.DataFrame</code>","text":"<p>Function to add \"Periodic Images\" of atoms at Periodic Boundaries (with a specific cutoff distance) By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>2d-list np.array pd.DataFrame</code>)           \u2013            <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>               (<code>3d-list array</code>)           \u2013            <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> <li> <code>cutoff</code>               (<code>float</code>, default:                   <code>6.5</code> )           \u2013            <p>Cutoff distance</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>contains original atoms and image atoms with remark colum df['image'].</p> </li> </ul> <p>Examples:</p> <p>```py</p> <pre><code>df = add_periodic_image(P, box, bound_cond=[1 1 0], cutoff=5)\n    ```\n</code></pre>"},{"location":"model/#thmd.model.box_tool.wrap_coord_PBC","title":"<code>wrap_coord_PBC(points: pd.DataFrame | np.ndarray | list, box: np.ndarray, bound_cond: list = [1, 1, 1]) -&gt; pd.DataFrame</code>","text":"<p>Function to wrap atom positions at Periodic Boundaries By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>2d-list np.array pd.DataFrame</code>)           \u2013            <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>               (<code>3d-list array</code>)           \u2013            <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>contains atom positions.</p> </li> </ul> <p>Examples:         <code>py     df = wrap_coord_PBC(P, box, bound_cond=[1 1 0], cutoff=5)</code></p>"},{"location":"model/#thmd.model.box_tool.shell_fcc","title":"<code>shell_fcc(a)</code>","text":"<p>Compute nearest-neighbor shells for FCC crystal</p> <p>Parameters:</p> <ul> <li> <code>a</code>               (<code>float</code>)           \u2013            <p>lattice constant</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>shell</code> (              <code>list</code> )          \u2013            <p>5 nearest-neighbor shells</p> </li> </ul>"},{"location":"model/#thmd.model.box_tool.box_generate","title":"<code>box_generate(box_size: list = [1, 1, 1], zDirect: str = '001', xDirect: str = None) -&gt; Dict[str, List]</code>","text":"<p>Generate orientation and dimensions of simulation box.</p> <p>Parameters:</p> <ul> <li> <code>box_size</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>dimension of box on each side as in [100] direction</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>specify the direction of z-side. Defaults to '001', mean nothing is happen.</p> </li> <li> <code>xDirect</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>specify the direction of z-side.  Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>box</code> (              <code>dict</code> )          \u2013            <p>dictionary contain orientation and box_size - 'orient' (list[list]): list-of-vectors of 3 directional vectors. - 'box_size' (list[list]): dimension of box on each side.</p> </li> </ul> <p>Examples:</p> <pre><code>box = box_generate(box_size=[1, 1, 1], zDirect='001')\norient = box['orient']\nbox_size = box['box_size']\n</code></pre>"},{"location":"model/#thmd.model.box_tool.box_orient","title":"<code>box_orient(zDirect: str = '001', xDirect: str = None) -&gt; List[List]</code>","text":"<p>Generate orirentations of simulation box. Args:     zDirect (str): specify the direction of z-side. Defaults to '001', mean nothing is happen.     xDirect (str): specify the direction of z-side.  Defaults to None.</p> <p>Returns:</p> <ul> <li> <code>orient</code> (              <code>list[list]</code> )          \u2013            <p>list-of-vectors of 3 directional vectors.</p> </li> </ul>"},{"location":"model/#thmd.model.combining_LJ_interface","title":"<code>combining_LJ_interface</code>","text":"<p>Functions:</p> <ul> <li> <code>pair_LJ</code>             \u2013              <p>compute parameters (epsilon &amp; sigma) of LJ potential at interface</p> </li> </ul>"},{"location":"model/#thmd.model.combining_LJ_interface.pair_LJ","title":"<code>pair_LJ(dict_group1, dict_group2, unit_style, combining_rule='geometric', pair_style='lj/cut')</code>","text":"<p>compute parameters (epsilon &amp; sigma) of LJ potential at interface Note that in LAMMPS: 'Lorentz_Berthelot'='arithmetic'   https://tinyurl.com/yzpwg2hs</p> <p>Parameters:</p> <ul> <li> <code>dict_group1,</code>               (<code>dict_group2</code>)           \u2013            <p>Dicts contain sig &amp; eps of each element of 2 surfaces. Must contain keys: 'atom_name', 'type', 'sigma', 'epsilon'</p> </li> <li> <code>unit_style</code>           \u2013            <p>'real' or 'metal'</p> </li> </ul> <pre><code>combining_rule='arithmetic' (also 'Lorentz_Berthelot')\n            + 'arithmetic'/'Lorentz_Berthelot'\n            + 'geometric'\n            + 'sixthpower'\n        pair_style='lj/cut': pair_style of Lammps  lj/cut/coul/long\n        external_interaction: require\n</code></pre> Return <p>list-of-string: contain pair_coeffs for LAMMPS</p> Notes <p>energy unit is kcal/mol, but in OPLSaa of Foyer is kJ/mol. types in 2 dict must either completely different or indentical</p> <p>Examples: PMMA/h_BN interface <pre><code>dict_group1 = {'element':['CT','CT','CT','CT','HC','HC','C_2','O_2','OS','CT','HC'],\n        'atom_name':['opls_135','opls_136','opls_137','opls_139','opls_140','opls_282','opls_465','opls_466','opls_467','opls_468','opls_469'],\n        'type':[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],\n        'sigma': [3.5, 3.5, 3.5, 3.5, 2.5, 2.42, 3.75, 2.96, 3.0, 3.5, 2.42],\n        'epsilon':[0.066, 0.066, 0.066, 0.066, 0.03, 0.015, 0.105, 0.21, 0.17, 0.066, 0.015]}\ndict_group2 = {'element':['B','N'],\n                'atom_name':['B','N'],\n                'type':[12,13],\n                'sigma': [3.453, 3.365],\n                'epsilon':[0.094988, 0.1448671]}\ncombining_LJ(dict_group1, dict_group2, combining_rule='Lorentz_Berthelot', pair_style='lj/cut/coul/long')\n</code></pre></p>"},{"location":"model/#thmd.model.coord_rotation","title":"<code>coord_rotation</code>","text":"<p>Classes:</p> <ul> <li> <code>CoordTransform</code>           \u2013            <p>We can express a rotation using direction-cosines-matrix (DCM) or Euler-angles (phi,theta,psi)</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>rot1axis</code>             \u2013              <p>Rotate array of points about 1 axis</p> </li> <li> <code>check_right_hand</code>             \u2013              <p>check right_hand_rule orthogonal of 3 vectors</p> </li> <li> <code>guess_right_hand</code>             \u2013              <p>give 2 vectors, then guess the third vector that satisfy right_hand_rule</p> </li> <li> <code>cartesian2spherical</code>             \u2013              <p>Convert cartesian coordinates to Spherical coordinates</p> </li> </ul>"},{"location":"model/#thmd.model.coord_rotation.CoordTransform","title":"<code>CoordTransform(old_orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], new_orient=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])</code>","text":"<p>We can express a rotation using direction-cosines-matrix (DCM) or Euler-angles (phi,theta,psi)</p> <p>Parameters:</p> <ul> <li> <code>old_orient</code>               (<code>array / list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array/list, contains 3 mutully orthotropic unit vectors of the OLD basis</p> </li> <li> <code>new_orient</code>               (<code>array / list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>3x3 array/list, contains 3 mutully orthotropic unit vectors of the NEW basis             (all input vector will be normalized to unit vectors)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code> (              <code>obj</code> )          \u2013            <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>oldAxis = array([[1, 0, 0], [0, 1, 0], [0, 0, 1]])\nnewAxis = array([[1, -1, 0], [1, 1, -2], [1, 1, 1]])\nBT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\n</code></pre> \"Refs\" <ol> <li>Bower, Allan F. Applied Mechanics of Solids. CRC Press, 2009. page 711</li> <li>https://link.aps.org/doi/10.1103/PhysRevB.92.180102</li> <li>https://en.wikipedia.org/wiki/Euler_angles</li> </ol> <p>Methods:</p> <ul> <li> <code>direction_cosine_matrix</code>             \u2013              <p>Calculate direction-cosines-matrix (DCM) between 2 coordinates systems</p> </li> <li> <code>rotation_matrix</code>             \u2013              <p>Calculate Rotation-matrix (R) as transpose of DCM</p> </li> <li> <code>EA2ROT</code>             \u2013              <p>Calculate Rotation_Matrix Euler Angles (EA) between 2 coordinates systems (ZXZ proper Euler angles)</p> </li> <li> <code>euler_angle</code>             \u2013              <p>Calculate Euler Angles (EA) between 2 coordinates systems (intrinsic ZXZ proper Euler angles)</p> </li> <li> <code>euler_angle_PSpincal</code>             \u2013              <p>Calculate Euler Angles (EA) between 2 coordinates systems (proper Eulerian angles)</p> </li> <li> <code>rotate_3d</code>             \u2013              <p>Rotate a set of points (or set of vectors) from a OLD-coords to NEW-coords</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>old_orient</code>           \u2013            </li> <li> <code>new_orient</code>           \u2013            </li> <li> <code>DCM</code>           \u2013            </li> <li> <code>ROT</code>           \u2013            </li> <li> <code>EA</code>           \u2013            </li> </ul>"},{"location":"model/#thmd.model.coord_rotation.CoordTransform.old_orient","title":"<code>old_orient = np.asarray(old_orient)</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.coord_rotation.CoordTransform.new_orient","title":"<code>new_orient = np.asarray(new_orient)</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.coord_rotation.CoordTransform.DCM","title":"<code>DCM = None</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.coord_rotation.CoordTransform.ROT","title":"<code>ROT = None</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.coord_rotation.CoordTransform.EA","title":"<code>EA = None</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.coord_rotation.CoordTransform.direction_cosine_matrix","title":"<code>direction_cosine_matrix()</code>","text":"<p>Calculate direction-cosines-matrix (DCM) between 2 coordinates systems</p> <p>Returns:</p> <ul> <li> <code>Q</code>          \u2013            <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\nQ = BT.direction_cosine_matrix()\n</code></pre>"},{"location":"model/#thmd.model.coord_rotation.CoordTransform.rotation_matrix","title":"<code>rotation_matrix()</code>","text":"<p>Calculate Rotation-matrix (R) as transpose of DCM By Cao Thang, Apr 2019,  Update: May2020</p>"},{"location":"model/#thmd.model.coord_rotation.CoordTransform.EA2ROT","title":"<code>EA2ROT(euler_angle, unit='rad')</code>","text":"<p>Calculate Rotation_Matrix Euler Angles (EA) between 2 coordinates systems (ZXZ proper Euler angles) This is just for testing, since we dont know whether input angles yield orthogonal axis or not</p> <p>Parameters:</p> <ul> <li> <code>euler_angle</code>               (<code>list</code>)           \u2013            <p>1x3 array/list (phi,theta,psi) in Rad or Deg</p> </li> <li> <code>unit</code>               (<code>str</code>, default:                   <code>'rad'</code> )           \u2013            <p>'rad' or 'deg'      (default is rad)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Q</code> (              <code>array</code> )          \u2013            <p>3x3 array, the rotation matrix or matrix of direction cosines</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thmd.CoordTransform()\nDCM = BT.EulerAngle(euler_angle=[90,], unit='deg')\n</code></pre> Notes <p>don't use arctan2()</p>"},{"location":"model/#thmd.model.coord_rotation.CoordTransform.euler_angle","title":"<code>euler_angle(unit='rad')</code>","text":"<p>Calculate Euler Angles (EA) between 2 coordinates systems (intrinsic ZXZ proper Euler angles) https://en.wikipedia.org/wiki/Euler_angles#Definition_by_intrinsic_rotations https://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.transform.Rotation.as_euler.html#r72d546869407-1</p> <p>Parameters:</p> <ul> <li> <code>unit='rad'</code>           \u2013            <p>'rad' or 'deg'      (default is rad)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Angle</code>          \u2013            <p>1x3 array (phi,theta,psi) in Rad  (apply intrinsic ZXZ proper Euler)</p> </li> </ul> <p>Examples:</p> <p>BT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis) phi,theta,psi = BT.EulerAngle(unit='deg')</p> Notes <ul> <li>don't use arctan2()</li> <li>Rotation Matrix is as to tranpose of DCM, use Rotation Matrix to compute EA</li> <li>To avoid devide by zero, we use 1e-64 instead of 0.</li> </ul>"},{"location":"model/#thmd.model.coord_rotation.CoordTransform.euler_angle_PSpincal","title":"<code>euler_angle_PSpincal(euler_order='zxz', unit='rad', tol=1e-07)</code>","text":"<p>Calculate Euler Angles (EA) between 2 coordinates systems (proper Eulerian angles)</p> <p>Parameters:</p> <ul> <li> <code>unit</code>           \u2013            <p>'rad', 'deg'      (default is rad)</p> </li> <li> <code>euler_order='zxz'</code>           \u2013            <p>rotation order, lowercase [\"zyx\",\"zxy\",\"yxz\",\"xzy\",\"xyz\",\"yzx\",\"zyz\",\"zxz\",\"yxy\",\"yzy\",\"xyx\",\"xzx\"]</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Angle</code>          \u2013            <p>1x3 array (phi,theta,psi) in Rad  (apply extrinsic ZXZ proper Euler)</p> </li> </ul> Notes <ul> <li>this module may define psi as phi, and vice versa. So becareful</li> <li>should not use PSpincalc, since it produce unknown value?</li> </ul> \"Refs\" <p>[1] navpy not use 'ZXZ': https://navpy.readthedocs.io/en/latest/code_docs/coordinate_transformations.html [2] use this https://pypi.org/project/PSpincalc/ [3] https://github.com/tuxcell/PSpincalc/blob/master/PSpincalc/PSpincalc.py     Ex: https://github.com/tuxcell/PSpincalc/blob/master/examples/examplesPSpincalc.ipynb</p>"},{"location":"model/#thmd.model.coord_rotation.CoordTransform.rotate_3d","title":"<code>rotate_3d(points)</code>","text":"<p>Rotate a set of points (or set of vectors) from a OLD-coords to NEW-coords</p> <p>Parameters:</p> <ul> <li> <code>points</code>           \u2013            <p>Nx3 array, contain coords in OLD coordinates systems</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>points</code>          \u2013            <p>Nx3 array, contain coords in NEW coordinates systems</p> </li> </ul> <p>Examples:</p> <pre><code>BT = thmd.CoordTransform(old_orient=oldAxis, new_orient=newAxis)\nnewP = BT.rotate_3d(P)\n</code></pre>"},{"location":"model/#thmd.model.coord_rotation.rot1axis","title":"<code>rot1axis(P, theta, axis='X')</code>","text":"<p>Rotate array of points about 1 axis</p> <p>Parameters:</p> <ul> <li> <code>P</code>               (<code> </code>)           \u2013            <p>Nx3 array, contain input poits</p> </li> <li> <code>theta</code>               (<code> </code>)           \u2013            <p>the rotation angle in Degree</p> </li> <li> <code>axis</code>               (<code> </code>, default:                   <code>'X'</code> )           \u2013            <p>Rotation axis</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>outP</code>          \u2013            <p>Nx3 array, contain points after rotation</p> </li> </ul>"},{"location":"model/#thmd.model.coord_rotation.check_right_hand","title":"<code>check_right_hand(list_3vec=[[1, 0, 0], [0, 1, 0], [0, 0, 1]])</code>","text":"<p>check right_hand_rule orthogonal of 3 vectors</p>"},{"location":"model/#thmd.model.coord_rotation.guess_right_hand","title":"<code>guess_right_hand(list_2vec=[[1, 0, 0], [0, 1, 0]])</code>","text":"<p>give 2 vectors, then guess the third vector that satisfy right_hand_rule</p>"},{"location":"model/#thmd.model.coord_rotation.cartesian2spherical","title":"<code>cartesian2spherical(xyz)</code>","text":"<p>Convert cartesian coordinates to Spherical coordinates</p> <p>Parameters:</p> <ul> <li> <code>xyz</code>               (<code>array</code>)           \u2013            <p>Mx3 array contain Cartesian coordinates (X, Y, Z)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>shpCoord</code> (              <code>array</code> )          \u2013            <p>Mx3 array contain Spherical coordinates (R, theta, phi). Also (radial distance, polar angle, azimuthal(longitude) angle)</p> </li> </ul> Notes <ol> <li>The polar(theta) angle defined from from Z-axis down (zero at the North pole to 180\u00b0 at the South pole)</li> <li> <p>adapted from this</p> </li> <li> <p>There are many conventions that angles can be</p> <ul> <li>In geography, angles are in latitude/longitude or elevation/azimuthal form, polar angle is called <code>latitude</code>, measuze from XY-plane (ranges from -90\u00b0 at the south pole to 90\u00b0 at the north pole, with 0\u00b0 at the Equator)</li> </ul> <p></p> <ul> <li>In mathematics and physics, polar angle measured from Z-axis (zero at the North pole to 180\u00b0 at the South pole)</li> </ul> <p></p> <ul> <li>In <code>scipy</code>, polar angle is defined as Colatitude, which is a non-negative quantity, ranging from zero at the North pole to 180\u00b0 at the South pole (same as commonly used in mathematics and physics)</li> </ul> </li> </ol>"},{"location":"model/#thmd.model.forcefield_info","title":"<code>forcefield_info</code>","text":"<p>This module contains some data for various ForceField. Data obtained from simulation</p> <p>Classes:</p> <ul> <li> <code>EAM</code>           \u2013            <p>Create an Object (class) of Potential, contain some pre-setup information</p> </li> <li> <code>ReaxFF</code>           \u2013            <p>Create an Object (class) of Potential, contain some pre-setup information</p> </li> </ul>"},{"location":"model/#thmd.model.forcefield_info.EAM","title":"<code>EAM(atom_symbol, force_field, model_type='BULK', zDirect='001', thickness=20)</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information</p> <pre><code>    - Cu: Mishin2001,  Mendelev2008, Foiles1986\n</code></pre> <ul> <li>Al: Laird2000,  Mishin1999,  Mendelev2008,  LiuEA2004, Sheng2011</li> <li>V:  Olsson2009</li> </ul> <p>Parameters:</p> <ul> <li> <code>atom_symbol</code>               (<code>str</code>)           \u2013            <p>define element, e.g., 'Al', 'Cu',...</p> </li> <li> <code>force_field</code>               (<code>str</code>)           \u2013            <p>the name of potential 'Cu' : 'Mishin-2001'; 'Foiles-1986';... 'Al' : 'Mishin-1999'; 'Sheng-2011';...</p> </li> <li> <code>model_type</code>               (<code>str</code>, default:                   <code>'BULK'</code> )           \u2013            <p>type of model (BULK or PLATE)</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>define the crystal orient along the z-direction simulation box, e,g., '001'/ '110'/ '111'</p> </li> <li> <code>thickness</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>define thickness in case <code>model_type=PALTE</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>obj</code>          \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>atom_symbol</code>               (<code>str</code>)           \u2013            <p>element</p> </li> <li> <code>force_field</code>               (<code>str</code>)           \u2013            <p>forcefield name.</p> </li> <li> <code>cutoff</code>               (<code>float</code>)           \u2013            <p>return cutoff of forcefield.</p> </li> <li> <code>thermal_coeff</code>               (<code>list</code>)           \u2013            <p>return values thermal expansion coefficients of input Structure</p> </li> </ul> <p>Stored DATA (these data are compute from several simulations, or from papers)</p> <p>Methods:</p> <ul> <li> <code>lattice_constant</code>             \u2013              <p>Compute lattice constant at a specific temperature T.</p> </li> <li> <code>atomic_volume_FCC</code>             \u2013              <p>Compute atomic volume at a specific temperature T.</p> </li> <li> <code>melt_barrier</code>             \u2013              <p>Compute free energy barrier/atom of melting. For a system of N atoms  \\(F = f*N^(2/3)\\) , then barrier/atom  \\(f = F/N^(2/3)\\). This method return f(T)</p> </li> <li> <code>estimate_FCCUBIC_liqsol</code>             \u2013              <p>Estimate value of FCCUBIC parameter in bulk solid/liquid at a specific temperature T.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>coeff_FCCUBIC_liqsol_coexist</code>           \u2013            </li> <li> <code>coeff_FCCUBIC_tail_solid</code>           \u2013            </li> <li> <code>coeff_FCCUBIC_tail_liquid</code>           \u2013            </li> <li> <code>atom_symbol</code>           \u2013            </li> <li> <code>force_field</code>           \u2013            </li> <li> <code>thermal_coeff</code>           \u2013            </li> <li> <code>cutoff</code>           \u2013            </li> <li> <code>melt_barrier_coeff</code>           \u2013            </li> </ul>"},{"location":"model/#thmd.model.forcefield_info.EAM.coeff_FCCUBIC_liqsol_coexist","title":"<code>coeff_FCCUBIC_liqsol_coexist = [-0.000467305786, 0.88174401]</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.coeff_FCCUBIC_tail_solid","title":"<code>coeff_FCCUBIC_tail_solid = [-0.0017082985, 1.80537817]</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.coeff_FCCUBIC_tail_liquid","title":"<code>coeff_FCCUBIC_tail_liquid = [-9.33394967e-06, 0.608209715]</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.atom_symbol","title":"<code>atom_symbol = atom_symbol</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.force_field","title":"<code>force_field = force_field</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.thermal_coeff","title":"<code>thermal_coeff = D[thermal_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.cutoff","title":"<code>cutoff = Rcut</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.melt_barrier_coeff","title":"<code>melt_barrier_coeff = melt_barrier[melt_barrier_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.EAM.lattice_constant","title":"<code>lattice_constant(temp)</code>","text":"<p>Compute lattice constant at a specific temperature T.</p> <p>Parameters:</p> <ul> <li> <code>temp</code>               (<code>float</code>)           \u2013            <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>a</code> (              <code>float</code> )          \u2013            <p>lattice constant as input temperature.</p> </li> </ul>"},{"location":"model/#thmd.model.forcefield_info.EAM.atomic_volume_FCC","title":"<code>atomic_volume_FCC(temp)</code>","text":"<p>Compute atomic volume at a specific temperature T.</p> <p>Parameters:</p> <ul> <li> <code>temp</code>               (<code>float</code>)           \u2013            <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>V</code> (              <code>float</code> )          \u2013            <p>atomic volume (volume/atom) as input temperature.</p> </li> </ul>"},{"location":"model/#thmd.model.forcefield_info.EAM.melt_barrier","title":"<code>melt_barrier(temp)</code>","text":"<p>Compute free energy barrier/atom of melting. For a system of N atoms  \\(F = f*N^(2/3)\\) , then barrier/atom  \\(f = F/N^(2/3)\\). This method return f(T)</p> <p>Parameters:</p> <ul> <li> <code>temp</code>               (<code>float</code>)           \u2013            <p>input temperature.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>barrier</code> (              <code>float</code> )          \u2013            <p>free energy barrier/atom of melting as input temperature.</p> </li> </ul>"},{"location":"model/#thmd.model.forcefield_info.EAM.estimate_FCCUBIC_liqsol","title":"<code>estimate_FCCUBIC_liqsol(temp)</code>","text":"<p>Estimate value of FCCUBIC parameter in bulk solid/liquid at a specific temperature T.</p>"},{"location":"model/#thmd.model.forcefield_info.ReaxFF","title":"<code>ReaxFF(atom_symbol, force_field, model_type='BULK', zDirect='001')</code>","text":"<p>Create an Object (class) of Potential, contain some pre-setup information</p> <p>Methods:</p> <ul> <li> <code>lattice_constant</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>atom_symbol</code>           \u2013            </li> <li> <code>force_field</code>           \u2013            </li> <li> <code>thermal_coeff</code>           \u2013            </li> <li> <code>cutoff</code>           \u2013            </li> <li> <code>melt_barrier_coeff</code>           \u2013            </li> </ul>"},{"location":"model/#thmd.model.forcefield_info.ReaxFF.atom_symbol","title":"<code>atom_symbol = atom_symbol</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.ReaxFF.force_field","title":"<code>force_field = force_field</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.ReaxFF.thermal_coeff","title":"<code>thermal_coeff = D[thermal_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.ReaxFF.cutoff","title":"<code>cutoff = Rcut</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.ReaxFF.melt_barrier_coeff","title":"<code>melt_barrier_coeff = melt_barrier[melt_barrier_key]</code>  <code>instance-attribute</code>","text":""},{"location":"model/#thmd.model.forcefield_info.ReaxFF.lattice_constant","title":"<code>lattice_constant(Temp)</code>","text":""},{"location":"model/#thmd.model.polymer_mbuild","title":"<code>polymer_mbuild</code>","text":"<p>This module contains classes and functions to build models of atomic polymers See this Python package: [1] mBuild: https://mbuild.mosdef.org/en/stable/</p> <p>See the files: D:\\code\\code_simulate\\polymer_c21_pickup_hBN_PMMA ef_using_mBuild_foyer.ipynb</p> NOTEs <ol> <li>Due to mbuild cannot be installed with python 3.10, so import this package in functions to avoid checking in thmd</li> </ol> <p>Functions:</p> <ul> <li> <code>PMMA_chain</code>             \u2013              <p>build polyPMMA from monomers</p> </li> <li> <code>PVC_chain</code>             \u2013              </li> <li> <code>packing_lammps</code>             \u2013              <p>Packing polymer chains into box, and write LAMMPS file</p> </li> </ul>"},{"location":"model/#thmd.model.polymer_mbuild.PMMA_chain","title":"<code>PMMA_chain(chain_len)</code>","text":"<p>build polyPMMA from monomers</p> <p>Parameters:</p> <ul> <li> <code>chain_len</code>               (<code>int</code>)           \u2013            <p>number of monomers in each polymer = degree of polymerization</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>chain</code> (              <code>compound</code> )          \u2013            <p>polymer chain</p> </li> </ul>"},{"location":"model/#thmd.model.polymer_mbuild.PVC_chain","title":"<code>PVC_chain(chain_len)</code>","text":""},{"location":"model/#thmd.model.polymer_mbuild.packing_lammps","title":"<code>packing_lammps(chain, chain_num, density=None, box_size=None, forcefield_name=None, forcefield_files=None, atom_style='full', unit_style='metal', combining_rule='geometric', file_name='polymer.dat')</code>","text":"<p>Packing polymer chains into box, and write LAMMPS file Packing based on either density or box_size.</p> <p>Parameters:</p> <ul> <li> <code>chain</code>               (<code>compound</code>)           \u2013            <p>polymer chain</p> </li> <li> <code>chain_num</code>               (<code>int</code>)           \u2013            <p>number of chains to be packed.</p> </li> <li> <code>density</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>density, unit in kg/m3 (= 1e-3 g/cm3)</p> </li> <li> <code>box_size</code>               (<code>list</code>, default:                   <code>None</code> )           \u2013            <p>box_size = [3,3,3]</p> </li> <li> <code>forcefield_name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>should be 'oplsaa'.</p> </li> <li> <code>forcefield_files</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>path to the *.xml file.</p> </li> <li> <code>atom_style</code>               (<code>str</code>, default:                   <code>'full'</code> )           \u2013            <p>atom_style of LAMMPS.</p> </li> <li> <code>unit_style</code>               (<code>str</code>, default:                   <code>'metal'</code> )           \u2013            <p>can be 'metal'/'real'/'lj'</p> </li> </ul>"},{"location":"model/#thmd.model.polymer_pysimm","title":"<code>polymer_pysimm</code>","text":"<p>This module contains classes to build models of atomic polymers See this Python package: [1] pysimm: A python package for simulation of molecular systems, 10.1016/j.softx.2016.12.002 source code: https://github.com/polysimtools/pysimm</p>"},{"location":"model_box_tool/","title":"Model box tool","text":""},{"location":"model_box_tool/#thmd.model.box_tool","title":"<code>thmd.model.box_tool</code>","text":"<p>Functions:</p> <ul> <li> <code>add_periodic_image</code>             \u2013              <p>Function to add \"Periodic Images\" of atoms at Periodic Boundaries (with a specific cutoff distance)</p> </li> <li> <code>wrap_coord_PBC</code>             \u2013              <p>Function to wrap atom positions at Periodic Boundaries</p> </li> <li> <code>shell_fcc</code>             \u2013              <p>Compute nearest-neighbor shells for FCC crystal</p> </li> <li> <code>box_generate</code>             \u2013              <p>Generate orientation and dimensions of simulation box.</p> </li> <li> <code>box_orient</code>             \u2013              <p>Generate orirentations of simulation box.</p> </li> </ul>"},{"location":"model_box_tool/#thmd.model.box_tool.add_periodic_image","title":"<code>add_periodic_image(points: pd.DataFrame | np.ndarray | list, box: np.ndarray, bound_cond: list = [1, 1, 1], cutoff: float = 6.5) -&gt; pd.DataFrame</code>","text":"<p>Function to add \"Periodic Images\" of atoms at Periodic Boundaries (with a specific cutoff distance) By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>2d-list np.array pd.DataFrame</code>)           \u2013            <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>               (<code>3d-list array</code>)           \u2013            <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> <li> <code>cutoff</code>               (<code>float</code>, default:                   <code>6.5</code> )           \u2013            <p>Cutoff distance</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>contains original atoms and image atoms with remark colum df['image'].</p> </li> </ul> <p>Examples:</p> <p>```py</p> <pre><code>df = add_periodic_image(P, box, bound_cond=[1 1 0], cutoff=5)\n    ```\n</code></pre>"},{"location":"model_box_tool/#thmd.model.box_tool.wrap_coord_PBC","title":"<code>wrap_coord_PBC(points: pd.DataFrame | np.ndarray | list, box: np.ndarray, bound_cond: list = [1, 1, 1]) -&gt; pd.DataFrame</code>","text":"<p>Function to wrap atom positions at Periodic Boundaries By Thang, June 2019 (update 2022)</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>2d-list np.array pd.DataFrame</code>)           \u2013            <p>Mx3 Matrix contain positions of atoms before Wrapping</p> </li> <li> <code>box</code>               (<code>3d-list array</code>)           \u2013            <p>3x2 Matrix contain simulation box bounds</p> </li> <li> <code>bound_cond</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>1x3 list contains convention of Peridic bounds(ex: bound_cond = [1 1 1])</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>contains atom positions.</p> </li> </ul> <p>Examples:         <code>py     df = wrap_coord_PBC(P, box, bound_cond=[1 1 0], cutoff=5)</code></p>"},{"location":"model_box_tool/#thmd.model.box_tool.shell_fcc","title":"<code>shell_fcc(a)</code>","text":"<p>Compute nearest-neighbor shells for FCC crystal</p> <p>Parameters:</p> <ul> <li> <code>a</code>               (<code>float</code>)           \u2013            <p>lattice constant</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>shell</code> (              <code>list</code> )          \u2013            <p>5 nearest-neighbor shells</p> </li> </ul>"},{"location":"model_box_tool/#thmd.model.box_tool.box_generate","title":"<code>box_generate(box_size: list = [1, 1, 1], zDirect: str = '001', xDirect: str = None) -&gt; Dict[str, List]</code>","text":"<p>Generate orientation and dimensions of simulation box.</p> <p>Parameters:</p> <ul> <li> <code>box_size</code>               (<code>list</code>, default:                   <code>[1, 1, 1]</code> )           \u2013            <p>dimension of box on each side as in [100] direction</p> </li> <li> <code>zDirect</code>               (<code>str</code>, default:                   <code>'001'</code> )           \u2013            <p>specify the direction of z-side. Defaults to '001', mean nothing is happen.</p> </li> <li> <code>xDirect</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>specify the direction of z-side.  Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>box</code> (              <code>dict</code> )          \u2013            <p>dictionary contain orientation and box_size - 'orient' (list[list]): list-of-vectors of 3 directional vectors. - 'box_size' (list[list]): dimension of box on each side.</p> </li> </ul> <p>Examples:</p> <pre><code>box = box_generate(box_size=[1, 1, 1], zDirect='001')\norient = box['orient']\nbox_size = box['box_size']\n</code></pre>"},{"location":"model_box_tool/#thmd.model.box_tool.box_orient","title":"<code>box_orient(zDirect: str = '001', xDirect: str = None) -&gt; List[List]</code>","text":"<p>Generate orirentations of simulation box. Args:     zDirect (str): specify the direction of z-side. Defaults to '001', mean nothing is happen.     xDirect (str): specify the direction of z-side.  Defaults to None.</p> <p>Returns:</p> <ul> <li> <code>orient</code> (              <code>list[list]</code> )          \u2013            <p>list-of-vectors of 3 directional vectors.</p> </li> </ul>"},{"location":"plot/","title":"plot","text":""},{"location":"plot/#thmd.plot","title":"<code>thmd.plot</code>","text":"<p>This module provides functions and class to produce publication-quality figures. The main idea is to create a handy class which setup all necessary parameters for plotting, and then just call its methods to produce the publication-quality figures.</p> <p>The core class is the <code>Plotter</code>, which is built on top of <code>matplotlib.pyplot</code>. The <code>Plotter</code>, therefore, has all useful functions from <code>matplotlib.pyplot</code>.</p> <p>Assume we have a data frame <code>df</code>: <pre><code>import numpy as np\nimport polars as pl\nx = np.arange(0, 1000)\ndf = pl.DataFrame({'x': x, 'y': x**2})\n</code></pre></p> <p>Then, use the <code>Plotter().plt</code> to plot the data as a normal <code>matplotlib.pyplot</code> object. Adapt all functions from <code>matplotlib.pyplot</code>. <pre><code>from thmd.plot import Plotter\nplt = Plotter(style='thang').plt\nplt.plot(df['x'], df['y'])\nplt.show()\n</code></pre></p> Refs <ol> <li>Customizing Matplotlib with style sheets and rcParams</li> <li>Figure size Elsevier<ul> <li>Single column: W = 90 mm (~3.5 in). H = W*\u2158 = 2.8</li> <li>Double column: W = 190 mm (~7.5 in). H = 6</li> </ul> </li> </ol> <p>Classes:</p> <ul> <li> <code>Plotter</code>           \u2013            <p>Class to produce publication-quality figures with matplotlib.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>custom_styles</code>             \u2013              <p>style for matplotlib</p> </li> </ul>"},{"location":"plot/#thmd.plot.Plotter","title":"<code>Plotter()</code>","text":"<p>Class to produce publication-quality figures with matplotlib.</p> <p>Parameters:</p> <ul> <li> <code>style</code>               (<code>str</code>)           \u2013            <p>the plotting style.</p> </li> </ul> <p>Examples:</p> <pre><code>from thmd.plot import Plotter\nplt = Plotter().plt\nplt.plot(df['x'], df['y'])\n</code></pre> <p>Methods:</p> <ul> <li> <code>get_plt</code>             \u2013              <p>Shortcut to the <code>matplotlib.pyplot</code> object.</p> </li> <li> <code>set_minor_locator</code>             \u2013              <p>Set minor locator for axes</p> </li> <li> <code>get_PdfPages</code>             \u2013              <p>shortcut to <code>matplotlib.backends.backend_pdf.PdfPages</code>.</p> </li> <li> <code>avail_styles</code>             \u2013              <p>List all available styles.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>COLOR</code>           \u2013            </li> <li> <code>MARKER</code>           \u2013            </li> <li> <code>LINE</code>           \u2013            </li> <li> <code>info</code>           \u2013            </li> </ul>"},{"location":"plot/#thmd.plot.Plotter.COLOR","title":"<code>COLOR = _COLOR</code>  <code>instance-attribute</code>","text":""},{"location":"plot/#thmd.plot.Plotter.MARKER","title":"<code>MARKER = _MARKER</code>  <code>instance-attribute</code>","text":""},{"location":"plot/#thmd.plot.Plotter.LINE","title":"<code>LINE = _LINE</code>  <code>instance-attribute</code>","text":""},{"location":"plot/#thmd.plot.Plotter.info","title":"<code>info</code>  <code>property</code>","text":""},{"location":"plot/#thmd.plot.Plotter.get_plt","title":"<code>get_plt(style: str = 'thang')</code>","text":"<p>Shortcut to the <code>matplotlib.pyplot</code> object.</p>"},{"location":"plot/#thmd.plot.Plotter.set_minor_locator","title":"<code>set_minor_locator(ax: object, xminor=1, yminor=1)</code>","text":"<p>Set minor locator for axes</p>"},{"location":"plot/#thmd.plot.Plotter.get_PdfPages","title":"<code>get_PdfPages()</code>","text":"<p>shortcut to <code>matplotlib.backends.backend_pdf.PdfPages</code>.</p>"},{"location":"plot/#thmd.plot.Plotter.avail_styles","title":"<code>avail_styles()</code>","text":"<p>List all available styles.</p>"},{"location":"plot/#thmd.plot.custom_styles","title":"<code>custom_styles()</code>","text":"<p>style for matplotlib</p>"},{"location":"qflow/","title":"qflow","text":"<p>Workflow for <code>qsub</code> system, using DPDispatcher</p>"},{"location":"qflow/#thmd.qflow","title":"<code>thmd.qflow</code>","text":"<p>Modules:</p> <ul> <li> <code>help_function</code>           \u2013            <p>Define support functions for qflow package.</p> </li> <li> <code>machine_unist</code>           \u2013            </li> <li> <code>qsub_script</code>           \u2013            <p>Define the template for qsub job submission.</p> </li> <li> <code>resource_unist</code>           \u2013            </li> </ul>"},{"location":"qflow/#thmd.qflow.help_function","title":"<code>help_function</code>","text":"<p>Define support functions for qflow package.</p> <p>Functions:</p> <ul> <li> <code>read_nodes</code>             \u2013              <p>Read node list from file.</p> </li> <li> <code>format_ignore_string</code>             \u2013              <p>Format <code>qsub_string</code> for ignore nodes.</p> </li> <li> <code>format_select_string</code>             \u2013              <p>Format <code>qsub_string</code> for selected nodes.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.help_function.read_nodes","title":"<code>read_nodes(file_name: str) -&gt; list</code>","text":"<p>Read node list from file.     Support delimiter: '|', ',', ';', ':', ' ', ' '</p> <pre><code>Args:\n    file_name (str): File name.\n\nReturns:\n    list: List of unique nodes.\n</code></pre>"},{"location":"qflow/#thmd.qflow.help_function.format_ignore_string","title":"<code>format_ignore_string(nodes: list) -&gt; str</code>","text":"<p>Format <code>qsub_string</code> for ignore nodes.</p>"},{"location":"qflow/#thmd.qflow.help_function.format_select_string","title":"<code>format_select_string(nodes: list) -&gt; str</code>","text":"<p>Format <code>qsub_string</code> for selected nodes.</p>"},{"location":"qflow/#thmd.qflow.machine_unist","title":"<code>machine_unist</code>","text":"<p>Functions:</p> <ul> <li> <code>Tachyon</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>Eagle</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>Lion</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>Leopard</code>             \u2013              <p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> </li> <li> <code>CanCentosGpu</code>             \u2013              <p>Define Machine for running jobs on CAN cluster at UNIST.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>sge_template</code>           \u2013            </li> </ul>"},{"location":"qflow/#thmd.qflow.machine_unist.sge_template","title":"<code>sge_template = {'context_type': 'SSHContext', 'batch_type': 'SGE', 'local_root': './', 'remote_root': '/home1/p001cao/work/w24_tmp', 'remote_profile': {'hostname': '10.0.7.53', 'username': 'p001cao', 'password': 'p001cao', 'port': 2022, 'timeout': 20}}</code>  <code>module-attribute</code>","text":""},{"location":"qflow/#thmd.qflow.machine_unist.Tachyon","title":"<code>Tachyon(remote_path: str = '/home1/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/home1/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.machine_unist.Eagle","title":"<code>Eagle(remote_path: str = '/uwork/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/uwork/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.machine_unist.Lion","title":"<code>Lion(remote_path: str = '/uwork/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/uwork/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.machine_unist.Leopard","title":"<code>Leopard(remote_path: str = '/uwork/p001cao/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/uwork/p001cao/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.machine_unist.CanCentosGpu","title":"<code>CanCentosGpu(remote_path: str = '/home/tha/work/w24_alff')</code>","text":"<p>Define Machine for running jobs on CAN cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>remote_path</code>               (<code>str</code>, default:                   <code>'/home/tha/work/w24_alff'</code> )           \u2013            <p>Remote working folder.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.qsub_script","title":"<code>qsub_script</code>","text":"<p>Define the template for qsub job submission.</p> <p>Functions:</p> <ul> <li> <code>qsub_sge_job</code>             \u2013              <p>Return the example script for submiting SGE job.</p> </li> <li> <code>winBAT_submit_dispatcher</code>             \u2013              <p>Return the windows batch script for submitting DP dispatcher.</p> </li> <li> <code>winBAT_cmd</code>             \u2013              <p>Return the example script for running command in cmd.</p> </li> <li> <code>winBAT_wsl</code>             \u2013              <p>Return the example script for running command in cmd.</p> </li> <li> <code>python_dispatcher</code>             \u2013              <p>Return the example script for using dpdispatcher.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.qsub_script.qsub_sge_job","title":"<code>qsub_sge_job() -&gt; str</code>","text":"<p>Return the example script for submiting SGE job.</p>"},{"location":"qflow/#thmd.qflow.qsub_script.winBAT_submit_dispatcher","title":"<code>winBAT_submit_dispatcher(conda_env: str = None) -&gt; str</code>","text":"<p>Return the windows batch script for submitting DP dispatcher.</p>"},{"location":"qflow/#thmd.qflow.qsub_script.winBAT_cmd","title":"<code>winBAT_cmd(command: str, conda_env: str = 'py11') -&gt; str</code>","text":"<p>Return the example script for running command in cmd.</p>"},{"location":"qflow/#thmd.qflow.qsub_script.winBAT_wsl","title":"<code>winBAT_wsl(command: str, conda_env: str = 'py11') -&gt; str</code>","text":"<p>Return the example script for running command in cmd.</p>"},{"location":"qflow/#thmd.qflow.qsub_script.python_dispatcher","title":"<code>python_dispatcher() -&gt; str</code>","text":"<p>Return the example script for using dpdispatcher.</p>"},{"location":"qflow/#thmd.qflow.resource_unist","title":"<code>resource_unist</code>","text":"<p>Functions:</p> <ul> <li> <code>Tachyon_lammps_ib</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only InfiniBand nodes.</p> </li> <li> <code>Tachyon_lammps_tcp</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only use TCP.</p> </li> <li> <code>Tachyon_gpaw_ib</code>             \u2013              <p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> </li> <li> <code>Tachyon_gpaw_ucx</code>             \u2013              <p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> </li> <li> <code>Tachyon_gpaw_tcp</code>             \u2013              </li> <li> <code>Tachyon_lammps_ase</code>             \u2013              </li> <li> <code>Tachyon_ase_ib</code>             \u2013              </li> <li> <code>Tachyon_ase_tcp</code>             \u2013              </li> <li> <code>Lion_lammps</code>             \u2013              <p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> </li> <li> <code>Leopard_lammps</code>             \u2013              </li> <li> <code>Eagle_lammps</code>             \u2013              <p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> </li> <li> <code>CanCentosGpu_lammps</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> </li> <li> <code>CanCentosGpu_gpaw</code>             \u2013              <p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> </li> <li> <code>CanCentosGpu_ase</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>tachyon_template</code>           \u2013            </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.tachyon_template","title":"<code>tachyon_template = {'group_size': 1, 'queue_name': 'ib.q', 'kwargs': {'pe_name': 'mpi_8', 'job_name': 'zDP'}, 'cpu_per_node': 8, 'custom_flags': ['#$ -l  h_rt=168:00:00', '#$ -l  mem_used=600M'], 'source_list': ['/etc/profile.d/modules.sh'], 'module_list': ['mpi/openmpi4.1.7-clang17-IB', 'lammps/llvmOMPI4-dev'], 'envs': {'OMP_NUM_THREADS': 1, 'OMPI_MCA_btl_openib_allow_ib': 1, 'OMPI_MCA_btl': '^tcp'}}</code>  <code>module-attribute</code>","text":""},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_lammps_ib","title":"<code>Tachyon_lammps_ib(n_cpu: int = 16)</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only InfiniBand nodes.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_lammps_tcp","title":"<code>Tachyon_lammps_tcp(n_cpu: int = 8)</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST, only use TCP.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>8</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_gpaw_ib","title":"<code>Tachyon_gpaw_ib(n_cpu: int = 16)</code>","text":"<p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_gpaw_ucx","title":"<code>Tachyon_gpaw_ucx(n_cpu: int = 16)</code>","text":"<p>Define Resources for running GPAW on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_gpaw_tcp","title":"<code>Tachyon_gpaw_tcp(n_cpu: int = 8)</code>","text":""},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_lammps_ase","title":"<code>Tachyon_lammps_ase(n_cpu: int = 16)</code>","text":""},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_ase_ib","title":"<code>Tachyon_ase_ib(n_cpu: int = 16)</code>","text":""},{"location":"qflow/#thmd.qflow.resource_unist.Tachyon_ase_tcp","title":"<code>Tachyon_ase_tcp(n_cpu: int = 8)</code>","text":""},{"location":"qflow/#thmd.qflow.resource_unist.Lion_lammps","title":"<code>Lion_lammps(n_cpu: int = 12, queue_name: str = 'lion-normal.q', pe_name: str = 'lion-normal', time: str = '168:00:00')</code>","text":"<p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Number of CPU to run job. 12x for Lion, 8x for Leopard, 10x for Eagle.</p> </li> <li> <code>queue_name</code>               (<code>str</code>, default:                   <code>'lion-normal.q'</code> )           \u2013            <p>SGE's queue name. Available queues: - Lion: lion-normal.q, lion-short.q, lion-long.q - Leopard: leopard-normal.q, leopard-short.q, leopard-long.q</p> </li> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'lion-normal'</code> )           \u2013            <p>SGE's Parallel environment name: mpi, mpi_1~mpi_20 - Lion: lion-normal, lion-short, lion-long - Leopard: leopard-normal, leopard-short, leopard-long</p> </li> <li> <code>time</code>               (<code>str</code>, default:                   <code>'168:00:00'</code> )           \u2013            <p>Time limit for the job. normal: '168:00:00', long: '540:00:00'</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.Leopard_lammps","title":"<code>Leopard_lammps(n_cpu: int = 8, queue_name: str = 'leopard-normal.q', pe_name: str = 'leopard-normal', time: str = '168:00:00')</code>","text":""},{"location":"qflow/#thmd.qflow.resource_unist.Eagle_lammps","title":"<code>Eagle_lammps(n_cpu: int = 10, pe_name: str = 'mpi_10')</code>","text":"<p>Define Resources for running LAMMPS on Eagle cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>10</code> )           \u2013            <p>Number of CPU to run job. 12x for Lion, 8x for Leopard, 10x for Eagle.</p> </li> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'mpi_10'</code> )           \u2013            <p>SGE's Parallel environment name: mpi, mpi_1~mpi_20 - Eagle: mpi, mpi_1~mpi_20</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.CanCentosGpu_lammps","title":"<code>CanCentosGpu_lammps(n_cpu: int = 12, pe_name: str = 'mpi_12')</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'mpi_12'</code> )           \u2013            <p>SGE's Parallel environment name.</p> </li> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.CanCentosGpu_gpaw","title":"<code>CanCentosGpu_gpaw(n_cpu: int = 12, pe_name: str = 'mpi_12')</code>","text":"<p>Define Resources for running LAMMPS on Tachyon cluster at UNIST.</p> <p>Parameters:</p> <ul> <li> <code>pe_name</code>               (<code>str</code>, default:                   <code>'mpi_12'</code> )           \u2013            <p>SGE's Parallel environment name.</p> </li> <li> <code>n_cpu</code>               (<code>int</code>, default:                   <code>12</code> )           \u2013            <p>Number of CPU to run job.</p> </li> </ul>"},{"location":"qflow/#thmd.qflow.resource_unist.CanCentosGpu_ase","title":"<code>CanCentosGpu_ase(n_cpu: int = 12, pe_name: str = 'mpi_12')</code>","text":""},{"location":"recipe/","title":"recipe","text":""},{"location":"recipe/#thmd.recipe","title":"<code>thmd.recipe</code>","text":"<p>Modules:</p> <ul> <li> <code>git</code>           \u2013            </li> <li> <code>gpaw</code>           \u2013            </li> <li> <code>lammps</code>           \u2013            </li> <li> <code>mace</code>           \u2013            <p>Some notes</p> </li> <li> <code>mlff</code>           \u2013            </li> <li> <code>ovito</code>           \u2013            </li> <li> <code>plumed</code>           \u2013            </li> <li> <code>sevennet</code>           \u2013            <p>Some notes</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.git","title":"<code>git</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw","title":"<code>gpaw</code>","text":"<p>Modules:</p> <ul> <li> <code>arg_parser</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_check_PWcutoff</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_check_kpoints</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_check_kpoints_density</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_optimize</code>           \u2013            <p>Some notes</p> </li> <li> <code>cli_gpaw_singlepoint</code>           \u2013            <p>Some notes</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.gpaw.arg_parser","title":"<code>arg_parser</code>","text":"<p>Some notes</p> RFE <ul> <li>Python CLI variables: https://stackoverflow.com/questions/4033723/how-do-i-access-command-line-arguments</li> <li>argparse: https://stackoverflow.com/questions/20063/whats-the-best-way-to-parse-command-line-arguments</li> <li>Parse a list in argparse: https://stackoverflow.com/questions/15753701/how-can-i-pass-a-list-as-a-command-line-argument-with-argparse</li> </ul> <p>Functions:</p> <ul> <li> <code>args_optimize</code>             \u2013              </li> </ul>"},{"location":"recipe/#thmd.recipe.gpaw.arg_parser.args_optimize","title":"<code>args_optimize()</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff","title":"<code>cli_gpaw_check_PWcutoff</code>","text":"<p>Some notes - calc.new() will create a new calculator that inherits all parameters from the current calculator, except for <code>txt</code> and <code>timer</code></p> RFE <ul> <li>convergence-checks: https://wiki.fysik.dtu.dk/gpaw/tutorialsexercises/structureoptimization/water/water.html#convergence-checks</li> <li>Gpaw tools: https://github.com/lrgresearch/gpaw-tools/blob/main/optimizations/optimize_ecut.py</li> </ul> <p>Attributes:</p> <ul> <li> <code>output_dir</code>           \u2013            </li> <li> <code>parallel_args</code>           \u2013            </li> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>ecut</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>new_calc</code>           \u2013            </li> <li> <code>pe</code>           \u2013            </li> <li> <code>out_file</code>           \u2013            </li> </ul>"},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.output_dir","title":"<code>output_dir = Path('output')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.parallel_args","title":"<code>parallel_args = {'sl_auto': True, 'use_elpa': True}</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.parser","title":"<code>parser = argparse.ArgumentParser(description='Check convergence of PW energy cutoff')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.extxyz_file","title":"<code>extxyz_file = args.poscar</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.ecut","title":"<code>ecut = args.ecutoff</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz_file', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.calc","title":"<code>calc = GPAW(mode=PW(550), xc='PBE', occupations=FermiDirac(0.01), kpts={'density': 15, 'gamma': False}, parallel=parallel_args)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.new_calc","title":"<code>new_calc = calc.new(mode=PW(ecut), txt=f'{output_dir}/calc_ecut_{ecut}.txt')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.pe","title":"<code>pe = atoms.get_potential_energy() / len(atoms)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_PWcutoff.out_file","title":"<code>out_file = f'{output_dir}/check_ecut_{ecut}.txt'</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints","title":"<code>cli_gpaw_check_kpoints</code>","text":"<p>Some notes</p> RFE <ul> <li>convergence-checks: https://wiki.fysik.dtu.dk/gpaw/tutorialsexercises/structureoptimization/water/water.html#convergence-checks</li> <li>Gpaw tools: https://github.com/lrgresearch/gpaw-tools/blob/main/optimizations/optimize_kpoints.py</li> <li>Parse a list in argparse: https://stackoverflow.com/questions/15753701/how-can-i-pass-a-list-as-a-command-line-argument-with-argparse</li> </ul> <p>Attributes:</p> <ul> <li> <code>output_dir</code>           \u2013            </li> <li> <code>parallel_args</code>           \u2013            </li> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>pbc</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>pe</code>           \u2013            </li> <li> <code>out_file</code>           \u2013            </li> </ul>"},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.output_dir","title":"<code>output_dir = Path('output')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.parallel_args","title":"<code>parallel_args = {'sl_auto': True, 'use_elpa': True}</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.parser","title":"<code>parser = argparse.ArgumentParser(description='Check convergence of PW energy cutoff')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.extxyz_file","title":"<code>extxyz_file = args.poscar</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.pbc","title":"<code>pbc = [int(item) for item in args.pbc.split(' ')]</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz_file', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.calc","title":"<code>calc = GPAW(mode=PW(550), xc='PBE', occupations=FermiDirac(0.01), kpts={'size': (nkx, nky, nkz), 'gamma': True}, txt=f'{output_dir}/calc_kpoints_{nkx}x{nky}x{nkz}.txt', parallel=parallel_args)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.pe","title":"<code>pe = atoms.get_potential_energy() / len(atoms)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints.out_file","title":"<code>out_file = f'{output_dir}/check_kpoints_{nkx}x{nky}x{nkz}.txt'</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density","title":"<code>cli_gpaw_check_kpoints_density</code>","text":"<p>Some notes</p> RFE <ul> <li>convergence-checks: https://wiki.fysik.dtu.dk/gpaw/tutorialsexercises/structureoptimization/water/water.html#convergence-checks</li> <li>Gpaw tools: https://github.com/lrgresearch/gpaw-tools/blob/main/optimizations/optimize_kpoints.py</li> </ul> <p>Attributes:</p> <ul> <li> <code>output_dir</code>           \u2013            </li> <li> <code>parallel_args</code>           \u2013            </li> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>kdensity</code>           \u2013            </li> <li> <code>pbc</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>pe</code>           \u2013            </li> <li> <code>out_file</code>           \u2013            </li> </ul>"},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.output_dir","title":"<code>output_dir = Path('output')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.parallel_args","title":"<code>parallel_args = {'sl_auto': True, 'use_elpa': True}</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.parser","title":"<code>parser = argparse.ArgumentParser(description='Check convergence of PW energy cutoff')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.extxyz_file","title":"<code>extxyz_file = args.poscar</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.kdensity","title":"<code>kdensity = args.kdensity</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.pbc","title":"<code>pbc = [int(item) for item in args.pbc.split(' ')]</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz_file', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.calc","title":"<code>calc = GPAW(mode=PW(550), xc='PBE', occupations=FermiDirac(0.01), kpts={'density': kdensity, 'gamma': True}, txt=f'{output_dir}/calc_kdensity_{kdensity}.txt', parallel=parallel_args)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.pe","title":"<code>pe = atoms.get_potential_energy() / len(atoms)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_check_kpoints_density.out_file","title":"<code>out_file = f'{output_dir}/check_kdensity_{kdensity}.txt'</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize","title":"<code>cli_gpaw_optimize</code>","text":"<p>Some notes - Must set txt='calc.txt' in GPAW calculator for backward files. - param_yaml must contain     - a dict <code>gpaw</code> with GPAW parameters.     - a dict <code>optimize</code> with ASE optimization parameters.</p> <p>Attributes:</p> <ul> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>configfile</code>           \u2013            </li> <li> <code>pdict</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>gpaw_arg</code>           \u2013            </li> <li> <code>params</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>opt_args</code>           \u2013            </li> <li> <code>relax_dim</code>           \u2013            </li> <li> <code>pbc</code>           \u2013            </li> <li> <code>fmax</code>           \u2013            </li> <li> <code>nsteps</code>           \u2013            </li> <li> <code>atoms_filter</code>           \u2013            </li> <li> <code>opt</code>           \u2013            </li> <li> <code>pot_energy</code>           \u2013            </li> <li> <code>forces</code>           \u2013            </li> <li> <code>stress</code>           \u2013            </li> <li> <code>atoms_fake</code>           \u2013            </li> <li> <code>output_file</code>           \u2013            </li> </ul>"},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.parser","title":"<code>parser = argparse.ArgumentParser(description='Optimize structure using GPAW')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.configfile","title":"<code>configfile = args.param</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.pdict","title":"<code>pdict = load_setting_file(configfile)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.extxyz_file","title":"<code>extxyz_file = pdict['input_extxyz_path']</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.gpaw_arg","title":"<code>gpaw_arg = pdict.get('gpaw_arg', {})</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.params","title":"<code>params = {'mode': {'name': 'pw', 'ecut': 500}, 'xc': 'PBE', 'convergence': {'energy': 1e-06, 'density': 0.0001, 'eigenstates': 1e-08}, 'occupations': {'name': 'fermi-dirac', 'width': 0.01}, 'txt': 'calc_optimize.txt'}</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.calc","title":"<code>calc = GPAW(**params)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.opt_args","title":"<code>opt_args = pdict.get('optimize', {})</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.relax_dim","title":"<code>relax_dim = opt_args.get('relax_dim', None)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.pbc","title":"<code>pbc = atoms.get_pbc()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.fmax","title":"<code>fmax = opt_args.get('fmax', 0.05)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.nsteps","title":"<code>nsteps = opt_args.get('nsteps', 10000)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.atoms_filter","title":"<code>atoms_filter = FrechetCellFilter(atoms, mask=relax_dim)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.opt","title":"<code>opt = BFGS(atoms_filter)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.pot_energy","title":"<code>pot_energy = atoms.get_potential_energy()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.forces","title":"<code>forces = atoms.get_forces()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.stress","title":"<code>stress = atoms.get_stress(voigt=True)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.atoms_fake","title":"<code>atoms_fake = atoms.copy()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_optimize.output_file","title":"<code>output_file = extxyz_file.replace('.extxyz', '_labeled.extxyz')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint","title":"<code>cli_gpaw_singlepoint</code>","text":"<p>Some notes - Must set txt='calc.txt' in GPAW calculator for backward files. - param_yaml must contain     - a dict <code>gpaw</code> with GPAW parameters.</p> <p>Attributes:</p> <ul> <li> <code>parser</code>           \u2013            </li> <li> <code>args</code>           \u2013            </li> <li> <code>configfile</code>           \u2013            </li> <li> <code>pdict</code>           \u2013            </li> <li> <code>extxyz_file</code>           \u2013            </li> <li> <code>atoms</code>           \u2013            </li> <li> <code>gpaw_arg</code>           \u2013            </li> <li> <code>params</code>           \u2013            </li> <li> <code>calc</code>           \u2013            </li> <li> <code>pot_energy</code>           \u2013            </li> <li> <code>forces</code>           \u2013            </li> <li> <code>stress</code>           \u2013            </li> <li> <code>atoms_fake</code>           \u2013            </li> <li> <code>output_file</code>           \u2013            </li> </ul>"},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.parser","title":"<code>parser = argparse.ArgumentParser(description='Optimize structure using GPAW')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.configfile","title":"<code>configfile = args.param</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.pdict","title":"<code>pdict = load_setting_file(configfile)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.extxyz_file","title":"<code>extxyz_file = pdict['input_extxyz_path']</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.atoms","title":"<code>atoms = read(extxyz_file, format='extxyz', index='-1')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.gpaw_arg","title":"<code>gpaw_arg = pdict.get('gpaw_arg', {})</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.params","title":"<code>params = {'mode': {'name': 'pw', 'ecut': 500}, 'xc': 'PBE', 'convergence': {'energy': 1e-06, 'density': 0.0001, 'eigenstates': 1e-08}, 'occupations': {'name': 'fermi-dirac', 'width': 0.01}, 'txt': 'calc_singlepoint.txt'}</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.calc","title":"<code>calc = GPAW(**params)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.pot_energy","title":"<code>pot_energy = atoms.get_potential_energy()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.forces","title":"<code>forces = atoms.get_forces()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.stress","title":"<code>stress = atoms.get_stress(voigt=True)</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.atoms_fake","title":"<code>atoms_fake = atoms.copy()</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.gpaw.cli_gpaw_singlepoint.output_file","title":"<code>output_file = extxyz_file.replace('.extxyz', '_labeled.extxyz')</code>  <code>module-attribute</code>","text":""},{"location":"recipe/#thmd.recipe.lammps","title":"<code>lammps</code>","text":""},{"location":"recipe/#thmd.recipe.mace","title":"<code>mace</code>","text":"<p>Some notes</p> RFE <ul> <li>SevenNet repo: https://github.com/MDIL-SNU/SevenNet</li> </ul> <p>Functions:</p> <ul> <li> <code>cli_mace_optimize</code>             \u2013              <p>Return filepath of the script for running optimization using SevenNet.</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.mace.cli_mace_optimize","title":"<code>cli_mace_optimize(copy_to: str = None) -&gt; str</code>","text":"<p>Return filepath of the script for running optimization using SevenNet.</p>"},{"location":"recipe/#thmd.recipe.mlff","title":"<code>mlff</code>","text":""},{"location":"recipe/#thmd.recipe.ovito","title":"<code>ovito</code>","text":"<p>Functions:</p> <ul> <li> <code>scale_RGB</code>             \u2013              <p>Function to convert RGB color code from scale 0-255 to scale 0-1.</p> </li> <li> <code>mod_set_prop_atom_name</code>             \u2013              <p>Modifier to set atom names</p> </li> <li> <code>mod_set_prop_atom_color_PMMAori</code>             \u2013              <p>Modifier to assign atom colors based on atom_names.</p> </li> <li> <code>delete_pipelines</code>             \u2013              <p>delete all existed viewports, pipelines, and scene</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.ovito.scale_RGB","title":"<code>scale_RGB(RGB=(255, 255, 255))</code>","text":"<p>Function to convert RGB color code from scale 0-255 to scale 0-1.</p> <p>Parameters:</p> <ul> <li> <code>RGB</code>               (<code>tuple</code>, default:                   <code>(255, 255, 255)</code> )           \u2013            <p>RGB code in scale 0-255</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>rgb</code> (              <code>tuple</code> )          \u2013            <p>RGB code in scale 0-1</p> </li> </ul> <p>Examples:</p> <pre><code>rgb = scale_RGB((255,255,255)))\n</code></pre> Quote <ol> <li>rgb-values-to-0-to-1-scale</li> </ol>"},{"location":"recipe/#thmd.recipe.ovito.mod_set_prop_atom_name","title":"<code>mod_set_prop_atom_name(frame, data)</code>","text":"<p>Modifier to set atom names</p> <p>Examples:</p> <pre><code>from thmd.visual.ovito_modifier import mod_set_prop_atom_name\nfrom ovito.io import import_file\n\npipeline = import_file(\"test.cfg\")\npipeline.add_to_scene()\n## add mod\ndict_name = {'type_id':[1, 2], 'atom_name':['C', 'H']}\npipeline.modifiers.append(mod_set_prop_atom_name)\n</code></pre> Note <ul> <li>So far, can not a custom argument to modifier, see here. So we need to define a <code>global variable</code> before using this function     <pre><code>dict_name = {'type_id':(1, 2), 'atom_name':('C', 'H')}\n</code></pre></li> <li>Do not use 'return` in modifier</li> <li>the underscore notation mean modifiable version of the quantity in ovito</li> </ul> Quote <ol> <li>Pass custom args to modifier</li> <li>ovito.data.Property             - type.id, type.name, type.color, type.radius</li> </ol>"},{"location":"recipe/#thmd.recipe.ovito.mod_set_prop_atom_color_PMMAori","title":"<code>mod_set_prop_atom_color_PMMAori(frame, data)</code>","text":"<p>Modifier to assign atom colors based on atom_names.</p> <p>Examples:</p> <pre><code>from thmd.visual.ovito_modifier import mod_set_prop_atom_color_PMMAori\nfrom ovito.io import import_file\n\npipeline = import_file(\"test.cfg\")\npipeline.add_to_scene()\n## add mod\npipeline.modifiers.append(mod_set_prop_atom_color_PMMAori)\n</code></pre>"},{"location":"recipe/#thmd.recipe.ovito.delete_pipelines","title":"<code>delete_pipelines(viewports: list[object] = [], pipelines: list[object] = [], scene: object = None)</code>","text":"<p>delete all existed viewports, pipelines, and scene</p> <p>Parameters:</p> <ul> <li> <code>viewports</code>               (<code>obj</code>, default:                   <code>[]</code> )           \u2013            <p>list of ovito viewport objects</p> </li> <li> <code>pipelines</code>               (<code>obj</code>, default:                   <code>[]</code> )           \u2013            <p>list of ovito pipeline objects</p> </li> <li> <code>scene</code>               (<code>obj</code>, default:                   <code>None</code> )           \u2013            <p>ovito scene object</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.plumed","title":"<code>plumed</code>","text":"<p>Functions:</p> <ul> <li> <code>script_FCCUBIC</code>             \u2013              <p>PLUMED script to compute FCCUBIC</p> </li> <li> <code>script_LOCAL_CRYSTALINITY</code>             \u2013              <p>PLUMED script to compute LOCAL_CRYSTALINITY</p> </li> <li> <code>script_LOGMFD</code>             \u2013              <p>PLUMED script to compute LOGFMD</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.plumed.script_FCCUBIC","title":"<code>script_FCCUBIC(a_fcc, zDirect, label='mcv', alpha=27, partialCompute=False, atoms='@mdatoms', atomsA=None, atomsB=None, options='')</code>","text":"<p>PLUMED script to compute FCCUBIC</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>               (<code>float</code>)           \u2013            <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>               (<code>str</code>)           \u2013            <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>'mcv'</code> )           \u2013            <p>label of PLUMED command</p> </li> <li> <code>alpha</code>               (<code>int</code>, default:                   <code>27</code> )           \u2013            <p>ALPHA parameter to compute FCCUBIC colvar.</p> </li> <li> <code>atoms</code>               (<code>str</code>, default:                   <code>'@mdatoms'</code> )           \u2013            <p>specify atom-ids in computed group.</p> </li> <li> <code>partialCompute</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>compute for some atoms.</p> </li> <li> <code>atomsA</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>specify atom-ids in group A.</p> </li> <li> <code>atomsB</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>specify atom-ids in group B.</p> </li> <li> <code>options</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.plumed.script_LOCAL_CRYSTALINITY","title":"<code>script_LOCAL_CRYSTALINITY(a_fcc, zDirect, label='mcv', vectors=[[1, 0, 0], [0, 1, 0], [0, 0, 1]], atoms='@mdatoms', options='')</code>","text":"<p>PLUMED script to compute LOCAL_CRYSTALINITY</p> <p>Parameters:</p> <ul> <li> <code>a_fcc</code>               (<code>float</code>)           \u2013            <p>Lattice constant of FCC crystal</p> </li> <li> <code>zDirect</code>               (<code>str</code>)           \u2013            <p>specify the z-direction of crystal</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>'mcv'</code> )           \u2013            <p>label of PLUMED command</p> </li> <li> <code>vectors</code>               (<code>list</code>, default:                   <code>[[1, 0, 0], [0, 1, 0], [0, 0, 1]]</code> )           \u2013            <p>2xN list of lists, to specify directions of reciprocal vectors.</p> </li> <li> <code>atoms</code>               (<code>str</code>, default:                   <code>'@mdatoms'</code> )           \u2013            <p>specify atom-ids in computed group.</p> </li> <li> <code>options</code>               (<code>str</code>, default:                   <code>''</code> )           \u2013            <p>add options.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.plumed.script_LOGMFD","title":"<code>script_LOGMFD(ARG, FICT, FICT_MIN, FICT_MAX, TEMP, DELTA_T, INTERVAL, KAPPA, deltaF, deltaX, kB, label='mfd', FLOG=5000, MFDstat='VS')</code>","text":"<p>PLUMED script to compute LOGFMD</p> <p>Parameters:</p> <ul> <li> <code>ARG</code>               (<code>str</code>)           \u2013            <p>the scalar input for this action</p> </li> <li> <code>FICT</code>               (<code>float</code>)           \u2013            <p>The initial values of the fictitious dynamical variables</p> </li> <li> <code>FICT_MIN</code>               (<code>float</code>)           \u2013            <p>Boundaries of CV_space</p> </li> <li> <code>FICT_MAX</code>               (<code>float</code>)           \u2013            <p>Boundaries of CV_space</p> </li> <li> <code>TEMP</code>               (<code>float</code>)           \u2013            <p>Temperature of the fictitious dynamical variables</p> </li> <li> <code>DELTA_T</code>               (<code>float</code>)           \u2013            <p>Time step for the fictitious dynamical variables (MFD step)</p> </li> <li> <code>INTERVAL</code>               (<code>int</code>)           \u2013            <p>Period of MD steps ( Nm) to update fictitious dynamical variables</p> </li> <li> <code>KAPPA</code>               (<code>int</code>)           \u2013            <p>Spring constant of the harmonic restraining potential for the fictitious dynamical variables</p> </li> <li> <code>deltaF</code>               (<code>float</code>)           \u2013            <p>Energy Barrier to estimate ALPHA (Alpha parameter for LogMFD)</p> </li> <li> <code>deltaX</code>               (<code>float</code>)           \u2013            <p>CV distance at each MFDstep, to estimate MFICT, VFICT (mass &amp; velocity of fictitious dynamical variable)</p> </li> <li> <code>kB</code>               (<code>float</code>)           \u2013            <p>Boltzmann constant</p> </li> <li> <code>label</code>               (<code>str</code>, default:                   <code>'mfd'</code> )           \u2013            <p>label of PLUMED command</p> </li> <li> <code>FLOG</code>               (<code>float</code>, default:                   <code>5000</code> )           \u2013            <p>The initial free energy value in the LogMFD, initial F(X)</p> </li> <li> <code>MFDstat</code>               (<code>str</code>, default:                   <code>'VS'</code> )           \u2013            <p>Type of thermostat for the fictitious dynamical variables. NVE, NVT, VS are available.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code> (              <code>list</code> )          \u2013            <p>list of strings.</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.sevennet","title":"<code>sevennet</code>","text":"<p>Some notes</p> RFE <ul> <li>SevenNet repo: https://github.com/MDIL-SNU/SevenNet</li> </ul> <p>Functions:</p> <ul> <li> <code>cli_7net_optimize</code>             \u2013              <p>Return filepath of the script for running optimization using SevenNet.</p> </li> </ul>"},{"location":"recipe/#thmd.recipe.sevennet.cli_7net_optimize","title":"<code>cli_7net_optimize(copy_to: str = None) -&gt; str</code>","text":"<p>Return filepath of the script for running optimization using SevenNet.</p>"},{"location":"util/","title":"Util","text":""},{"location":"util/#thmd.util","title":"<code>thmd.util</code>","text":"<p>Modules:</p> <ul> <li> <code>check_installation</code>           \u2013            </li> <li> <code>compute_angle</code>           \u2013            </li> <li> <code>compute_distance</code>           \u2013            </li> <li> <code>compute_tensor</code>           \u2013            </li> <li> <code>detect_sign_change</code>           \u2013            </li> <li> <code>fit</code>           \u2013            </li> <li> <code>grid_box</code>           \u2013            </li> <li> <code>many_stuff</code>           \u2013            </li> <li> <code>row_operation</code>           \u2013            </li> <li> <code>string_index</code>           \u2013            </li> <li> <code>unit</code>           \u2013            <p>This module to convert unit of some physical properties</p> </li> </ul>"},{"location":"util/#thmd.util.check_installation","title":"<code>check_installation</code>","text":"<p>Functions:</p> <ul> <li> <code>check_install_ovito</code>             \u2013              </li> <li> <code>check_install_googlesearch</code>             \u2013              </li> </ul>"},{"location":"util/#thmd.util.check_installation.check_install_ovito","title":"<code>check_install_ovito()</code>","text":""},{"location":"util/#thmd.util.check_installation.check_install_googlesearch","title":"<code>check_install_googlesearch()</code>","text":""},{"location":"util/#thmd.util.compute_angle","title":"<code>compute_angle</code>","text":"<p>Functions:</p> <ul> <li> <code>angle_vector2vectors</code>             \u2013              <p>copmute angles between a vector with set of vectors</p> </li> </ul>"},{"location":"util/#thmd.util.compute_angle.angle_vector2vectors","title":"<code>angle_vector2vectors(fixVector, arrayVectors, unit='rad')</code>","text":"<p>copmute angles between a vector with set of vectors</p>"},{"location":"util/#thmd.util.compute_distance","title":"<code>compute_distance</code>","text":"<p>Functions:</p> <ul> <li> <code>dist2_point2points</code>             \u2013              <p>Compute bond_len and postion_vetors from 1 point to a list of points</p> </li> <li> <code>dist2_points2line</code>             \u2013              <p>Compute bond_len and postion_vetors from 1 point to a list of points</p> </li> <li> <code>closest_points2line</code>             \u2013              <p>Find all points locate inside a checkin-distance \"dist\" from a line.</p> </li> <li> <code>closest_points2multilines</code>             \u2013              <p>Find all points locate inside a checkin-distance \"dist\" from multilines.</p> </li> </ul>"},{"location":"util/#thmd.util.compute_distance.dist2_point2points","title":"<code>dist2_point2points(point, points)</code>","text":"<p>Compute bond_len and postion_vetors from 1 point to a list of points</p> <p>Parameters:</p> <ul> <li> <code>point</code>               (<code>list array</code>)           \u2013            <p>coordinate of 1 point.</p> </li> <li> <code>points</code>               (<code>list array</code>)           \u2013            <p>2d-list of coordinates of points/point.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>df</code> (              <code>DataFrame</code> )          \u2013            <p>pd.DataFrame constains distance and component of connecting vectors.</p> </li> </ul>"},{"location":"util/#thmd.util.compute_distance.dist2_points2line","title":"<code>dist2_points2line(points, line=[(0, 0, 0), (0, 0, 0)])</code>","text":"<p>Compute bond_len and postion_vetors from 1 point to a list of points Ref: https://stackoverflow.com/questions/39840030/distance-between-point-and-a-line-from-two-points</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list array DataFrame</code>)           \u2013            <p>list of coordinates of points/point.</p> </li> <li> <code>line</code>               (<code>list array</code>, default:                   <code>[(0, 0, 0), (0, 0, 0)]</code> )           \u2013            <p>2d-array contains coordinates to define a line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>d</code> (              <code>float list</code> )          \u2013            <p>distances between points and a line.</p> </li> </ul>"},{"location":"util/#thmd.util.compute_distance.closest_points2line","title":"<code>closest_points2line(points, line=[(0, 0, 0), (0, 0, 0)], distance=0, Xbound=None, Ybound=None, Zbound=None)</code>","text":"<p>Find all points locate inside a checkin-distance \"dist\" from a line.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list array</code>)           \u2013            <p>list of coordinates of points/point.</p> </li> <li> <code>line</code>               (<code>list array</code>, default:                   <code>[(0, 0, 0), (0, 0, 0)]</code> )           \u2013            <p>[[x1,y1,z1], [x1,y2,z2]]: 2d-list contains coordinates to define a line.</p> </li> <li> <code>distance</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>the checkin-distance.</p> </li> <li> <code>Xbound</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>define the boundaries for checking. Xbound='line': use the lengths of lines as bounds. Xbound=None: extend to INF. Xbound = (xlo, xhi)</p> </li> <li> <code>Ybound</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>define the boundaries for checking.</p> </li> <li> <code>Zbound</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>define the boundaries for checking.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds_idx</code> (              <code>Series</code> )          \u2013            <p>Series of indices of points within the checkin-distance</p> </li> </ul>"},{"location":"util/#thmd.util.compute_distance.closest_points2multilines","title":"<code>closest_points2multilines(points, multilines=[], distance=0, Xbound=None, Ybound=None, Zbound=None)</code>","text":"<p>Find all points locate inside a checkin-distance \"dist\" from multilines. The Bound is set as the line-lengths.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list array</code>)           \u2013            <p>list of coordinates of points/point.</p> </li> <li> <code>multilines</code>               (<code>list</code>, default:                   <code>[]</code> )           \u2013            <p>list of pair-points, each pair-point contains coordinates of 2 points to define a line used in 'closest_points2line'.</p> </li> <li> <code>distance</code>               (<code>float</code>, default:                   <code>0</code> )           \u2013            <p>the checkin-distance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>ds_idx</code> (              <code>Series</code> )          \u2013            <p>Series of indices of points within the checkin-distance</p> </li> </ul>"},{"location":"util/#thmd.util.compute_tensor","title":"<code>compute_tensor</code>","text":"<p>Functions:</p> <ul> <li> <code>ke_tensor</code>             \u2013              <p>Compute Kinetic Energy tensors, and Temp</p> </li> <li> <code>stress_tensor</code>             \u2013              <p>Compute local pressure/stress</p> </li> </ul>"},{"location":"util/#thmd.util.compute_tensor.ke_tensor","title":"<code>ke_tensor(vel, mass, kb)</code>","text":"<p>Compute Kinetic Energy tensors, and Temp Args:         vel (array): Nx3 array of per-atom velocity         mass (array): Nx3 array of atomic mass         inUNIT (str): ['angstrom','ps','amu','eV'], outUNIT=['eV','K'] Returns:         Kinetic energy tensor, Kinetic scalar, Temperature scalar</p>"},{"location":"util/#thmd.util.compute_tensor.stress_tensor","title":"<code>stress_tensor(per_atom_stress_tensor, atomic_volume, unitFac=1)</code>","text":"<p>Compute local pressure/stress Args:         per_atom_stress_tensor : Nx6 array of the per-atom stress tensor         atomVol    : Nx1 vector of atomVol         inUNIT=['bar','angstrom'], outUNIT=['bar'] \u2192 unitFac=1e-4 for ['GPa'] Returns:         pressure scalar         Stress tensor</p>"},{"location":"util/#thmd.util.detect_sign_change","title":"<code>detect_sign_change</code>","text":"<p>Functions:</p> <ul> <li> <code>detect_sign_change</code>             \u2013              <p>determine points where line y=y(x) change its sign</p> </li> </ul>"},{"location":"util/#thmd.util.detect_sign_change.detect_sign_change","title":"<code>detect_sign_change(y, x=[])</code>","text":"<p>determine points where line y=y(x) change its sign</p> <p>Parameters:</p> <ul> <li> <code>y</code>           \u2013            <p>Nx1 arrays, contains dependent variable y</p> </li> <li> <code>x</code>           \u2013            <p>(Optinal) Nx1 arrays, contains independent variable x of line y(x)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>idx</code>          \u2013            <p>1d array of indices where sign changes</p> </li> </ul>"},{"location":"util/#thmd.util.fit","title":"<code>fit</code>","text":"<p>Modules:</p> <ul> <li> <code>curve_intersect</code>           \u2013            </li> <li> <code>fit_root</code>           \u2013            </li> <li> <code>user_lmfit</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>curve_intersect_shapely</code>             \u2013              <p>find the intersection points between 2 lines</p> </li> <li> <code>polyfit</code>             \u2013              <p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients.</p> </li> <li> <code>find_slope</code>             \u2013              <p>Compute slope of a linear relation y = A + B*x.</p> </li> <li> <code>find_roots</code>             \u2013              <p>find roots for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_extrema</code>             \u2013              <p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_convergence</code>             \u2013              <p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> </li> <li> <code>extrapolate</code>             \u2013              </li> </ul>"},{"location":"util/#thmd.util.fit.curve_intersect_shapely","title":"<code>curve_intersect_shapely(line1, line2)</code>","text":"<p>find the intersection points between 2 lines Args:         line1 (array like): Nx2 arrays, contains data points of curve 1         line2 (array like): Nx2 arrays, contains data points of curve 2</p> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul>"},{"location":"util/#thmd.util.fit.polyfit","title":"<code>polyfit(x, y, deg=1, sigma_y=None, uncert=False, **kwargs)</code>","text":"<p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients. The fitted polynomial(s) are in the form</p> <pre><code>p(x) = a0 + a1*x + a2*x^2 + ... + an*x^n\n</code></pre> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>deg</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>degree of polynomial</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> <li> <code>uncert</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return uncertainties of coefficients. Defaults to False.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional arguments, adapt all args from <code>np.polyfit</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients</p> </li> <li> <code>uncert</code> (              <code>array</code> )          \u2013            <p>1D array of standard deviation of coefficients</p> </li> </ul>"},{"location":"util/#thmd.util.fit.find_slope","title":"<code>find_slope(x, y)</code>","text":"<p>Compute slope of a linear relation y = A + B*x.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> </ul> Return <p>slope (float): the slope to linear relation</p>"},{"location":"util/#thmd.util.fit.find_roots","title":"<code>find_roots(x, y, order=1)</code>","text":"<p>find roots for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>order of polynomial. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>roots</code> (              <code>list</code> )          \u2013            <p>list of roots</p> </li> </ul>"},{"location":"util/#thmd.util.fit.find_extrema","title":"<code>find_extrema(x, y, order=2, retun_fit=False)</code>","text":"<p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>order of polynomial. Defaults to 2.</p> </li> <li> <code>retun_fit</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return fitted params. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>list</code> )          \u2013            <p>list of flex points.</p> </li> </ul>"},{"location":"util/#thmd.util.fit.find_convergence","title":"<code>find_convergence(x, y, tol=1e-06, grid_size=None, convergence_side='right')</code>","text":"<p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x values</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y values</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>tolerance of the slope (dy/dx). Defaults to 1e-6.</p> </li> <li> <code>grid_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>set grid size of x if need to interpolate finer data. Defaults to None.</p> </li> <li> <code>convergence_side</code>               (<code>str</code>, default:                   <code>'right'</code> )           \u2013            <p>find the first x on the left or right side. Defaults to \"right\".</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>best_x, best_y (float): found x and y value that y converge with a tolerance &lt; tol.</p> </li> </ul> Notes <p>Value <code>df['dy'] = df['y'].diff()</code> depends on grid size. Should use <code>df['dy'] = df['y'].diff()/ df['x'].diff()</code>.</p> References <ol> <li>https://docs.scipy.org/doc/scipy/tutorial/interpolate.html</li> </ol>"},{"location":"util/#thmd.util.fit.extrapolate","title":"<code>extrapolate(x, y, left_side: list = None, right_side: list = None, grid_size=0.1) -&gt; tuple[list, list]</code>","text":""},{"location":"util/#thmd.util.fit.curve_intersect","title":"<code>curve_intersect</code>","text":"<p>Functions:</p> <ul> <li> <code>curve_intersect_shapely</code>             \u2013              <p>find the intersection points between 2 lines</p> </li> </ul>"},{"location":"util/#thmd.util.fit.curve_intersect.curve_intersect_shapely","title":"<code>curve_intersect_shapely(line1, line2)</code>","text":"<p>find the intersection points between 2 lines Args:         line1 (array like): Nx2 arrays, contains data points of curve 1         line2 (array like): Nx2 arrays, contains data points of curve 2</p> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul>"},{"location":"util/#thmd.util.fit.curve_intersect.___curve_intersect_numpy","title":"<code>___curve_intersect_numpy(curve1, curve2, degree=3, bounds=None)</code>","text":"<p>find the intersection points between 2 curves</p> <p>Parameters:</p> <ul> <li> <code>curve1</code>               (<code>array like</code>)           \u2013            <p>Nx2 arrays in form (x,y), contains data points of curve 1</p> </li> <li> <code>curve2</code>               (<code>array like</code>)           \u2013            <p>Nx2 arrays in form (x,y), contains data points of curve 2</p> </li> <li> <code>degree</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>degree of polynomial function to fit the curve</p> </li> <li> <code>bounds</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>(min, max) of x, to select points in bounds</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul> Refs <p>[1] http://t.ly/2_a-K</p>"},{"location":"util/#thmd.util.fit.fit_root","title":"<code>fit_root</code>","text":"<p>Functions:</p> <ul> <li> <code>polyfit</code>             \u2013              <p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients.</p> </li> <li> <code>find_slope</code>             \u2013              <p>Compute slope of a linear relation y = A + B*x.</p> </li> <li> <code>find_roots</code>             \u2013              <p>find roots for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_extrema</code>             \u2013              <p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_convergence</code>             \u2013              <p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> </li> <li> <code>extrapolate</code>             \u2013              </li> </ul>"},{"location":"util/#thmd.util.fit.fit_root.polyfit","title":"<code>polyfit(x, y, deg=1, sigma_y=None, uncert=False, **kwargs)</code>","text":"<p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients. The fitted polynomial(s) are in the form</p> <pre><code>p(x) = a0 + a1*x + a2*x^2 + ... + an*x^n\n</code></pre> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>deg</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>degree of polynomial</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> <li> <code>uncert</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return uncertainties of coefficients. Defaults to False.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional arguments, adapt all args from <code>np.polyfit</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients</p> </li> <li> <code>uncert</code> (              <code>array</code> )          \u2013            <p>1D array of standard deviation of coefficients</p> </li> </ul>"},{"location":"util/#thmd.util.fit.fit_root.find_slope","title":"<code>find_slope(x, y)</code>","text":"<p>Compute slope of a linear relation y = A + B*x.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> </ul> Return <p>slope (float): the slope to linear relation</p>"},{"location":"util/#thmd.util.fit.fit_root.find_roots","title":"<code>find_roots(x, y, order=1)</code>","text":"<p>find roots for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>order of polynomial. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>roots</code> (              <code>list</code> )          \u2013            <p>list of roots</p> </li> </ul>"},{"location":"util/#thmd.util.fit.fit_root.find_extrema","title":"<code>find_extrema(x, y, order=2, retun_fit=False)</code>","text":"<p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>order of polynomial. Defaults to 2.</p> </li> <li> <code>retun_fit</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return fitted params. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>list</code> )          \u2013            <p>list of flex points.</p> </li> </ul>"},{"location":"util/#thmd.util.fit.fit_root.find_convergence","title":"<code>find_convergence(x, y, tol=1e-06, grid_size=None, convergence_side='right')</code>","text":"<p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x values</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y values</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>tolerance of the slope (dy/dx). Defaults to 1e-6.</p> </li> <li> <code>grid_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>set grid size of x if need to interpolate finer data. Defaults to None.</p> </li> <li> <code>convergence_side</code>               (<code>str</code>, default:                   <code>'right'</code> )           \u2013            <p>find the first x on the left or right side. Defaults to \"right\".</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>best_x, best_y (float): found x and y value that y converge with a tolerance &lt; tol.</p> </li> </ul> Notes <p>Value <code>df['dy'] = df['y'].diff()</code> depends on grid size. Should use <code>df['dy'] = df['y'].diff()/ df['x'].diff()</code>.</p> References <ol> <li>https://docs.scipy.org/doc/scipy/tutorial/interpolate.html</li> </ol>"},{"location":"util/#thmd.util.fit.fit_root.extrapolate","title":"<code>extrapolate(x, y, left_side: list = None, right_side: list = None, grid_size=0.1) -&gt; tuple[list, list]</code>","text":""},{"location":"util/#thmd.util.fit.fit_root.___uncertainty_weighted_fit_linear","title":"<code>___uncertainty_weighted_fit_linear(x, y, sigma_y=None)</code>","text":"<p>Compute uncertainties in coefficients A and B of y = A + B*x from the weighted least square fitting.</p> <p>Apply when the measured data y_i has different uncertainties sigma_y_i, the weights w_i = 1/(sigma_y_i^2).</p> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients A and B</p> </li> <li> <code>uncertainties</code> (              <code>tuple</code> )          \u2013            <p>1D array (sigma_intercept, sigma_slope) of standard deviation of A and B</p> </li> </ul> References <ol> <li>Taylor_1997_An introduction to error analysis: the study of uncertainties in physical measurements, page 198.</li> <li>https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfit.html</li> </ol>"},{"location":"util/#thmd.util.fit.user_lmfit","title":"<code>user_lmfit</code>","text":"<p>Classes:</p> <ul> <li> <code>UserLmfit</code>           \u2013            <p>The class contains set of objective function of fitting use by LMFIT package</p> </li> </ul>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit","title":"<code>UserLmfit</code>","text":"<p>The class contains set of objective function of fitting use by LMFIT package NOTEs: - defined function followed the convection of LMFIT: the first argument of the function is taken as the independent variable, held in independent_vars, and the rest of the functions positional arguments (and, in certain cases, keyword arguments \u2013 see below) are used for Parameter names. https://lmfit.github.io/lmfit-py/model.html - This Class defines curve-forms that are not vailable in LMFIT's built-in models</p> <ul> <li> <p>Attributes:         swType       : (default='RATIONAL') Type of witching function,         r0, d0       : The r_0 parameter of the switching function</p> </li> <li> <p>Methods:         fFunc    : compute &amp; return value and derivation of sw function         fDmax    : estimate value of Dmax</p> </li> </ul> <p>Ex: func = thmd.CurveLib.Linear(x)</p> <p>Methods:</p> <ul> <li> <code>Linear</code>             \u2013              <p>this func is available in LMFIT, just play as an example here</p> </li> <li> <code>inverseTemperature</code>             \u2013              </li> <li> <code>ExpDecay</code>             \u2013              </li> <li> <code>sizeEffect</code>             \u2013              <p>system size-dependence on term N^(\u2154</p> </li> <li> <code>unNormalGaussian</code>             \u2013              <p>The unNormalize Gaussian function</p> </li> <li> <code>NormalGaussian</code>             \u2013              <p>The Normalize Gaussian function</p> </li> <li> <code>sum_2unNormalGaussian</code>             \u2013              <p>The sum of 2 Gaussian function</p> </li> <li> <code>sum_3unNormalGaussian</code>             \u2013              <p>The sum of 3 Gaussian function</p> </li> <li> <code>sum_4unNormalGaussian</code>             \u2013              <p>The sum of 4 Gaussian function</p> </li> <li> <code>sum_5unNormalGaussian</code>             \u2013              <p>The sum of 5 Gaussian function</p> </li> <li> <code>sum_2NormalGaussian</code>             \u2013              <p>The sum of 2 Gaussian function</p> </li> <li> <code>sum_3NormalGaussian</code>             \u2013              <p>The sum of 3 Gaussian function</p> </li> <li> <code>sum_4NormalGaussian</code>             \u2013              <p>The sum of 4 Gaussian function</p> </li> <li> <code>sum_5NormalGaussian</code>             \u2013              <p>The sum of 5 Gaussian function</p> </li> <li> <code>DoseResp</code>             \u2013              <p>Dose-response curve with variable Hill slope given by parameter 'p'.</p> </li> <li> <code>BiDoseResp</code>             \u2013              <p>Biphasic Dose Response Function,</p> </li> <li> <code>Carreau</code>             \u2013              <p>Carreau-Yasuda model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates</p> </li> <li> <code>Cross</code>             \u2013              <p>Cross model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates</p> </li> <li> <code>GammaCFD</code>             \u2013              <p>Gamma cumulative distribution function</p> </li> </ul>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.Linear","title":"<code>Linear(x, a0, a1)</code>","text":"<p>this func is available in LMFIT, just play as an example here</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.inverseTemperature","title":"<code>inverseTemperature(x, a, b)</code>","text":""},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.ExpDecay","title":"<code>ExpDecay(x, A, lambd)</code>","text":""},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sizeEffect","title":"<code>sizeEffect(x, a, b)</code>","text":"<p>system size-dependence on term N^(\u2154</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.unNormalGaussian","title":"<code>unNormalGaussian(x, amp, cen, sig)</code>","text":"<p>The unNormalize Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.NormalGaussian","title":"<code>NormalGaussian(x, amp, cen, sig)</code>","text":"<p>The Normalize Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_2unNormalGaussian","title":"<code>sum_2unNormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code>","text":"<p>The sum of 2 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_3unNormalGaussian","title":"<code>sum_3unNormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code>","text":"<p>The sum of 3 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_4unNormalGaussian","title":"<code>sum_4unNormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code>","text":"<p>The sum of 4 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_5unNormalGaussian","title":"<code>sum_5unNormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code>","text":"<p>The sum of 5 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_2NormalGaussian","title":"<code>sum_2NormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code>","text":"<p>The sum of 2 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_3NormalGaussian","title":"<code>sum_3NormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code>","text":"<p>The sum of 3 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_4NormalGaussian","title":"<code>sum_4NormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code>","text":"<p>The sum of 4 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.sum_5NormalGaussian","title":"<code>sum_5NormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code>","text":"<p>The sum of 5 Gaussian function</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.DoseResp","title":"<code>DoseResp(x, A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</code>","text":"<p>Dose-response curve with variable Hill slope given by parameter 'p'. Origin's Category: Pharmacology * Params:                 Names=A1,A2,LOGx0,p                 Meanings=bottom asymptote,top asymptote, center, hill slope Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.BiDoseResp","title":"<code>BiDoseResp(x, A1=-3.3, A2=-2.9, LOGx01=175000, LOGx02=480000, h1=0.1, h2=0.2, p=0.5)</code>","text":"<p>Biphasic Dose Response Function, Origin's Category: Pharmacology * Params:                 Names=A1, A2, LOGx01, LOGx02, h1, h2, p                 Meanings=Bottom, Top, 1<sup>st</sup> EC50, 2<sup>nd</sup> EC50, slope1, slope2, proportion Initiate params: pars = mod.make_params(A1=0, A2=100, LOGx01=-8, LOGx02=-4, h1=0.8, h2=1.2, p=0.5)</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.Carreau","title":"<code>Carreau(x, A1=60, A2=3, t=3.0, a=2.2, n=0.3)</code>","text":"<p>Carreau-Yasuda model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,a,n    &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,transition control factor,power index Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, t=2.0, a=2.2, n=0.2)</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.Cross","title":"<code>Cross(x, A1=0.1, A2=3, t=1000, m=0.9)</code>","text":"<p>Cross model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,m      &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,power index Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p>"},{"location":"util/#thmd.util.fit.user_lmfit.UserLmfit.GammaCFD","title":"<code>GammaCFD(x, y0, A1, a, b)</code>","text":"<p>Gamma cumulative distribution function Origin's Category: Statistics * Params:                 Names = y0,A1,a,b          (A1,a,b &gt;0)                 Meanings = Offset,Amplitude,Shape,Scale Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p>"},{"location":"util/#thmd.util.grid_box","title":"<code>grid_box</code>","text":"<p>Functions:</p> <ul> <li> <code>grid_box_2d</code>             \u2013              <p>devide box into 2d grid, return list of atom-IDs in each slab and list of slab-centers</p> </li> <li> <code>grid_box_1d</code>             \u2013              <p>devide box into 1d slabs, return list of atom-IDs in each slab and list of slab-centers</p> </li> </ul>"},{"location":"util/#thmd.util.grid_box.grid_box_2d","title":"<code>grid_box_2d(points, box, plane='XY', mode='bin_number', grid_size=[20, 20])</code>","text":"<p>devide box into 2d grid, return list of atom-IDs in each slab and list of slab-centers Args:         P          : Nx3 array contain positions of atoms         box        : simulation box         mode       : \"bin_number\" or \"bin_size\"         mode_value : corresponding 'Number-of-bins' or 'size-of-bin'         plane      : on which plane the box will be gridded Returns:         atomIDinCell : 1xBinNumber array of 1xM-vector, contain indices of atoms of each Cell         cellCenter   : 1xBinNumber array of scalar, is center of each slab</p>"},{"location":"util/#thmd.util.grid_box.grid_box_1d","title":"<code>grid_box_1d(points, box, axis='Z', mode='bin_number', grid_size=20)</code>","text":"<p>devide box into 1d slabs, return list of atom-IDs in each slab and list of slab-centers Args:         P          : Nx3 array contain positions of atoms         box        : simulation box         mode       : \"bin_number\" or \"bin_size\"         mode_value : corresponding 'Number-of-bins' or 'size-of-bin'         axis       : on which axis the box will be slabbed Returns:         atomIDinCell : 1xBinNumber array of 1xM arrays, contain indices of atoms of each Slab, array of arrays         geoCenter    : 1xBinNumber array of scalar, is geometry center of each slab         massCenter   : 1xBinNumber array of scalar, is mass center of each slab</p>"},{"location":"util/#thmd.util.many_stuff","title":"<code>many_stuff</code>","text":"<p>Functions:</p> <ul> <li> <code>memory_usage</code>             \u2013              <p>return the memory usage in MB</p> </li> <li> <code>natSorted</code>             \u2013              <p>https://stackoverflow.com/questions/4836710/is-there-a-built-in-function-for-string-natural-sort</p> </li> <li> <code>split_list</code>             \u2013              <p>Should use <code>np.array_split</code> instead</p> </li> <li> <code>find_nearest_value</code>             \u2013              </li> </ul>"},{"location":"util/#thmd.util.many_stuff.memory_usage","title":"<code>memory_usage()</code>","text":"<p>return the memory usage in MB</p>"},{"location":"util/#thmd.util.many_stuff.natSorted","title":"<code>natSorted(mylist)</code>","text":"<p>https://stackoverflow.com/questions/4836710/is-there-a-built-in-function-for-string-natural-sort</p>"},{"location":"util/#thmd.util.many_stuff.split_list","title":"<code>split_list(a, n)</code>","text":"<p>Should use <code>np.array_split</code> instead Args:             a (list): list to be splitted             n (int): number of chunks     Returns:             generator: a generator of splitted list</p>"},{"location":"util/#thmd.util.many_stuff.find_nearest_value","title":"<code>find_nearest_value(array, value)</code>","text":""},{"location":"util/#thmd.util.row_operation","title":"<code>row_operation</code>","text":"<p>Functions:</p> <ul> <li> <code>unique_row</code>             \u2013              <p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X</p> </li> <li> <code>match_row</code>             \u2013              <p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X</p> </li> <li> <code>asvoid</code>             \u2013              <p>Base on: https://stackoverflow.com/questions/38674027/find-the-row-indexes-of-several-values-in-a-numpy-array</p> </li> </ul>"},{"location":"util/#thmd.util.row_operation.unique_row","title":"<code>unique_row(X, tol_decimal=2)</code>","text":"<p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X Args:             X, find_rows    : NxN numpy arrays             tol_decimal : number of digits for round off input data</p>"},{"location":"util/#thmd.util.row_operation.match_row","title":"<code>match_row(X, find_rows, tol_decimal=2)</code>","text":"<p>find match_indices &amp; mismatch_indices of arr(find_rows) in arr(X), return indices of X Args:             X, find_rows    : NxN numpy arrays             tol_decimal : number of digits for round off input data</p>"},{"location":"util/#thmd.util.row_operation.asvoid","title":"<code>asvoid(arr)</code>","text":"<p>Base on: https://stackoverflow.com/questions/38674027/find-the-row-indexes-of-several-values-in-a-numpy-array</p>"},{"location":"util/#thmd.util.string_index","title":"<code>string_index</code>","text":"<p>Functions:</p> <ul> <li> <code>string_index</code>             \u2013              <p>groupSURF index by consecutive-series</p> </li> </ul>"},{"location":"util/#thmd.util.string_index.string_index","title":"<code>string_index(idx_list)</code>","text":"<p>groupSURF index by consecutive-series</p>"},{"location":"util/#thmd.util.unit","title":"<code>unit</code>","text":"<p>This module to convert unit of some physical properties pressure</p> <p>Consider to use this module: https://unyt.readthedocs.io/en/stable/usage.html</p> <p>Functions:</p> <ul> <li> <code>pressure</code>             \u2013              <p>convert unit of pressure</p> </li> <li> <code>force</code>             \u2013              <p>convert unit of force</p> </li> <li> <code>energy</code>             \u2013              <p>convert unit of energy</p> </li> <li> <code>constant</code>             \u2013              <p>list of constants</p> </li> </ul>"},{"location":"util/#thmd.util.unit.pressure","title":"<code>pressure(key_word='all_key')</code>","text":"<p>convert unit of pressure Pa: Pascal atm: standard atmosphere at: technical atmosphere</p> <p>kgf/cm2 = kg/cm2 1 Pa = 1 N/m^2 1 kgf/cm2 = 1</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>               (<code>str</code>, default:                   <code>'all_key'</code> )           \u2013            <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (              <code>float</code> )          \u2013            <p>multiply factor of conversion</p> </li> </ul> <p>Examples:</p> <pre><code>key_word='Pa_atm': convert from Pa (Pascal) to atm (Standard atmosphere)\n</code></pre>"},{"location":"util/#thmd.util.unit.force","title":"<code>force(key_word='all_key')</code>","text":"<p>convert unit of force N: Newton kgf = m.g: kilogram-force (weight: one kilogram of mass in a 9.80665 m/s2 gravitational field) lbf: pound-force p: pond</p> <p>1 N = 1 J/m    (Work = Force.distance) 1 kcal = 4184 J = 4184 N.m = 4184.10^10 N.Angstrom 69.4786 pN = 1 kcal/mol Angstrom.     https://tinyurl.com/yb2gnlhc</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>               (<code>str</code>, default:                   <code>'all_key'</code> )           \u2013            <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (              <code>float</code> )          \u2013            <p>multiply factor of conversion</p> </li> </ul>"},{"location":"util/#thmd.util.unit.energy","title":"<code>energy(key_word='all_key')</code>","text":"<p>convert unit of energy J: Joule W.h: watt-hour cal: calorie (th) hp.h: horsepower hour eV: electron-volt</p> <p>1 J = 1 N.m    (Work = Force.distance) 1J = 1 W.s</p> <p>Parameters:</p> <ul> <li> <code>key_word</code>               (<code>str</code>, default:                   <code>'all_key'</code> )           \u2013            <p>a string to specify units to be converted.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>factor</code> (              <code>float</code> )          \u2013            <p>multiply factor of conversion</p> </li> </ul> <p>Notes         <pre><code>## convert eV to kcal/mol\neV2J = 1/unit_convert.energy('J_eV')\nJ2Jmol = unit_convert.constant('1/mol')\nkj2kcal = 1/unit_convert.energy('kcal/mol_kJ/mol')\neV2kcalmol = eV2J * J2Jmol * 1e-3 *kj2kcal\n</code></pre></p>"},{"location":"util/#thmd.util.unit.constant","title":"<code>constant(key_word='all_key')</code>","text":"<p>list of constants Na = 6.02214076e23  (=1/mol): Avogadro number</p> <p>Parameters:</p> <ul> <li> <code>Ex</code>           \u2013            <p>key_word='Pa_atm': convert from Pa (Pascal) to atm (Standard atmosphere)</p> </li> </ul> <p>Returns:         factor: float, multiply factor of conversion</p>"},{"location":"util_fit/","title":"Util fit","text":""},{"location":"util_fit/#thmd.util.fit","title":"<code>thmd.util.fit</code>","text":"<p>Modules:</p> <ul> <li> <code>curve_intersect</code>           \u2013            </li> <li> <code>fit_root</code>           \u2013            </li> <li> <code>user_lmfit</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>curve_intersect_shapely</code>             \u2013              <p>find the intersection points between 2 lines</p> </li> <li> <code>polyfit</code>             \u2013              <p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients.</p> </li> <li> <code>find_slope</code>             \u2013              <p>Compute slope of a linear relation y = A + B*x.</p> </li> <li> <code>find_roots</code>             \u2013              <p>find roots for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_extrema</code>             \u2013              <p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_convergence</code>             \u2013              <p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> </li> <li> <code>extrapolate</code>             \u2013              </li> </ul>"},{"location":"util_fit/#thmd.util.fit.curve_intersect_shapely","title":"<code>curve_intersect_shapely(line1, line2)</code>","text":"<p>find the intersection points between 2 lines Args:         line1 (array like): Nx2 arrays, contains data points of curve 1         line2 (array like): Nx2 arrays, contains data points of curve 2</p> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.polyfit","title":"<code>polyfit(x, y, deg=1, sigma_y=None, uncert=False, **kwargs)</code>","text":"<p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients. The fitted polynomial(s) are in the form</p> <pre><code>p(x) = a0 + a1*x + a2*x^2 + ... + an*x^n\n</code></pre> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>deg</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>degree of polynomial</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> <li> <code>uncert</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return uncertainties of coefficients. Defaults to False.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional arguments, adapt all args from <code>np.polyfit</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients</p> </li> <li> <code>uncert</code> (              <code>array</code> )          \u2013            <p>1D array of standard deviation of coefficients</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.find_slope","title":"<code>find_slope(x, y)</code>","text":"<p>Compute slope of a linear relation y = A + B*x.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> </ul> Return <p>slope (float): the slope to linear relation</p>"},{"location":"util_fit/#thmd.util.fit.find_roots","title":"<code>find_roots(x, y, order=1)</code>","text":"<p>find roots for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>order of polynomial. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>roots</code> (              <code>list</code> )          \u2013            <p>list of roots</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.find_extrema","title":"<code>find_extrema(x, y, order=2, retun_fit=False)</code>","text":"<p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>order of polynomial. Defaults to 2.</p> </li> <li> <code>retun_fit</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return fitted params. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>list</code> )          \u2013            <p>list of flex points.</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.find_convergence","title":"<code>find_convergence(x, y, tol=1e-06, grid_size=None, convergence_side='right')</code>","text":"<p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x values</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y values</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>tolerance of the slope (dy/dx). Defaults to 1e-6.</p> </li> <li> <code>grid_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>set grid size of x if need to interpolate finer data. Defaults to None.</p> </li> <li> <code>convergence_side</code>               (<code>str</code>, default:                   <code>'right'</code> )           \u2013            <p>find the first x on the left or right side. Defaults to \"right\".</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>best_x, best_y (float): found x and y value that y converge with a tolerance &lt; tol.</p> </li> </ul> Notes <p>Value <code>df['dy'] = df['y'].diff()</code> depends on grid size. Should use <code>df['dy'] = df['y'].diff()/ df['x'].diff()</code>.</p> References <ol> <li>https://docs.scipy.org/doc/scipy/tutorial/interpolate.html</li> </ol>"},{"location":"util_fit/#thmd.util.fit.extrapolate","title":"<code>extrapolate(x, y, left_side: list = None, right_side: list = None, grid_size=0.1) -&gt; tuple[list, list]</code>","text":""},{"location":"util_fit/#thmd.util.fit.curve_intersect","title":"<code>curve_intersect</code>","text":"<p>Functions:</p> <ul> <li> <code>curve_intersect_shapely</code>             \u2013              <p>find the intersection points between 2 lines</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.curve_intersect.curve_intersect_shapely","title":"<code>curve_intersect_shapely(line1, line2)</code>","text":"<p>find the intersection points between 2 lines Args:         line1 (array like): Nx2 arrays, contains data points of curve 1         line2 (array like): Nx2 arrays, contains data points of curve 2</p> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.curve_intersect.___curve_intersect_numpy","title":"<code>___curve_intersect_numpy(curve1, curve2, degree=3, bounds=None)</code>","text":"<p>find the intersection points between 2 curves</p> <p>Parameters:</p> <ul> <li> <code>curve1</code>               (<code>array like</code>)           \u2013            <p>Nx2 arrays in form (x,y), contains data points of curve 1</p> </li> <li> <code>curve2</code>               (<code>array like</code>)           \u2013            <p>Nx2 arrays in form (x,y), contains data points of curve 2</p> </li> <li> <code>degree</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>degree of polynomial function to fit the curve</p> </li> <li> <code>bounds</code>               (<code>tuple</code>, default:                   <code>None</code> )           \u2013            <p>(min, max) of x, to select points in bounds</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Points</code> (              <code>array like</code> )          \u2013            <p>Nx2 arrays, contains data points of intersection points</p> </li> </ul> Refs <p>[1] http://t.ly/2_a-K</p>"},{"location":"util_fit/#thmd.util.fit.fit_root","title":"<code>fit_root</code>","text":"<p>Functions:</p> <ul> <li> <code>polyfit</code>             \u2013              <p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients.</p> </li> <li> <code>find_slope</code>             \u2013              <p>Compute slope of a linear relation y = A + B*x.</p> </li> <li> <code>find_roots</code>             \u2013              <p>find roots for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_extrema</code>             \u2013              <p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> </li> <li> <code>find_convergence</code>             \u2013              <p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> </li> <li> <code>extrapolate</code>             \u2013              </li> </ul>"},{"location":"util_fit/#thmd.util.fit.fit_root.polyfit","title":"<code>polyfit(x, y, deg=1, sigma_y=None, uncert=False, **kwargs)</code>","text":"<p>Polynomial fitting for y = f(x) relation, which returns uncertainties of coefficients. The fitted polynomial(s) are in the form</p> <pre><code>p(x) = a0 + a1*x + a2*x^2 + ... + an*x^n\n</code></pre> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>deg</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>degree of polynomial</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> <li> <code>uncert</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return uncertainties of coefficients. Defaults to False.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>additional arguments, adapt all args from <code>np.polyfit</code></p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients</p> </li> <li> <code>uncert</code> (              <code>array</code> )          \u2013            <p>1D array of standard deviation of coefficients</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.fit_root.find_slope","title":"<code>find_slope(x, y)</code>","text":"<p>Compute slope of a linear relation y = A + B*x.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> </ul> Return <p>slope (float): the slope to linear relation</p>"},{"location":"util_fit/#thmd.util.fit.fit_root.find_roots","title":"<code>find_roots(x, y, order=1)</code>","text":"<p>find roots for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>order of polynomial. Defaults to 1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>roots</code> (              <code>list</code> )          \u2013            <p>list of roots</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.fit_root.find_extrema","title":"<code>find_extrema(x, y, order=2, retun_fit=False)</code>","text":"<p>find extrema points (der=0) for y = f(x) relation in polynomial form.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x value</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y value</p> </li> <li> <code>order</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>order of polynomial. Defaults to 2.</p> </li> <li> <code>retun_fit</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>return fitted params. Defaults to False.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>p</code> (              <code>list</code> )          \u2013            <p>list of flex points.</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.fit_root.find_convergence","title":"<code>find_convergence(x, y, tol=1e-06, grid_size=None, convergence_side='right')</code>","text":"<p>y is a function of x, then find value of x that y converge with a tolerance &lt; tol.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list</code>)           \u2013            <p>a list/array of x values</p> </li> <li> <code>y</code>               (<code>list</code>)           \u2013            <p>a list/array of y values</p> </li> <li> <code>tol</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>tolerance of the slope (dy/dx). Defaults to 1e-6.</p> </li> <li> <code>grid_size</code>               (<code>float</code>, default:                   <code>None</code> )           \u2013            <p>set grid size of x if need to interpolate finer data. Defaults to None.</p> </li> <li> <code>convergence_side</code>               (<code>str</code>, default:                   <code>'right'</code> )           \u2013            <p>find the first x on the left or right side. Defaults to \"right\".</p> </li> </ul> <p>Returns:</p> <ul> <li>           \u2013            <p>best_x, best_y (float): found x and y value that y converge with a tolerance &lt; tol.</p> </li> </ul> Notes <p>Value <code>df['dy'] = df['y'].diff()</code> depends on grid size. Should use <code>df['dy'] = df['y'].diff()/ df['x'].diff()</code>.</p> References <ol> <li>https://docs.scipy.org/doc/scipy/tutorial/interpolate.html</li> </ol>"},{"location":"util_fit/#thmd.util.fit.fit_root.extrapolate","title":"<code>extrapolate(x, y, left_side: list = None, right_side: list = None, grid_size=0.1) -&gt; tuple[list, list]</code>","text":""},{"location":"util_fit/#thmd.util.fit.fit_root.___uncertainty_weighted_fit_linear","title":"<code>___uncertainty_weighted_fit_linear(x, y, sigma_y=None)</code>","text":"<p>Compute uncertainties in coefficients A and B of y = A + B*x from the weighted least square fitting.</p> <p>Apply when the measured data y_i has different uncertainties sigma_y_i, the weights w_i = 1/(sigma_y_i^2).</p> <p>Parameters:</p> <ul> <li> <code>x,y</code>               (<code>array</code>)           \u2013            <p>1D array of x and y data</p> </li> <li> <code>sigma_y</code>               (<code>array</code>, default:                   <code>None</code> )           \u2013            <p>1D array of standard deviation of y data. Use in weighted least square fitting.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>pars</code> (              <code>array</code> )          \u2013            <p>1D array of coefficients A and B</p> </li> <li> <code>uncertainties</code> (              <code>tuple</code> )          \u2013            <p>1D array (sigma_intercept, sigma_slope) of standard deviation of A and B</p> </li> </ul> References <ol> <li>Taylor_1997_An introduction to error analysis: the study of uncertainties in physical measurements, page 198.</li> <li>https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.polyfit.html</li> </ol>"},{"location":"util_fit/#thmd.util.fit.user_lmfit","title":"<code>user_lmfit</code>","text":"<p>Classes:</p> <ul> <li> <code>UserLmfit</code>           \u2013            <p>The class contains set of objective function of fitting use by LMFIT package</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit","title":"<code>UserLmfit</code>","text":"<p>The class contains set of objective function of fitting use by LMFIT package NOTEs: - defined function followed the convection of LMFIT: the first argument of the function is taken as the independent variable, held in independent_vars, and the rest of the functions positional arguments (and, in certain cases, keyword arguments \u2013 see below) are used for Parameter names. https://lmfit.github.io/lmfit-py/model.html - This Class defines curve-forms that are not vailable in LMFIT's built-in models</p> <ul> <li> <p>Attributes:         swType       : (default='RATIONAL') Type of witching function,         r0, d0       : The r_0 parameter of the switching function</p> </li> <li> <p>Methods:         fFunc    : compute &amp; return value and derivation of sw function         fDmax    : estimate value of Dmax</p> </li> </ul> <p>Ex: func = thmd.CurveLib.Linear(x)</p> <p>Methods:</p> <ul> <li> <code>Linear</code>             \u2013              <p>this func is available in LMFIT, just play as an example here</p> </li> <li> <code>inverseTemperature</code>             \u2013              </li> <li> <code>ExpDecay</code>             \u2013              </li> <li> <code>sizeEffect</code>             \u2013              <p>system size-dependence on term N^(\u2154</p> </li> <li> <code>unNormalGaussian</code>             \u2013              <p>The unNormalize Gaussian function</p> </li> <li> <code>NormalGaussian</code>             \u2013              <p>The Normalize Gaussian function</p> </li> <li> <code>sum_2unNormalGaussian</code>             \u2013              <p>The sum of 2 Gaussian function</p> </li> <li> <code>sum_3unNormalGaussian</code>             \u2013              <p>The sum of 3 Gaussian function</p> </li> <li> <code>sum_4unNormalGaussian</code>             \u2013              <p>The sum of 4 Gaussian function</p> </li> <li> <code>sum_5unNormalGaussian</code>             \u2013              <p>The sum of 5 Gaussian function</p> </li> <li> <code>sum_2NormalGaussian</code>             \u2013              <p>The sum of 2 Gaussian function</p> </li> <li> <code>sum_3NormalGaussian</code>             \u2013              <p>The sum of 3 Gaussian function</p> </li> <li> <code>sum_4NormalGaussian</code>             \u2013              <p>The sum of 4 Gaussian function</p> </li> <li> <code>sum_5NormalGaussian</code>             \u2013              <p>The sum of 5 Gaussian function</p> </li> <li> <code>DoseResp</code>             \u2013              <p>Dose-response curve with variable Hill slope given by parameter 'p'.</p> </li> <li> <code>BiDoseResp</code>             \u2013              <p>Biphasic Dose Response Function,</p> </li> <li> <code>Carreau</code>             \u2013              <p>Carreau-Yasuda model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates</p> </li> <li> <code>Cross</code>             \u2013              <p>Cross model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates</p> </li> <li> <code>GammaCFD</code>             \u2013              <p>Gamma cumulative distribution function</p> </li> </ul>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.Linear","title":"<code>Linear(x, a0, a1)</code>","text":"<p>this func is available in LMFIT, just play as an example here</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.inverseTemperature","title":"<code>inverseTemperature(x, a, b)</code>","text":""},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.ExpDecay","title":"<code>ExpDecay(x, A, lambd)</code>","text":""},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sizeEffect","title":"<code>sizeEffect(x, a, b)</code>","text":"<p>system size-dependence on term N^(\u2154</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.unNormalGaussian","title":"<code>unNormalGaussian(x, amp, cen, sig)</code>","text":"<p>The unNormalize Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.NormalGaussian","title":"<code>NormalGaussian(x, amp, cen, sig)</code>","text":"<p>The Normalize Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_2unNormalGaussian","title":"<code>sum_2unNormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code>","text":"<p>The sum of 2 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_3unNormalGaussian","title":"<code>sum_3unNormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code>","text":"<p>The sum of 3 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_4unNormalGaussian","title":"<code>sum_4unNormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code>","text":"<p>The sum of 4 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_5unNormalGaussian","title":"<code>sum_5unNormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code>","text":"<p>The sum of 5 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_2NormalGaussian","title":"<code>sum_2NormalGaussian(x, amp1, amp2, cen1, cen2, sig1, sig2)</code>","text":"<p>The sum of 2 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_3NormalGaussian","title":"<code>sum_3NormalGaussian(x, amp1, amp2, amp3, cen1, cen2, cen3, sig1, sig2, sig3)</code>","text":"<p>The sum of 3 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_4NormalGaussian","title":"<code>sum_4NormalGaussian(x, amp1, amp2, amp3, amp4, cen1, cen2, cen3, cen4, sig1, sig2, sig3, sig4)</code>","text":"<p>The sum of 4 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.sum_5NormalGaussian","title":"<code>sum_5NormalGaussian(x, amp1, amp2, amp3, amp4, amp5, cen1, cen2, cen3, cen4, cen5, sig1, sig2, sig3, sig4, sig5)</code>","text":"<p>The sum of 5 Gaussian function</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.DoseResp","title":"<code>DoseResp(x, A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</code>","text":"<p>Dose-response curve with variable Hill slope given by parameter 'p'. Origin's Category: Pharmacology * Params:                 Names=A1,A2,LOGx0,p                 Meanings=bottom asymptote,top asymptote, center, hill slope Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, LOGx0=480000, p=1.2)</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.BiDoseResp","title":"<code>BiDoseResp(x, A1=-3.3, A2=-2.9, LOGx01=175000, LOGx02=480000, h1=0.1, h2=0.2, p=0.5)</code>","text":"<p>Biphasic Dose Response Function, Origin's Category: Pharmacology * Params:                 Names=A1, A2, LOGx01, LOGx02, h1, h2, p                 Meanings=Bottom, Top, 1<sup>st</sup> EC50, 2<sup>nd</sup> EC50, slope1, slope2, proportion Initiate params: pars = mod.make_params(A1=0, A2=100, LOGx01=-8, LOGx02=-4, h1=0.8, h2=1.2, p=0.5)</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.Carreau","title":"<code>Carreau(x, A1=60, A2=3, t=3.0, a=2.2, n=0.3)</code>","text":"<p>Carreau-Yasuda model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,a,n    &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,transition control factor,power index Initiate params: pars = mod.make_params(A1=-3.3, A2=-2.9, t=2.0, a=2.2, n=0.2)</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.Cross","title":"<code>Cross(x, A1=0.1, A2=3, t=1000, m=0.9)</code>","text":"<p>Cross model to describe pseudoplastic flow with asymptotic viscosities at zero and infinite shear rates Origin's Category: Rheology * Params:                 Names = A1,A2,t,m      &gt;0         (lower bound)                 Meanings = zero shear viscosity,infinite shear viscosity,time constant,power index Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p>"},{"location":"util_fit/#thmd.util.fit.user_lmfit.UserLmfit.GammaCFD","title":"<code>GammaCFD(x, y0, A1, a, b)</code>","text":"<p>Gamma cumulative distribution function Origin's Category: Statistics * Params:                 Names = y0,A1,a,b          (A1,a,b &gt;0)                 Meanings = Offset,Amplitude,Shape,Scale Initiate params: pars = mod.make_params(A1=0.1, A2=3, t=1000, m=0.9)</p>"}]}